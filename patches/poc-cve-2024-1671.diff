diff --git a/args.gn b/args.gn
new file mode 100644
index 0000000000000..cc70c51945eff
--- /dev/null
+++ b/args.gn
@@ -0,0 +1,11 @@
+# Set build arguments here. See `gn help buildargs`.
+dcheck_always_on = false
+is_component_build = false
+# enable_mojo_tracing = true
+is_asan = true
+is_debug = false
+enable_nacl = false
+symbol_level = 0
+sanitizer_coverage_flags = "trace-pc-guard"
+use_sanitizer_coverage = true
+use_external_fuzzing_engine = true
\ No newline at end of file
diff --git a/base/BUILD.gn b/base/BUILD.gn
index 2916d69d2b1db..cb009869b4420 100644
--- a/base/BUILD.gn
+++ b/base/BUILD.gn
@@ -1089,6 +1089,7 @@ component("base") {
     "//build:chromecast_buildflags",
     "//build:chromeos_buildflags",
     "//third_party/abseil-cpp:absl",
+    "//coverage",
   ]
 
   if (build_rust_base_conversions) {
diff --git a/content/browser/browser_main.cc b/content/browser/browser_main.cc
index 87ac9feb51d44..8a9c89d4319d0 100644
--- a/content/browser/browser_main.cc
+++ b/content/browser/browser_main.cc
@@ -13,11 +13,16 @@
 #include "content/browser/browser_main_runner_impl.h"
 #include "content/common/content_constants_internal.h"
 
+#include "coverage/sanitizer_coverage.h"
+#include "base/logging.h"
+
 namespace content {
 
 // Main routine for running as the Browser process.
 int BrowserMain(MainFunctionParams parameters) {
+  LOG(ERROR) << "BrowserMain!!!!!!!!!!!!!!!!!!!!!!!!!!!!!" << std::endl;
   TRACE_EVENT_INSTANT0("startup", "BrowserMain", TRACE_EVENT_SCOPE_THREAD);
+  activate_coverage_browser();
 
   base::CurrentProcess::GetInstance().SetProcessType(
       base::CurrentProcessType::PROCESS_BROWSER);
diff --git a/content/browser/renderer_host/agent_scheduling_group_host.cc b/content/browser/renderer_host/agent_scheduling_group_host.cc
index c2fb50fcc79b1..523d7a8f4283f 100644
--- a/content/browser/renderer_host/agent_scheduling_group_host.cc
+++ b/content/browser/renderer_host/agent_scheduling_group_host.cc
@@ -334,6 +334,13 @@ void AgentSchedulingGroupHost::CreateView(mojom::CreateViewParamsPtr params) {
   DCHECK_EQ(state_, LifecycleState::kBound);
   DCHECK(process_->IsInitializedAndNotDead());
   DCHECK(mojo_remote_.is_bound());
+  LOG(INFO) << "AgentSchedulingGroupHost::CreateView";
+  if (params->outermost_origin.has_value()) {
+    LOG(INFO) << "outermost_origin: " << params->outermost_origin.value();
+  } else {
+      LOG(INFO) << "outermost_origin: null";
+  }
+
   mojo_remote_.get()->CreateView(std::move(params));
 }
 
diff --git a/content/browser/renderer_host/render_frame_host_impl.cc b/content/browser/renderer_host/render_frame_host_impl.cc
index 579fe40f6c502..294ca1af3e0ac 100644
--- a/content/browser/renderer_host/render_frame_host_impl.cc
+++ b/content/browser/renderer_host/render_frame_host_impl.cc
@@ -1955,6 +1955,16 @@ const blink::LocalFrameToken& RenderFrameHostImpl::GetTopFrameToken() {
   return frame->GetFrameToken();
 }
 
+void RenderFrameHostImpl::RequestLastCommittedOrigin(RequestLastCommittedOriginCallback callback){
+  const url::Origin& origin = GetLastCommittedOrigin();
+  std::move(callback).Run(origin);
+}
+
+void RenderFrameHostImpl::RequestProcessLock(RequestProcessLockCallback callback){
+  GURL url = GetProcess()->GetProcessLock().lock_url();
+  std::move(callback).Run(url);
+}
+
 void RenderFrameHostImpl::AudioContextPlaybackStarted(int audio_context_id) {
   delegate_->AudioContextPlaybackStarted(this, audio_context_id);
 }
diff --git a/content/browser/renderer_host/render_frame_host_impl.h b/content/browser/renderer_host/render_frame_host_impl.h
index 55f3ae7e770d2..f0ae1ac59b077 100644
--- a/content/browser/renderer_host/render_frame_host_impl.h
+++ b/content/browser/renderer_host/render_frame_host_impl.h
@@ -392,6 +392,9 @@ class CONTENT_EXPORT RenderFrameHostImpl
   const blink::LocalFrameToken& GetFrameToken() const override;
   const base::UnguessableToken& GetReportingSource() override;
 
+  void RequestLastCommittedOrigin(RequestLastCommittedOriginCallback callback) override;
+  void RequestProcessLock(RequestProcessLockCallback callback) override;
+
   ui::AXTreeID GetAXTreeID() override;
   SiteInstanceImpl* GetSiteInstance() const override;
   RenderProcessHost* GetProcess() const override;
diff --git a/content/common/BUILD.gn b/content/common/BUILD.gn
index 3c5d755932014..d7aefb503dbb1 100644
--- a/content/common/BUILD.gn
+++ b/content/common/BUILD.gn
@@ -328,6 +328,7 @@ source_set("common") {
     "//ui/shell_dialogs",
     "//url",
     "//url/ipc:url_ipc",
+    "//third_party/abseil-cpp:absl",
   ]
 
   defines = []
diff --git a/content/renderer/render_process_impl.cc b/content/renderer/render_process_impl.cc
index 0739558b39122..d6a58c2ea8125 100644
--- a/content/renderer/render_process_impl.cc
+++ b/content/renderer/render_process_impl.cc
@@ -44,6 +44,9 @@
 #include "third_party/blink/public/web/web_frame.h"
 #include "v8/include/v8-initialization.h"
 
+#include "third_party/blink/public/common/ipc_fuzzer/render_process_indicator.h"
+
+
 #if (BUILDFLAG(IS_LINUX) || BUILDFLAG(IS_CHROMEOS)) && \
     (defined(ARCH_CPU_X86_64) || defined(ARCH_CPU_ARM64))
 #define ENABLE_WEB_ASSEMBLY_TRAP_HANDLER_LINUX
@@ -273,6 +276,8 @@ RenderProcessImpl::RenderProcessImpl()
     v8::V8::EnableWebAssemblyTrapHandler(use_v8_signal_handler);
   }
 #endif  // BUILDFLAG(IS_MAC) && defined(ARCH_CPU_X86_64)
+
+::blink::RenderProcessIndicator::GetInstance()->set_renderer();
 }
 
 RenderProcessImpl::~RenderProcessImpl() {
diff --git a/coverage/BUILD.gn b/coverage/BUILD.gn
new file mode 100644
index 0000000000000..6879636458993
--- /dev/null
+++ b/coverage/BUILD.gn
@@ -0,0 +1,6 @@
+source_set("coverage") {
+    sources = [
+    "sanitizer_coverage.cc",
+    "sanitizer_coverage.h"
+    ]
+}
\ No newline at end of file
diff --git a/coverage/sanitizer_coverage.cc b/coverage/sanitizer_coverage.cc
new file mode 100644
index 0000000000000..92c0cf6b02bfe
--- /dev/null
+++ b/coverage/sanitizer_coverage.cc
@@ -0,0 +1,123 @@
+#include "coverage/sanitizer_coverage.h"
+
+#include <fcntl.h> /* For O_* constants */
+#include <stdint.h>
+#include <stdio.h>
+#include <stdlib.h>
+#include <sys/mman.h>
+#include <sys/stat.h> /* For mode constants */
+#include <unistd.h>
+
+#define SHM_SIZE 0x100000
+#define MAX_EDGES ((SHM_SIZE - 4) * 8)
+
+struct shmem_data* cov_all = nullptr;
+struct shmem_data* cov_browser = nullptr;
+
+static const bool once = [](){
+        activate_coverage_all();
+        return true;
+    } ();
+
+#define NO_SANITIZE __attribute__((no_sanitize("all")))
+
+NO_SANITIZE void __sanitizer_cov_trace_pc_guard_init(uint32_t* start,
+                                                     uint32_t* stop) {
+  edges_start = start;
+  edges_stop = stop;
+  fprintf(stderr, "[COV] __sanitizer_cov_trace_pc_guard_init %ld %p %p\n", stop-start, start, stop);
+}
+
+NO_SANITIZE void __sanitizer_cov_trace_pc_guard(uint32_t* guard) {
+  if (coverage_activated == true && *guard != 0) {
+    uint32_t index = *guard;
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
+    cov_all->edges[index / 8] |= 1 << (index % 8);
+    if (browser_coverage_activated) {
+      cov_browser->edges[index / 8] |= 1 << (index % 8);
+    }
+#pragma clang diagnostic pop
+    *guard = 0;
+  }
+}
+
+NO_SANITIZE void map_shmem(const char* id, shmem_data** shmem) {
+    if (!edges_start || !edges_stop) {
+    fprintf(stderr,
+            "[COV] __sanitizer_cov_trace_pc_guard_init was not called!\n");
+    return;
+  }
+
+  if (*shmem) {
+    fprintf(stderr, "[COV] Multiple initialization of shmem\n");
+    _exit(-1);
+  }
+
+  const char* shm_key = getenv(id);
+  fprintf(stderr, "[COV] shm_key: %s\n", shm_key);
+  if (!shm_key) {
+    fprintf(stderr, "[COV] No shared memory bitmap available\n");
+    return;
+  }
+
+  // Create and open shared memory object
+  int fd = shm_open(shm_key,  O_RDWR, 0666); //O_CREAT |
+  if (fd <= -1) {
+    perror("shm_open");
+    fprintf(stderr, "[COV] Failed to open shared memory region\n");
+    _exit(-1);
+  }
+
+  // Set size of shared memory object
+  // if (ftruncate(fd, SHM_SIZE) == -1) {
+  //     perror("ftruncate");
+  //     fprintf(stderr, "[COV] Failed to ftruncate shared memory object\n");
+  //     close(fd);
+  //     _exit(-1);
+  // }
+
+  // Map shared memory object into address space
+  *shmem = (shmem_data*) mmap(nullptr, SHM_SIZE, PROT_READ | PROT_WRITE,
+                                    MAP_SHARED, fd, 0);
+  if (*shmem == MAP_FAILED) {
+    perror("mmap");
+    fprintf(stderr, "[COV] Failed to mmap shared memory region\n");
+    _exit(-1);
+  }
+
+  init_edges(edges_start, edges_stop);
+  (*shmem)->num_edges = static_cast<uint32_t>(edges_stop - edges_start);
+
+  fprintf(stderr,
+          "[COV] edge counters initialized. Shared memory: %s with %u edges\n",
+          shm_key, (*shmem)->num_edges);
+}
+
+NO_SANITIZE void activate_coverage_browser() {
+  map_shmem("COV_BROWSER_SHM_ID", &cov_browser);
+  browser_coverage_activated = true;
+}
+
+NO_SANITIZE void activate_coverage_all() {
+  map_shmem("COV_ALL_SHM_ID", &cov_all);
+  coverage_activated = true;
+}
+
+NO_SANITIZE void init_edges(uint32_t* start, uint32_t* stop) {
+  if (edges_initialized){
+    return;
+  }
+  edges_initialized = true;
+  if (!start || !stop) {
+    return;
+  }
+
+#pragma clang diagnostic push
+#pragma clang diagnostic ignored "-Wunsafe-buffer-usage"
+  uint32_t N = 0;
+  for (uint32_t* x = start; x < stop && N < MAX_EDGES; x++) {
+    *x = ++N;
+  }
+#pragma clang diagnostic pop
+}
\ No newline at end of file
diff --git a/coverage/sanitizer_coverage.h b/coverage/sanitizer_coverage.h
new file mode 100644
index 0000000000000..b21c31797e174
--- /dev/null
+++ b/coverage/sanitizer_coverage.h
@@ -0,0 +1,29 @@
+// sanitizer coverage creates a 
+
+#ifndef COVERAGE_SANITIZER_COVERAGE_H_
+#define COVERAGE_SANITIZER_COVERAGE_H_
+
+#include <stdint.h>
+
+extern "C" {
+  void __sanitizer_cov_trace_pc_guard_init(uint32_t *start, uint32_t *stop);
+  void __sanitizer_cov_trace_pc_guard(uint32_t *guard);
+}
+
+struct shmem_data {
+  uint32_t num_edges;
+  unsigned char edges[];
+};
+
+static bool edges_initialized = false;
+static bool coverage_activated = false;
+static bool browser_coverage_activated = false;
+static uint32_t *edges_start = nullptr;
+static uint32_t *edges_stop = nullptr;
+
+void map_shmem(const char* id, shmem_data** shmem);
+void activate_coverage_all();
+void activate_coverage_browser();
+void init_edges(uint32_t *start, uint32_t *stop);
+
+#endif  // COVERAGE_SANITIZER_COVERAGE_H_
\ No newline at end of file
diff --git a/headless/app/headless_shell.cc b/headless/app/headless_shell.cc
index 02a11f078af54..c0e0c9c3191f9 100644
--- a/headless/app/headless_shell.cc
+++ b/headless/app/headless_shell.cc
@@ -45,6 +45,8 @@
 #include "components/headless/command_handler/headless_command_handler.h"  // nogncheck
 #endif
 
+#include "coverage/sanitizer_coverage.h"
+
 namespace headless {
 
 namespace {
@@ -202,6 +204,9 @@ void HeadlessChildMain(content::ContentMainParams params) {
 }
 
 int HeadlessBrowserMain(content::ContentMainParams params) {
+  LOG(ERROR) << "HeadlessBrowserMain" << std::endl;
+  activate_coverage_browser();
+
 #if DCHECK_IS_ON()
   // The browser can only be initialized once.
   static bool browser_was_initialized;
diff --git a/ipc/ipc_message.cc b/ipc/ipc_message.cc
index 9b9dd7d31c3f9..e4f19c487a7f4 100644
--- a/ipc/ipc_message.cc
+++ b/ipc/ipc_message.cc
@@ -43,6 +43,8 @@ inline uint32_t GetRefNumUpper24() {
 
 namespace IPC {
 
+void (*leakSanitizerCallback)(const char* data, size_t data_len) = nullptr;
+
 //------------------------------------------------------------------------------
 
 Message::~Message() = default;
@@ -73,6 +75,9 @@ Message::Message(int32_t routing_id, uint32_t type, PriorityValue priority)
 Message::Message(const char* data, size_t data_len)
     : base::Pickle(data, data_len) {
   Init();
+  if (leakSanitizerCallback != nullptr) {
+    (*leakSanitizerCallback)(data, data_len);
+  }
 }
 
 Message::Message(const Message& other) : base::Pickle(other) {
diff --git a/ipc/ipc_message.h b/ipc/ipc_message.h
index 0f99a40805ae4..432580c7aafbb 100644
--- a/ipc/ipc_message.h
+++ b/ipc/ipc_message.h
@@ -30,6 +30,9 @@ namespace internal {
 class ChannelReader;
 }  // namespace internal
 
+
+extern void (*leakSanitizerCallback)(const char*, size_t);
+
 //------------------------------------------------------------------------------
 
 struct LogData;
diff --git a/mojo/public/cpp/bindings/lib/message.cc b/mojo/public/cpp/bindings/lib/message.cc
index 5a26dac7ea37f..04fb20ba64012 100644
--- a/mojo/public/cpp/bindings/lib/message.cc
+++ b/mojo/public/cpp/bindings/lib/message.cc
@@ -9,6 +9,7 @@
 #include <stdlib.h>
 
 #include <atomic>
+#include <cstddef>
 #include <string_view>
 #include <tuple>
 #include <utility>
@@ -31,6 +32,9 @@
 
 namespace mojo {
 
+  void (*leakSanitizerCallback)(const char* data, size_t data_len) = nullptr;
+
+
 namespace {
 
 BASE_FEATURE(kMojoBindingsInlineSLS,
@@ -359,6 +363,10 @@ Message Message::CreateFromMessageHandle(ScopedMessageHandle* message_handle) {
       return Message();
     }
 
+    if (::mojo::leakSanitizerCallback != nullptr) {
+      (*::mojo::leakSanitizerCallback)((char*)(buffer), num_bytes);
+    }
+
     return Message(std::move(*message_handle), std::move(handles),
                    internal::Buffer(buffer, num_bytes, num_bytes),
                    true /* serialized */);
@@ -611,6 +619,81 @@ void Message::WriteIntoTrace(perfetto::TracedValue ctx) const {
   }
 }
 
+
+
+bool containsMagicString(const char *data, size_t data_len){
+    size_t MAGIC_LENGTH = 32;
+    char magicString[33] = "8bf18cb9455f4a8e8fa93d14ab5ebb5d";
+  // search for utf-8 magic string
+  if (data_len < MAGIC_LENGTH) {
+    return false;
+  }
+  for (size_t i = 0; i < data_len - MAGIC_LENGTH; i++) {
+    bool found = true;
+    for (size_t j = 0; j < MAGIC_LENGTH; j++) {
+      if (data[i + j] != magicString[j]) {
+        found = false;
+        break;
+      }
+    }
+    if (found) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Basic function to append a character to a buffer, expanding it if necessary
+void appendChar(char *&str, int &len, int &cap, char c) {
+    if (len + 1 >= cap) {
+        cap *= 2;  // Double the capacity
+        char *newStr = new char[cap];  // Allocate new buffer
+        for (int i = 0; i < len; ++i) {
+            newStr[i] = str[i];  // Copy old content
+        }
+        delete[] str;  // Free old buffer
+        str = newStr;
+    }
+    str[len++] = c;  // Append the character
+    str[len] = '\0';  // Null-terminate the string
+}
+
+// Function to append a hexadecimal representation of a byte to a string
+void appendHex(char *&str, int &len, int &cap, unsigned char byte) {
+    const char *hexDigits = "0123456789ABCDEF";
+    appendChar(str, len, cap, hexDigits[byte >> 4]);
+    appendChar(str, len, cap, hexDigits[byte & 0x0F]);
+}
+
+// Main hexDump function that returns a dynamically allocated string
+char* hexDump(const char* data, size_t len) {
+    int capacity = 256;  // Initial capacity of the string
+    char *result = new char[capacity];
+    int resultLen = 0;
+    result[resultLen] = '\0';  // Start with an empty string
+
+    for (size_t i = 0; i < len; ++i) {
+        unsigned char byte = data[i];
+        if (byte >= 0x20 && byte < 0x7E) {  // Printable ASCII range
+            appendChar(result, resultLen, capacity, byte);
+        } else {
+            appendChar(result, resultLen, capacity, '\\');
+            appendChar(result, resultLen, capacity, 'x');
+            appendHex(result, resultLen, capacity, byte);
+        }
+    }
+
+    return result;
+}
+
+void Message::log(const char* interface_name, const char* method_name) const {
+    if (containsMagicString(reinterpret_cast<const char*>(payload()), payload_num_bytes())) {
+        char* dump = hexDump(reinterpret_cast<const char*>(payload()), payload_num_bytes());
+        LOG(INFO) << "[IPC] " << interface_name << "::" << method_name << " " << dump;
+        delete[] dump;
+    }
+}
+
 bool MessageReceiver::PrefersSerializedMessages() {
   return false;
 }
diff --git a/mojo/public/cpp/bindings/message.h b/mojo/public/cpp/bindings/message.h
index 2f3f15970d554..93844a28b75e3 100644
--- a/mojo/public/cpp/bindings/message.h
+++ b/mojo/public/cpp/bindings/message.h
@@ -30,6 +30,9 @@
 
 namespace mojo {
 
+  extern void (*leakSanitizerCallback)(const char*, size_t);
+
+
 class AssociatedGroupController;
 
 using ReportBadMessageCallback =
@@ -129,6 +132,8 @@ class COMPONENT_EXPORT(MOJO_CPP_BINDINGS_BASE) Message {
   // over a ScopedMessageHandle.
   bool IsValid() const;
 
+  void log(const char* interface_name, const char* method_name) const;
+
   // Indicates whether this Message is serialized.
   bool is_serialized() const { return serialized_; }
 
diff --git a/mojo/public/tools/bindings/BUILD.gn b/mojo/public/tools/bindings/BUILD.gn
index eeca73ea3d56c..51c49a833e76f 100644
--- a/mojo/public/tools/bindings/BUILD.gn
+++ b/mojo/public/tools/bindings/BUILD.gn
@@ -97,6 +97,7 @@ action("precompile_templates") {
     "$mojom_generator_root/generators/ts_templates/module_definition.tmpl",
     "$mojom_generator_root/generators/ts_templates/struct_definition.tmpl",
     "$mojom_generator_root/generators/ts_templates/union_definition.tmpl",
+    "$mojom_generator_root/generators/cpp_templates/interface_fuzzer.tmpl",
   ]
   script = mojom_generator_script
 
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
index 28aaa299ab302..36ab934fae82c 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
@@ -1,5 +1,6 @@
 {%- import "interface_macros.tmpl" as interface_macros %}
 {%- import "struct_macros.tmpl" as struct_macros %}
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
 
 {%- set class_name = interface.name %}
 {%- set proxy_name = interface.name ~ "Proxy" %}
@@ -243,8 +244,10 @@ class {{class_name}}_{{method.name}}_ForwardToCallback
 {%-   endif %}
 
 {%-   if method.sync %}
-bool {{proxy_name}}::{{method.name}}(
-    {{interface_macros.declare_sync_method_params("param_", method)}}) {
+bool {{proxy_name}}::{{method.name}}({{interface_fuzzer.declare_sync_method_params_fuzzed(qualified_class_name,"param_", method)}}) {
+{{interface_fuzzer.insert_fuzzer_hook(qualified_class_name,"param_", method.parameters, method.name)}}
+// WORK
+
 #if BUILDFLAG(MOJO_TRACE_ENABLED)
 {%-     set event_name = "Call %s::%s::%s (sync)" % (namespace_as_string,
                                                     class_name, method.name) %}
@@ -289,6 +292,8 @@ bool {{proxy_name}}::{{method.name}}(
   message.set_method_name("{{method.name}}");
 #endif
 
+  message.log("{{proxy_name}}","{{method.name}}");
+
   bool result = false;
   std::unique_ptr<mojo::MessageReceiver> responder(
       new {{class_name}}_{{method.name}}_HandleSyncResponse(
@@ -309,8 +314,10 @@ bool {{proxy_name}}::{{method.name}}(
 }
 {%-   endif %}  {#- if method.sync #}
 
-void {{proxy_name}}::{{method.name}}(
-    {{interface_macros.declare_request_params("in_", method)}}) {
+void {{proxy_name}}::{{method.name}}({{interface_fuzzer.declare_request_params_fuzzed(qualified_class_name, "in_", method)}}) {
+{{interface_fuzzer.insert_fuzzer_hook(qualified_class_name,"in_", method.parameters, method.name)}}
+// WORK
+
 #if BUILDFLAG(MOJO_TRACE_ENABLED)
 {%- set event_name = "Send %s::%s::%s" % (namespace_as_string, class_name,
                                           method.name) %}
@@ -465,6 +472,7 @@ bool {{class_name}}_{{method.name}}_ForwardToCallback::Accept(
 
 void {{class_name}}_{{method.name}}_ProxyToResponder::Run(
     {{interface_macros.declare_params("in_", method.response_parameters)}}) {
+{{interface_fuzzer.insert_fuzzer_return_hook(qualified_class_name,"in_", method.response_parameters)}}
 #if BUILDFLAG(MOJO_TRACE_ENABLED)
 {%-     set event_name = "Send reply %s::%s::%s"
                % (namespace_as_string, class_name, method.name) %}
@@ -496,6 +504,7 @@ void {{class_name}}_{{method.name}}_ProxyToResponder::Run(
 
   message.set_request_id(request_id_);
   message.set_trace_nonce(trace_nonce_);
+  message.log("{{proxy_name}}","{{method.name}}");
   ::mojo::internal::SendMojoMessage(*responder_, message);
   // SendMojoMessage() fails silently if the responder connection is closed,
   // or if the message is malformed.
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl
new file mode 100644
index 0000000000000..91e80d87dec27
--- /dev/null
+++ b/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl
@@ -0,0 +1,196 @@
+{%- import "interface_macros.tmpl" as interface_macros %}
+
+{# "::network::mojom::blink::NetworkContext" #}
+{%- set classes_to_fuzz = ["::blink::mojom::blink::BlobURLStore", "::network::mojom::blink::RestrictedCookieManager", "::blink::mojom::blink::FileSystemManager", "::network::mojom::blink::NetworkContext", "::blink::mojom::blink::DomStorage", "::network::mojom::blink::URLLoaderFactory", "::blink::mojom::blink::RemoteFrameHost", "::blink::mojom::blink::LocalFrameHost", "::content::mojom::FrameHost", "::blink::mojom::blink::BackgroundFetchService", "::content::mojom::NavigationClient"] %}
+{%- set other_classes = ["::content_settings::mojom::ContentSettingsManager"] %}
+{%- set privileged_interfaces = ["CookieEncryptionProvider", "CookieManager", "TrustedURLLoaderHeaderClient", "NetworkContext", "NetworkService", "UDPSocket", "RemoteInterfaces", "LocalStorageControl", "ServiceWorkerStorageControl", "CacheStorageControl", "AuctionWorkletService", "AudioStreamFactory", "AudioService", "GeolocationConfig", "TracingService", "ConsumerHost", "FrameSinkManager", "DisplayPrivate"] %}
+
+{%- macro insert_fuzzer_hook(qualified_class_name, prefix, parameters, method_name) %}
+// {{qualified_class_name}}
+
+{# log all IPC calls that have interesting parameters #}
+{%-   for param in parameters %}
+{%-   if param.is_interesting  %}
+{# DLOG(ERROR) << "PARAM {{qualified_class_name}}::{{method_name}}() - {{param.kind|cpp_wrapper_param_type}} {{prefix}}{{param.name}}" << {{prefix}}{{param.name}}->charset ; #}
+{%-   endif %}
+{%-   endfor %}
+
+{%- if qualified_class_name in classes_to_fuzz %}
+// FUZZME
+{# DLOG(INFO) << "IPCFuzzer intercept function: {{qualified_class_name}}::{{method_name}}()"; #}
+{%-   for param in parameters %}
+{# /* {{param.kind|cpp_wrapper_param_type}} */ #}
+{%-   if param.is_mutated  %}
+{%- if param.kind|cpp_wrapper_param_type == "const ::blink::KURL&" %}
+std::unique_ptr<const ::blink::KURL> {{prefix}}{{param.name}}_mutated = ::blink::BlinkIPCFuzzerCore::mutate_kurl_hook({{prefix}}{{param.name}}_original);
+const ::blink::KURL& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::GURL&" %}
+std::unique_ptr<const ::GURL> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_gurl_hook({{prefix}}{{param.name}}_original);
+const ::GURL& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::net::SiteForCookies&" %}
+std::unique_ptr<const ::net::SiteForCookies> {{prefix}}{{param.name}}_mutated = ::blink::BlinkIPCFuzzerCore::mutate_site_for_cookies_hook({{prefix}}{{param.name}}_original);
+const ::net::SiteForCookies& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::scoped_refptr<const ::blink::SecurityOrigin>&" %}
+::scoped_refptr<const ::blink::SecurityOrigin> {{prefix}}{{param.name}}_mutated = ::blink::BlinkIPCFuzzerCore::mutate_security_origin_hook({{prefix}}{{param.name}}_original);
+const ::scoped_refptr<const ::blink::SecurityOrigin>& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? {{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const std::optional<::blink::BlinkSchemefulSite>&" %}
+std::optional<::blink::BlinkSchemefulSite> {{prefix}}{{param.name}}_mutated = ::blink::BlinkIPCFuzzerCore::mutate_schemeful_site_hook({{prefix}}{{param.name}}_original);
+const std::optional<::blink::BlinkSchemefulSite>& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated.has_value()) ? {{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::blink::BlinkStorageKey&" %}
+std::unique_ptr<const ::blink::BlinkStorageKey> {{prefix}}{{param.name}}_mutated = ::blink::BlinkIPCFuzzerCore::mutate_storage_key_hook({{prefix}}{{param.name}}_original);
+const ::blink::BlinkStorageKey& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::url::Origin&" %}
+std::unique_ptr<const ::url::Origin> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_origin_hook({{prefix}}{{param.name}}_original);
+const ::url::Origin& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "::blink::mojom::OpenURLParamsPtr" -%}
+::blink::IPCFuzzerCore::GetInstance()->mutate_open_url_params_ptr_hook({{prefix}}{{param.name}});
+{%- elif  param.kind|cpp_wrapper_param_type == "OpenURLParamsPtr" -%}
+::blink::BlinkIPCFuzzerCore::mutate_open_url_params_ptr_hook({{prefix}}{{param.name}});
+{%- elif param.kind|cpp_wrapper_param_type == "::blink::mojom::FetchAPIRequestPtr" -%}
+::blink::IPCFuzzerCore::GetInstance()->mutate_fetch_api_request_ptr_hook({{prefix}}{{param.name}});
+{%- elif  param.kind|cpp_wrapper_param_type == "FetchAPIRequestPtr" -%}
+::blink::BlinkIPCFuzzerCore::mutate_fetch_api_request_ptr_hook({{prefix}}{{param.name}});
+{%- elif param.kind|cpp_wrapper_param_type == "::network::mojom::TrustedUrlRequestParams" -%}
+::blink::IPCFuzzerCore::GetInstance()->mutate_trusted_url_request_params_ptr_hook({{prefix}}{{param.name}});
+{%- elif  param.kind|cpp_wrapper_param_type == "::network::mojom::blink::TrustedUrlRequestParamsPtr" -%}
+{# DLOG(ERROR) << "CHECK_LIFETIME " << {{prefix}}{{param.name}}->url; #}
+::blink::BlinkIPCFuzzerCore::mutate_trusted_url_request_params_ptr_hook({{prefix}}{{param.name}});
+{# DLOG(ERROR) << "CHECK_AGAIN " << {{prefix}}{{param.name}}->url; #}
+{%- elif param.kind|cpp_wrapper_param_type == "::network::mojom::URLRequestPtr" -%}
+::blink::IPCFuzzerCore::GetInstance()->mutate_url_request_ptr_hook({{prefix}}{{param.name}});
+{%- elif  param.kind|cpp_wrapper_param_type == "::network::mojom::blink::URLRequestPtr" -%}
+{# DLOG(ERROR) << "CHECK_LIFETIME " << {{prefix}}{{param.name}}->url; #}
+::blink::BlinkIPCFuzzerCore::mutate_url_request_ptr_hook({{prefix}}{{param.name}});
+{# DLOG(ERROR) << "CHECK_AGAIN " << {{prefix}}{{param.name}}->url; #}
+{%- elif param.kind|cpp_wrapper_param_type == "const ::network::ResourceRequest&" -%}
+std::unique_ptr<const ::network::ResourceRequest> {{prefix}}{{param.name}}_mutated = ::blink::BlinkIPCFuzzerCore::mutate_ressource_request_hook({{prefix}}{{param.name}}_original);
+const ::network::ResourceRequest& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "CreateNewWindowParamsPtr" -%}
+::blink::IPCFuzzerCore::GetInstance()->mutate_create_new_window_params_ptr_hook({{prefix}}{{param.name}});
+{%- elif param.kind|cpp_wrapper_param_type == "::content::mojom::DidCommitProvisionalLoadParamsPtr" %}
+{# DLOG(ERROR) << "CHECK_LIFETIME " << {{prefix}}{{param.name}}->url << " " << {{prefix}}{{param.name}}->origin; #}
+::blink::IPCFuzzerCore::GetInstance()->mutate_did_commit_provisional_load_params_ptr_hook({{prefix}}{{param.name}});
+{# DLOG(ERROR) << "CHECK_AGAIN " << {{prefix}}{{param.name}}->url << " " << {{prefix}}{{param.name}}->origin; #}
+{%- else -%}
+DLOG(ERROR) << "UNCOVERED {{param.kind|cpp_wrapper_param_type}}";
+{%- endif %}
+{%-   endif %}
+{%-   endfor %}
+{%-   endif %} {#- if qualified_class_name in classes_to_fuzz #}
+{%- endmacro %}
+
+
+{%- macro insert_fuzzer_dependency(all_interfaces, all_namespaces, variant, type) %}
+{%- set insert_condition = namespace(bool=false) %}
+{%- set class_namespace = "::" %}
+{%- if all_namespaces|length > 1 %}
+{%- set class_namespace = class_namespace ~ all_namespaces|join("::") ~ "::" ~ (variant ~ "::" if variant) %}
+{%- endif %}
+
+{%- for interface in all_interfaces %}
+{%- set class_name = interface.name %}
+{%- set qualified_class_name = class_namespace ~ class_name %}
+  {%- if qualified_class_name in classes_to_fuzz %}
+    {%- set insert_condition.bool = true %}
+  {%- endif %}
+{%- endfor %}
+
+{%-   if insert_condition.bool  %}
+#include "base/logging.h"
+{% if type == "obj" %}
+#include "third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h"
+{% endif %}
+{% if "blink" in class_namespace %}
+#include "third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.h"
+{% endif %}
+{%-   endif %} {#- if insert_condition.bool #}
+{%- endmacro %}
+
+{%- macro declare_params_mutated(prefix, parameters) %}
+{%-   for param in parameters -%}
+{{param.kind|cpp_wrapper_param_type}} {{prefix}}{{param.name}}{{"_original" if param.is_mutated and "const" in param.kind|cpp_wrapper_param_type else ""}}
+{%- if not loop.last %}, {% endif %}
+{%-   endfor %}
+{%- endmacro %}
+
+{%- macro declare_sync_method_params_mutated(prefix, method) -%}
+{{declare_params_mutated(prefix, method.parameters)}}
+{%-   if method.response_parameters %}
+{%-     if method.parameters %}, {% endif %}
+{%-     for param in method.response_parameters -%}
+{{param.kind|cpp_wrapper_call_type}}* out_{{prefix}}{{param.name}}
+{%-       if not loop.last %}, {% endif %}
+{%-     endfor %}
+{%-   endif -%}
+{%- endmacro -%}
+
+{%- macro declare_request_params_mutated(prefix, method) -%}
+{{declare_params_mutated(prefix, method.parameters)}}
+{%-   if method.response_parameters != None -%}
+{%-     if method.parameters %}, {% endif -%}
+{{method.name}}Callback callback
+{%-   endif -%}
+{%- endmacro -%}
+
+{%- macro declare_request_params_fuzzed(qualified_class_name, prefix, method) -%}
+{%- if qualified_class_name in classes_to_fuzz %}
+{{declare_request_params_mutated(prefix, method)}}
+{%- else %}
+{{interface_macros.declare_request_params(prefix, method)}}
+{%- endif %}
+{%- endmacro -%}
+
+{%- macro declare_sync_method_params_fuzzed(qualified_class_name, prefix, method) -%}
+{%- if qualified_class_name in classes_to_fuzz %}
+{{declare_sync_method_params_mutated(prefix, method)}}
+{%- else %}
+{{interface_macros.declare_sync_method_params(prefix, method)}}
+{%- endif %}
+{%- endmacro -%}
+
+
+{%- macro insert_fuzzer_return_hook(qualified_class_name, prefix, parameters) %}
+// {{qualified_class_name}}
+
+{# log all IPC calls that have interesting parameters #}
+{%-   for param in parameters %}
+{%-   if param.is_mutated or param.is_interesting  %}
+{# DLOG(INFO) << "PARAM {{qualified_class_name}}::{{method_name}}() - {{param.kind|cpp_wrapper_param_type}} {{prefix}}{{param.name}}"; #}
+{%-   endif %}
+{%-   endfor %}
+
+{%- if qualified_class_name in classes_to_fuzz %}
+// FUZZME
+{# DLOG(INFO) << "IPCFuzzer intercept function: {{qualified_class_name}}::{{method_name}}()"; #}
+{%-   for param in parameters %}
+{# /* {{param.kind|cpp_wrapper_param_type}} */ #}
+{%-   if param.is_mutated_return  %}
+{%- if param.kind|cpp_wrapper_param_type == "DidCommitProvisionalLoadParamsPtr" %}
+{# DLOG(ERROR) << "CHECK_LIFETIME " << {{prefix}}{{param.name}}->url << " " << {{prefix}}{{param.name}}->origin; #}
+::blink::IPCFuzzerCore::GetInstance()->mutate_did_commit_provisional_load_params_ptr_hook({{prefix}}{{param.name}});
+{# DLOG(ERROR) << "CHECK_AGAIN " << {{prefix}}{{param.name}}->url << " " << {{prefix}}{{param.name}}->origin; #}
+{%- else -%}
+DLOG(ERROR) << "UNCOVERED {{param.kind|cpp_wrapper_param_type}}";
+{%- endif %}
+{%-   endif %}
+{%-   endfor %}
+{%-   endif %} {#- if qualified_class_name in classes_to_fuzz #}
+{%- endmacro %}
+
+{%- macro insert_process_check(interface_name) %}
+{%- if interface_name in privileged_interfaces %}
+::blink::RenderProcessIndicator::GetInstance()->crash_if_renderer("{{interface_name}}");
+{%- endif %}
+{%- endmacro%}
+
+{%- macro insert_process_check_dependency(all_interfaces) %}
+{%- set insert_condition = namespace(bool=false) %}
+{%- for interface in all_interfaces %}
+  {%- if interface.name in privileged_interfaces %}
+    {%- set insert_condition.bool = true %}
+  {%- endif %}
+{%- endfor %}
+{%-   if insert_condition.bool  %}
+#include "third_party/blink/public/common/ipc_fuzzer/render_process_indicator.h"
+{%- endif %}
+{%- endmacro%}
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
index dcdaf29fc8a42..8ed529a9de36b 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
@@ -1,3 +1,4 @@
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
 // Copyright 2016 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
@@ -25,6 +26,9 @@
 #include "{{header}}"
 {%- endfor %}
 
+{{interface_fuzzer.insert_fuzzer_dependency(interfaces, namespaces_as_array, none, "shared")}}
+{{interface_fuzzer.insert_process_check_dependency(interfaces)}}
+
 {%- for namespace in namespaces_as_array %}
 namespace {{namespace}} {
 {%- endfor %}
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
index 57b94d28b6f23..e247e2dc00896 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
@@ -1,3 +1,4 @@
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
 // Copyright 2013 The Chromium Authors
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
@@ -51,6 +52,9 @@
 #include "{{header}}"
 {%- endfor %}
 
+{{interface_fuzzer.insert_fuzzer_dependency(interfaces, namespaces_as_array, variant, "obj")}}
+{{interface_fuzzer.insert_process_check_dependency(interfaces)}}
+
 {{namespace_begin(namespaces_as_array, variant)}}
 
 {#--- Constants #}
diff --git a/mojo/public/tools/mojom/mojom/generate/module.py b/mojo/public/tools/mojom/mojom/generate/module.py
index ca5c8b4c3a786..a78b29a08c81e 100644
--- a/mojo/public/tools/mojom/mojom/generate/module.py
+++ b/mojo/public/tools/mojom/mojom/generate/module.py
@@ -1177,6 +1177,54 @@ class Parameter:
     return self.attributes.get(ATTRIBUTE_MIN_VERSION) \
         if self.attributes else None
 
+  @property
+  def is_mutated(self):
+    # is one of the parameters types targeted by the IPC fuzzer mutation?
+    if not isinstance(self.kind, Struct):
+      return False
+    if self.kind.module is None or not isinstance(self.kind.module, Module):
+      return False
+    if self.kind.mojom_name == 'Url' and self.kind.module.mojom_namespace == 'url.mojom':
+      return True
+    if self.kind.mojom_name == 'SiteForCookies' and self.kind.module.mojom_namespace == 'network.mojom':
+      return True
+    if self.kind.mojom_name == 'SchemefulSite' and self.kind.module.mojom_namespace == 'network.mojom':
+      return True
+    if self.kind.mojom_name == 'Origin' and self.kind.module.mojom_namespace == 'url.mojom':
+      return True
+    if self.kind.mojom_name == 'StorageKey' and self.kind.module.mojom_namespace == 'blink.mojom':
+      return True
+    if self.kind.mojom_name == "OpenURLParams" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True
+    if self.kind.mojom_name == "FetchAPIRequest" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True # probably not relevant
+    if self.kind.mojom_name == "TrustedUrlRequestParams" and self.kind.module.mojom_namespace == "network.mojom":
+      return True
+    if self.kind.mojom_name == "URLRequest" and self.kind.module.mojom_namespace == "network.mojom":
+      return True
+    if self.kind.mojom_name == "CreateNewWindowParams" and self.kind.module.mojom_namespace == "content.mojom":
+      return True
+    if self.kind.mojom_name == 'DidCommitProvisionalLoadParams' and self.kind.module.mojom_namespace == 'content.mojom':
+      return True
+    return False
+
+  @property
+  def is_mutated_return(self):
+    # is one of the parameters types targeted by the IPC fuzzer mutation?
+    if not isinstance(self.kind, Struct):
+      return False
+    if self.kind.module is None or not isinstance(self.kind.module, Module):
+      return False
+    if self.kind.mojom_name == 'DidCommitProvisionalLoadParams' and self.kind.module.mojom_namespace == 'content.mojom':
+      return True
+    return False
+
+  @property
+  def is_interesting(self):
+    if self.kind.mojom_name == "URLResponseHeadPtr" or self.kind.mojom_name == "URLResponseHead":# and self.kind.module.mojom_namespace == "blink.mojom":
+      return True
+    return False
+
   def __eq__(self, rhs):
     return (isinstance(rhs, Parameter)
             and (self.mojom_name, self.ordinal, self.kind, self.default,
diff --git a/third_party/blink/common/BUILD.gn b/third_party/blink/common/BUILD.gn
index b60de1fafafdd..c203fdc94b071 100644
--- a/third_party/blink/common/BUILD.gn
+++ b/third_party/blink/common/BUILD.gn
@@ -301,6 +301,11 @@ source_set("common") {
     "widget/device_emulation_params_mojom_traits.cc",
     "widget/visual_properties.cc",
     "widget/visual_properties_mojom_traits.cc",
+    "ipc_fuzzer/mutation.cc",
+    "ipc_fuzzer/mutation_store.cc",
+    "ipc_fuzzer/ipc_fuzzer_core.cc",
+    "ipc_fuzzer/mutator.cc",
+    "ipc_fuzzer/render_process_indicator.cc",
   ]
 
   sources += get_target_outputs(":make_generated_document_policy_features")
@@ -342,6 +347,7 @@ source_set("common") {
     "//ui/events:events_base",
     "//ui/events/mojom:event_latency_metadata_mojom",
     "//ui/latency/mojom:shared_mojom_traits",
+    "//ipc:message_support",
   ]
 
   if (enable_rust_crash) {
diff --git a/third_party/blink/common/ipc_fuzzer/ipc_fuzzer_core.cc b/third_party/blink/common/ipc_fuzzer/ipc_fuzzer_core.cc
new file mode 100644
index 0000000000000..597c84d88522f
--- /dev/null
+++ b/third_party/blink/common/ipc_fuzzer/ipc_fuzzer_core.cc
@@ -0,0 +1,368 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h"
+#include "third_party/blink/public/common/ipc_fuzzer/mutator.h"
+
+// #include <csignal>
+#include <csignal>
+#include "base/logging.h"
+#include "base/memory/singleton.h"
+// #include "third_party/blink/renderer/modules/ipc_fuzzer/mutator.h"
+#include "url/gurl.h"
+#include "url/origin.h"
+#include "ipc/ipc_message.h"
+#include "mojo/public/cpp/bindings/message.h"
+
+
+
+// #include "third_party/blink/public/common/navigation/navigation_params.h"
+// #include
+// "third_party/blink/public/mojom/navigation/navigation_params.mojom-blink.h"
+// #include
+// "third_party/blink/public/mojom/navigation/navigation_params.mojom.h"
+
+namespace blink {
+
+char magicString[MAGIC_LENGTH+1] = "8bf18cb9455f4a8e8fa93d14ab5ebb5d";
+
+bool containsMagicString(const char *data, size_t data_len){
+  // search for utf-8 magic string
+  if (data_len < MAGIC_LENGTH) {
+    return false;
+  }
+  for (size_t i = 0; i < data_len - MAGIC_LENGTH; i++) {
+    bool found = true;
+    for (size_t j = 0; j < MAGIC_LENGTH; j++) {
+      if (data[i + j] != magicString[j]) {
+        found = false;
+        break;
+      }
+    }
+    if (found) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Basic function to append a character to a buffer, expanding it if necessary
+void appendChar(char *&str, int &len, int &cap, char c) {
+    if (len + 1 >= cap) {
+        cap *= 2;  // Double the capacity
+        char *newStr = new char[cap];  // Allocate new buffer
+        for (int i = 0; i < len; ++i) {
+            newStr[i] = str[i];  // Copy old content
+        }
+        delete[] str;  // Free old buffer
+        str = newStr;
+    }
+    str[len++] = c;  // Append the character
+    str[len] = '\0';  // Null-terminate the string
+}
+
+// Function to append a hexadecimal representation of a byte to a string
+void appendHex(char *&str, int &len, int &cap, unsigned char byte) {
+    const char *hexDigits = "0123456789ABCDEF";
+    appendChar(str, len, cap, hexDigits[byte >> 4]);
+    appendChar(str, len, cap, hexDigits[byte & 0x0F]);
+}
+
+// Main hexDump function that returns a dynamically allocated string
+char* hexDump(const char* data, size_t len) {
+    int capacity = 256;  // Initial capacity of the string
+    char *result = new char[capacity];
+    int resultLen = 0;
+    result[resultLen] = '\0';  // Start with an empty string
+
+    for (size_t i = 0; i < len; ++i) {
+        unsigned char byte = data[i];
+        if (byte >= 0x20 && byte < 0x7E) {  // Printable ASCII range
+            appendChar(result, resultLen, capacity, byte);
+        } else {
+            appendChar(result, resultLen, capacity, '\\');
+            appendChar(result, resultLen, capacity, 'x');
+            appendHex(result, resultLen, capacity, byte);
+        }
+    }
+
+    return result;
+}
+
+void leakSanitizer(const char* data, size_t data_len) {
+  // char* output = hexDump(data, data_len);
+  // LOG(ERROR) << output;
+  // delete[] output;
+
+  if (data != nullptr && data_len > 0 && containsMagicString(data, data_len)) {
+    char* output = hexDump(data, data_len);
+    LOG(ERROR) << "[UXSS] leak in IPC message: " << output;
+    delete[] output;
+  }
+}
+
+IPCFuzzerCore* IPCFuzzerCore::GetInstance() {
+  return ::base::Singleton<IPCFuzzerCore>::get();
+}
+
+IPCFuzzerCore::IPCFuzzerCore()
+    : url_mutation_store_(),
+      security_origin_mutation_store_(),
+      schemeful_site_mutation_store_(),
+      site_for_cookies_mutation_store_(),
+      storage_key_mutation_store_(),
+      lock_(),
+      locked_site_(std::nullopt) {
+  LOG(INFO) << "RENDERER PROCESS";
+  sigignore(SIGTERM);
+}
+
+IPCFuzzerCore::~IPCFuzzerCore() = default;
+
+// todo ignore kill signals
+void IPCFuzzerCore::send_detach() {
+  // LOG(INFO) << "send detach message to browser";
+}
+
+// void IPCFuzzerCore::register_document(const KURL& url) {
+//   url_store_.store(url);
+// }
+
+// WTF::Vector<WTF::String> IPCFuzzerCore::leak() {
+//   // WTF::String result;
+//   // for (const WTF::String& s : url_store_.get()) {
+//   //   result = result + s + "\n";
+//   // }
+//   // return result;
+//   return url_store_.get();
+// }
+
+void IPCFuzzerCore::deactivate_renderer_checks() {
+  checks_deactivated = true;
+}
+
+void IPCFuzzerCore::activate_leak_sanitizer() {
+  ::IPC::leakSanitizerCallback = &leakSanitizer;
+  ::mojo::leakSanitizerCallback = &leakSanitizer;
+}
+
+void IPCFuzzerCore::enqueue_mutation(Mutation::TARGET target,
+                                     Mutation::KIND kind,
+                                     std::string url) {
+  switch (target) {
+    case Mutation::TARGET::URL:
+      url_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::ORIGIN:
+      security_origin_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::SITE_FOR_COOKIES:
+      site_for_cookies_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::SCHEMEFUL_SITE:
+      schemeful_site_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::STORAGE_KEY:
+      storage_key_mutation_store_.enqueue(target, kind, url);
+      break;
+  }
+}
+
+// WTF::String IPCFuzzerCore::list_mutations() {
+//   // return mutation_store_.to_string();
+//   // TODO fix for multiple stores
+//   return "";
+// }
+
+// std::unique_ptr<const KURL> IPCFuzzerCore::mutate_kurl_hook(const KURL& url)
+// {
+//   // LOG(INFO) << "IPCFuzzerCore intercept value: KURL " << url;
+//   std::unique_ptr<Mutation> mutation = url_mutation_store_.dequeue();
+
+//   if (mutation == nullptr) {
+//     return nullptr;
+//   }
+
+//   return Mutator::mutate_url(url, *mutation);
+// }
+
+std::unique_ptr<const ::GURL> IPCFuzzerCore::mutate_gurl_hook(
+    const ::GURL& url) {
+  // LOG(INFO) << "IPCFuzzerCore intercept value: GURL " << url;
+
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->url_mutation_store_.dequeue();
+
+  if (mutation != nullptr) {
+    return Mutator::mutate_url(url, *mutation);
+  }
+
+  return nullptr;
+}
+
+// ::scoped_refptr<const SecurityOrigin>
+// IPCFuzzerCore::mutate_security_origin_hook(
+//     const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+//   // if (security_origin != nullptr) {
+//   //   LOG(INFO) << "IPCFuzzerCore intercept value: SecurityOrigin "
+//   //              << security_origin->ToString();
+//   // }
+
+//   std::unique_ptr<Mutation> mutation =
+//       security_origin_mutation_store_.dequeue();
+
+//   if (mutation == nullptr) {
+//     return nullptr;
+//   }
+
+//   return Mutator::mutate_security_origin(security_origin, *mutation);
+// }
+
+// std::optional<BlinkSchemefulSite> IPCFuzzerCore::mutate_schemeful_site_hook(
+//     const std::optional<BlinkSchemefulSite>& schemeful_site) {
+//   // if (schemeful_site.has_value()) {
+//   //   LOG(INFO) << "IPCFuzzerCore intercept value: BlinkSchemefulSite "
+//   //              << schemeful_site.value().GetDebugString();
+//   // }
+
+//   // TODO: only dequeue mutation if IPCFuzzerCore intercept value:ed param
+//   has
+//   // value?
+//   std::unique_ptr<Mutation> mutation =
+//   schemeful_site_mutation_store_.dequeue();
+
+//   if (mutation == nullptr) {
+//     return std::nullopt;
+//   }
+
+//   return Mutator::mutate_schemeful_site(schemeful_site, *mutation);
+// }
+
+// std::unique_ptr<const ::net::SiteForCookies>
+// IPCFuzzerCore::mutate_site_for_cookies_hook(
+//     const ::net::SiteForCookies& site_for_cookies) {
+//   // LOG(INFO) << "IPCFuzzerCore intercept value: SiteForCookies "
+//   //            << site_for_cookies.ToDebugString();
+
+//   std::unique_ptr<Mutation> mutation =
+//       site_for_cookies_mutation_store_.dequeue();
+
+//   if (mutation == nullptr) {
+//     return nullptr;
+//   }
+
+//   return Mutator::mutate_site_for_cookies(site_for_cookies, *mutation);
+// }
+
+// std::unique_ptr<const BlinkStorageKey>
+// IPCFuzzerCore::mutate_storage_key_hook(
+//     const BlinkStorageKey& storage_key) {
+//   // LOG(INFO) << "IPCFuzzerCore intercept value: BlinkStorageKey "
+//   //            << storage_key.ToDebugString();
+
+//   std::unique_ptr<Mutation> mutation = storage_key_mutation_store_.dequeue();
+
+//   if (mutation == nullptr) {
+//     return nullptr;
+//   }
+
+//   return Mutator::mutate_storage_key(storage_key, *mutation);
+// }
+
+std::unique_ptr<const ::url::Origin> IPCFuzzerCore::mutate_origin_hook(
+    const ::url::Origin& origin) {
+  // LOG(INFO) << "IPCFuzzerCore intercept value: Origin " <<
+  // origin.Serialize();
+
+    std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->security_origin_mutation_store_.dequeue();
+
+  if (mutation != nullptr) {
+    return Mutator::mutate_origin(origin, *mutation);
+  }
+  return nullptr;
+}
+
+void IPCFuzzerCore::mutate_create_new_window_params_ptr_hook(
+    ::content::mojom::CreateNewWindowParamsPtr& ptr) {
+  // LOG(ERROR) << "CONTENT_IPC IPCFuzzerCore intercepted
+  // CreateNewWindowParamsPtr "
+  //             << ptr->target_url;
+}
+
+void IPCFuzzerCore::mutate_open_url_params_ptr_hook(
+    ::blink::mojom::OpenURLParamsPtr& ptr) {
+  LOG(ERROR) << "CONTENT_IPC IPCFuzzerCore intercepted OpenURLParamsPtr "
+             << ptr->url;
+
+  // ::blink::mojom::OpenURLParamsPtr mutated = ptr.Clone();
+
+  // return std::make_unique<::blink::mojom::OpenURLParamsPtr>(ptr.Clone());
+  // return nullptr;
+}
+
+void IPCFuzzerCore::mutate_fetch_api_request_ptr_hook(
+    ::blink::mojom::FetchAPIRequestPtr& ptr) {
+  LOG(ERROR) << "CONTENT_IPC IPCFuzzerCore intercepted FetchAPIRequestPtr "
+             << ptr->url;
+}
+
+void IPCFuzzerCore::mutate_trusted_url_request_params_ptr_hook(
+    ::network::mojom::TrustedUrlRequestParamsPtr& ptr) {
+  LOG(ERROR)
+      << "CONTENT_IPC IPCFuzzerCore intercepted TrustedUrlRequestParamsPtr";
+}
+void IPCFuzzerCore::mutate_url_request_ptr_hook(
+    ::network::mojom::URLRequestPtr& ptr) {
+  LOG(ERROR) << "CONTENT_IPC IPCFuzzerCore intercepted URLRequestPtr "
+             << ptr->url;
+}
+
+void IPCFuzzerCore::mutate_did_commit_provisional_load_params_ptr_hook(
+    ::content::mojom::DidCommitProvisionalLoadParamsPtr& ptr) {
+  // LOG(ERROR) << "CONTENT_IPC IPCFuzzerCore intercepted "
+  //               "DidCommitProvisionalLoadParamsPtr "
+  //            << ptr->url;
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->url_mutation_store_.dequeue();
+
+  if (mutation != nullptr) {
+    std::unique_ptr<GURL> mutated = Mutator::mutate_url(ptr->url, *mutation);
+    if (mutated != nullptr) {
+      ptr->url = *mutated;
+    }
+  }
+
+  mutation =
+      IPCFuzzerCore::GetInstance()->security_origin_mutation_store_.dequeue();
+
+  if (mutation != nullptr) {
+    std::unique_ptr<::url::Origin> mutated = Mutator::mutate_origin(ptr->origin, *mutation);
+    if (mutated != nullptr) {
+      ptr->origin = *mutated;
+    }
+  }
+}
+
+bool IPCFuzzerCore::check_isolation(const std::string& schemeful_site) {
+  lock_.Acquire();
+  if (locked_site_.has_value()) {
+    if (locked_site_.value() == schemeful_site) {
+      LOG(INFO) << "CHECK LOCK " << schemeful_site;
+      lock_.Release();
+      return false;
+    } else {
+      LOG(ERROR) << "[blink] [UXSS] " << schemeful_site << " "
+                 << locked_site_.value();
+      lock_.Release();
+      return true;
+    }
+
+  } else {
+    locked_site_ = schemeful_site;
+    lock_.Release();
+    LOG(INFO) << "LOCK " << schemeful_site;
+    return false;
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/common/ipc_fuzzer/mutation.cc b/third_party/blink/common/ipc_fuzzer/mutation.cc
new file mode 100644
index 0000000000000..23726e4af13f7
--- /dev/null
+++ b/third_party/blink/common/ipc_fuzzer/mutation.cc
@@ -0,0 +1,41 @@
+#include "third_party/blink/public/common/ipc_fuzzer/mutation.h"
+
+namespace blink {
+std::string Mutation::to_string() const {
+  std::string target_str;
+  switch (target_) {
+    case Mutation::TARGET::URL:
+      target_str = "URL";
+      break;
+    case Mutation::TARGET::ORIGIN:
+      target_str = "ORIGIN";
+      break;
+    case Mutation::TARGET::SITE_FOR_COOKIES:
+      target_str = "SITE_FOR_COOKIES";
+      break;
+    case Mutation::TARGET::SCHEMEFUL_SITE:
+      target_str = "SCHEMEFUL_SITE";
+      break;
+    case Mutation::TARGET::STORAGE_KEY:
+      target_str = "STORAGE_KEY";
+      break;
+  }
+
+  std::string kind_str;
+  switch (kind_) {
+    case Mutation::KIND::REPLACE_HOST:
+      kind_str = "REPLACE_HOST";
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      kind_str = "REPLACE_WHOLE";
+      break;
+  }
+
+  std::string result = std::string("{'target':'") + target_str +
+                       std::string("', 'kind':'") + kind_str +
+                       std::string("', 'url':'") + url_.possibly_invalid_spec() +
+                       std::string("'}");
+  return result;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/common/ipc_fuzzer/mutation_store.cc b/third_party/blink/common/ipc_fuzzer/mutation_store.cc
new file mode 100644
index 0000000000000..ef27858ff942a
--- /dev/null
+++ b/third_party/blink/common/ipc_fuzzer/mutation_store.cc
@@ -0,0 +1,73 @@
+#include "third_party/blink/public/common/ipc_fuzzer/mutation_store.h"
+#include "base/logging.h"
+
+namespace blink {
+MutationStore::MutationStore() = default;
+MutationStore::~MutationStore() = default;
+
+void MutationStore::enqueue(Mutation::TARGET target,
+                            Mutation::KIND kind,
+                            std::string url) {
+  ::GURL parsed_url(url);
+  std::unique_ptr<Mutation> mutation =
+      std::make_unique<Mutation>(target, kind, std::move(parsed_url));
+  LOG(INFO) << "IPCFuzzer enqueue mutation: " << mutation->to_string();
+
+  lock_.Acquire();
+  mutations_.push_back(std::move(mutation));
+  lock_.Release();
+}
+
+void MutationStore::enqueue(Mutation mutation) {
+  LOG(INFO) << "IPCFuzzer enqueue mutation: " << mutation.to_string();
+  lock_.Acquire();
+  mutations_.emplace_back(std::make_unique<Mutation>(std::move(mutation)));
+  lock_.Release();
+}
+
+std::unique_ptr<Mutation> MutationStore::dequeue_match(
+    const Mutation::TARGET& target) {
+  lock_.Acquire();
+  if (mutations_.size() == 0) {
+    lock_.Release();
+    return nullptr;
+  }
+
+  if (mutations_.front()->get_target() == target) {
+    std::unique_ptr<Mutation> mutation = std::move(mutations_.front());
+    mutations_.erase(mutations_.begin());
+    lock_.Release();
+    return mutation;
+  }
+  lock_.Release();
+  return nullptr;
+}
+
+std::unique_ptr<Mutation> MutationStore::dequeue() {
+  lock_.Acquire();
+  if (mutations_.size() == 0) {
+    lock_.Release();
+    return nullptr;
+  }
+
+  std::unique_ptr<Mutation> mutation = std::move(mutations_.front());
+  mutations_.erase(mutations_.begin());
+  lock_.Release();
+  return mutation;
+}
+
+std::string MutationStore::to_string() {
+  std::string result = "[";
+  lock_.Acquire();
+  for (const auto& m : mutations_) {
+    result = result + m->to_string();
+    if (&m != &mutations_.back()) {
+      result = result + ",";
+    }
+  }
+  lock_.Release();
+  result = result + "]";
+  return result;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/common/ipc_fuzzer/mutator.cc b/third_party/blink/common/ipc_fuzzer/mutator.cc
new file mode 100644
index 0000000000000..d147f5bf0e868
--- /dev/null
+++ b/third_party/blink/common/ipc_fuzzer/mutator.cc
@@ -0,0 +1,326 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/public/common/ipc_fuzzer/mutator.h"
+#include "base/logging.h"
+#include "url/gurl.h"
+#include "url/url_canon.h"
+#include "url/origin.h"
+
+
+namespace blink {
+
+std::unique_ptr<GURL> Mutator::mutate_url(const GURL& url,
+                                                const Mutation& mutation) {
+  std::unique_ptr<GURL> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      return url_replace_host(url, mutation.get_url());
+    case Mutation::KIND::REPLACE_WHOLE:
+      return std::make_unique<GURL>(mutation.get_url());
+  }
+  // if (mutated != nullptr) {
+  //   LOG(INFO) << "IPCFuzzer mutated: KURL " << *mutated;
+  // }
+}
+
+std::unique_ptr<::url::Origin> Mutator::mutate_origin(
+    const ::url::Origin& origin,
+    const Mutation& mutation) {
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      return origin_replace_host(origin, mutation.get_url());
+    case Mutation::KIND::REPLACE_WHOLE:
+      return std::make_unique<::url::Origin>(::url::Origin::Create(mutation.get_url()));
+  }
+}
+
+std::unique_ptr<::url::Origin> Mutator::origin_replace_host(
+    const ::url::Origin& origin,
+    const GURL& replacement) {
+  if (origin.opaque()) {
+    return nullptr;
+  }
+
+  std::unique_ptr<const GURL> mutated_url =
+      url_replace_host(origin.GetURL(), replacement);
+  if (mutated_url != nullptr) {
+    return std::make_unique<::url::Origin>(::url::Origin::Create(*mutated_url));
+  }
+  return nullptr;
+}
+
+// return optional because that is used by all Mojo functions
+// std::optional<BlinkSchemefulSite> Mutator::mutate_schemeful_site(
+//     const std::optional<BlinkSchemefulSite>& schemeful_site,
+//     const Mutation& mutation) {
+//   std::optional<BlinkSchemefulSite> mutated = std::nullopt;
+//   switch (mutation.get_kind()) {
+//     case Mutation::KIND::REPLACE_HOST:
+//       mutated = schemeful_site_replace_host(schemeful_site,
+//       KURL(mutation.get_url())); break;
+//     case Mutation::KIND::REPLACE_WHOLE: {
+//       auto security_origin = SecurityOrigin::CreateWithReferenceOrigin(
+//           KURL(mutation.get_url()), nullptr);
+//       mutated = BlinkSchemefulSite(security_origin);
+//     } break;
+//   }
+//   // if (mutated.has_value()) {
+//   //   LOG(INFO) << "IPCFuzzer mutated: BlinkSchemefulSite "
+//   //              << mutated.value().GetDebugString();
+//   // }
+//   return mutated;
+// }
+
+// std::unique_ptr<const ::net::SiteForCookies>
+// Mutator::mutate_site_for_cookies(
+//     const ::net::SiteForCookies& site_for_cookies,
+//     const Mutation& mutation) {
+//   std::unique_ptr<const ::net::SiteForCookies> mutated = nullptr;
+//   switch (mutation.get_kind()) {
+//     case Mutation::KIND::REPLACE_HOST:
+//       mutated =
+//           site_for_cookies_replace_host(site_for_cookies,
+//           KURL(mutation.get_url()));
+//       break;
+//     case Mutation::KIND::REPLACE_WHOLE:
+//       mutated = std::make_unique<const ::net::SiteForCookies>(
+//           ::net::SiteForCookies::FromUrl(GURL(KURL(mutation.get_url()))));
+//       break;
+//   }
+//   // if (mutated != nullptr) {KURL(mutation.get_url())
+//   //   LOG(INFO) << "IPCFuzzer mutated: SiteForCookies "
+//   //              << mutated->ToDebugString();
+//   // }
+//   return mutated;
+// }
+
+// TODO: implement more different mutations
+// std::unique_ptr<const BlinkStorageKey> Mutator::mutate_storage_key(
+//     const BlinkStorageKey& storage_key,
+//     const Mutation& mutation) {
+//   std::unique_ptr<const BlinkStorageKey> mutated = nullptr;
+//   switch (mutation.get_kind()) {
+//     case Mutation::KIND::REPLACE_HOST:
+//       mutated = storage_key_replace_host(storage_key,
+//       KURL(mutation.get_url())); break;
+//     case Mutation::KIND::REPLACE_WHOLE:
+//       if (storage_key.GetTopLevelSite().IsOpaque()) {
+//         mutated = create_storage_key(KURL(mutation.get_url()));
+//       } else {
+//         mutated = create_storage_key(KURL(mutation.get_url()),
+//                                      storage_key.GetAncestorChainBit());
+//       }
+//       break;
+//   }
+//   // if (mutated != nullptr) {
+//   //   LOG(INFO) << "IPCFuzzer mutated: BlinkStorageKey "
+//   //              << mutated->ToDebugString();
+//   // }
+//   return mutated;
+// }
+
+// private helper functions
+
+std::unique_ptr<GURL> Mutator::url_replace_host(const GURL& url,
+                                                const GURL& replacement) {
+  if (!can_replace_host(url)) {
+    return url_replace_inner_host(url, replacement);
+  }
+
+  ::url::StringViewReplacements<char> url_replacements;
+  auto host_str = replacement.host(); // Store host string in a local variable
+auto port_str = replacement.port(); // Store port string in a local variable
+
+url_replacements.SetHostStr(host_str.c_str());
+url_replacements.SetPortStr(port_str.c_str());
+
+  return std::make_unique<GURL>(url.ReplaceComponents(url_replacements));
+}
+
+std::unique_ptr<GURL> Mutator::url_replace_inner_host(const GURL& url,
+                                                      const GURL& replacement) {
+  if (!can_replace_inner_host(url)) {
+    return nullptr;
+  }
+
+  std::string protocol;
+  if (url.SchemeIsBlob()) {
+    protocol = "blob:";
+  } else if (url.SchemeIsFileSystem()) {
+    protocol = "filesystem:";
+  }
+
+  const GURL* inner_url = url.inner_url();
+
+  ::url::StringViewReplacements<char> url_replacements;
+ auto host_str = replacement.host(); // Store host string in a local variable
+auto port_str = replacement.port(); // Store port string in a local variable
+
+url_replacements.SetHostStr(host_str.c_str());
+url_replacements.SetPortStr(port_str.c_str());
+
+  GURL mutated_inner_url = inner_url->ReplaceComponents(url_replacements);
+
+  std::string new_url = protocol + mutated_inner_url.spec();
+
+  return std::make_unique<GURL>(new_url);
+}
+
+// ::scoped_refptr<const SecurityOrigin>
+// Mutator::security_origin_replace_host(
+//     const ::scoped_refptr<const SecurityOrigin>& security_origin,
+//     const KURL& replacement) {
+//   if (!can_replace_host(security_origin)) {
+//     return nullptr;
+//   }
+//   KURL url(security_origin->ToString());
+
+//   std::unique_ptr<blink::KURL> new_url = url_replace_host(url, replacement);
+//   if (new_url == nullptr) {
+//     // replacing host failed
+//     return nullptr;
+//   }
+
+//   return SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+// }
+
+// std::optional<BlinkSchemefulSite>
+// Mutator::schemeful_site_replace_host(
+//     const std::optional<BlinkSchemefulSite>& schemeful_site,
+//     const KURL& replacement) {
+//   if (!can_replace_host(schemeful_site)) {
+//     return std::nullopt;
+//   }
+
+//   String schemeful_site_str = schemeful_site.value().Serialize();
+
+//   std::unique_ptr<KURL> new_url =
+//       url_replace_host(KURL(schemeful_site_str), replacement);
+//   if (new_url == nullptr) {
+//     return std::nullopt;
+//   }
+
+//   auto origin =
+//       SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+//   return BlinkSchemefulSite(origin);
+// }
+
+// std::unique_ptr<::net::SiteForCookies>
+// Mutator::site_for_cookies_replace_host(
+//     const ::net::SiteForCookies& site_for_cookies,
+//     const KURL& replacement) {
+//   if (!can_replace_host(site_for_cookies)) {
+//     return nullptr;
+//   }
+
+//   GURL url = site_for_cookies.RepresentativeUrl();
+//   std::unique_ptr<KURL> new_url =
+//       url_replace_host(KURL(url), replacement);
+//   if (new_url == nullptr) {
+//     return nullptr;
+//   }
+
+//   return std::make_unique<::net::SiteForCookies>(
+//       ::net::SiteForCookies::FromUrl(GURL(*new_url)));
+// }
+
+// std::unique_ptr<BlinkStorageKey> Mutator::storage_key_replace_host(
+//     const BlinkStorageKey& storage_key,
+//     const KURL& replacement) {
+//   auto security_origin = storage_key.GetSecurityOrigin();
+//   ::scoped_refptr<const SecurityOrigin> new_security_origin =
+//       security_origin_replace_host(security_origin, replacement);
+//   if (new_security_origin == nullptr) {
+//     return nullptr;
+//   }
+
+//   // if the storage key has a nonce, just replace the host and reuse the
+//   // nonce
+//   // QUESTION: is this right??
+//   auto token = storage_key.GetNonce();
+//   if (token.has_value()) {
+//     return std::make_unique<BlinkStorageKey>(
+//         BlinkStorageKey::CreateWithNonce(new_security_origin,
+//                                                   token.value()));
+//   }
+
+//   auto schemeful_site = storage_key.GetTopLevelSite();
+//   std::optional<BlinkSchemefulSite> new_schemeful_site =
+//       schemeful_site_replace_host(schemeful_site, replacement);
+//   if (new_schemeful_site.has_value()) {
+//     return std::make_unique<BlinkStorageKey>(
+//         BlinkStorageKey::Create(new_security_origin,
+//                                          new_schemeful_site.value(),
+//                                          storage_key.GetAncestorChainBit()));
+//   }
+
+//   return std::make_unique<BlinkStorageKey>(
+//       BlinkStorageKey::CreateFirstParty(new_security_origin));
+// }
+
+// std::unique_ptr<BlinkStorageKey> Mutator::create_storage_key(
+//     const KURL& url) {
+//   auto security_origin =
+//       SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+//   return std::make_unique<BlinkStorageKey>(
+//       BlinkStorageKey::CreateFirstParty(security_origin));
+// }
+
+// std::unique_ptr<BlinkStorageKey> Mutator::create_storage_key(
+//     const KURL& url,
+//     mojom::AncestorChainBit ancestor_chain_bit) {
+//   auto security_origin =
+//       SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+//   auto schemeful_site = BlinkSchemefulSite(security_origin);
+//   return std::make_unique<BlinkStorageKey>(
+//       BlinkStorageKey::Create(security_origin, schemeful_site,
+//                                        ancestor_chain_bit));
+// }
+
+bool Mutator::can_replace_host(const GURL& url) {
+  if (url.is_empty()) {
+    // LOG(INFO) << "IPCFuzzer KURL is empty";
+    return false;
+  }
+  if (url.SchemeIsBlob() || url.SchemeIsFileSystem()) {
+    return false;
+  }
+  return true;
+}
+
+bool Mutator::can_replace_inner_host(const GURL& url) {
+  if (url.SchemeIsBlob() || url.SchemeIsFileSystem()) {
+    return true;
+  }
+  return false;
+}
+
+// bool Mutator::can_replace_host(
+//     const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+//   if (security_origin == nullptr || security_origin->IsOpaque()) {
+//     return false;
+//   }
+//   return true;
+// }
+
+// bool Mutator::can_replace_host(
+//     const std::optional<BlinkSchemefulSite>& schemeful_site) {
+//   if (!schemeful_site.has_value()) {
+//     return false;
+//   }
+//   if (schemeful_site.value().IsOpaque() ||
+//       schemeful_site.value().Serialize() == "null") {
+//     return false;
+//   }
+//   return true;
+// }
+
+// bool Mutator::can_replace_host(const ::net::SiteForCookies& site_for_cookies)
+// {
+//   if (site_for_cookies.IsNull()) {
+//     return false;
+//   }
+//   return true;
+// }
+
+}  // namespace blink
diff --git a/third_party/blink/common/ipc_fuzzer/render_process_indicator.cc b/third_party/blink/common/ipc_fuzzer/render_process_indicator.cc
new file mode 100644
index 0000000000000..2245c8190a424
--- /dev/null
+++ b/third_party/blink/common/ipc_fuzzer/render_process_indicator.cc
@@ -0,0 +1,30 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/public/common/ipc_fuzzer/render_process_indicator.h"
+#include "base/logging.h"
+
+namespace blink {
+
+RenderProcessIndicator* RenderProcessIndicator::GetInstance() {
+  return ::base::Singleton<RenderProcessIndicator>::get();
+}
+
+RenderProcessIndicator::RenderProcessIndicator() {}
+
+RenderProcessIndicator::~RenderProcessIndicator() = default;
+
+void RenderProcessIndicator::set_renderer() {
+  LOG(ERROR) << "SET RENDERER";
+  is_renderer = true;
+}
+
+void RenderProcessIndicator::crash_if_renderer(std::string interface) {
+  DCHECK(!is_renderer);
+
+  if (is_renderer) {
+    LOG(ERROR) << "Exploding Handle " << interface;
+    _exit(1);
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/public/common/BUILD.gn b/third_party/blink/public/common/BUILD.gn
index 8b812ec2f49a0..de339b2392f19 100644
--- a/third_party/blink/public/common/BUILD.gn
+++ b/third_party/blink/public/common/BUILD.gn
@@ -315,6 +315,11 @@ source_set("headers") {
     "widget/constants.h",
     "widget/device_emulation_params.h",
     "widget/visual_properties.h",
+    "ipc_fuzzer/mutation.h",
+    "ipc_fuzzer/mutation_store.h",
+    "ipc_fuzzer/ipc_fuzzer_core.h",
+    "ipc_fuzzer/mutator.h",
+    "ipc_fuzzer/render_process_indicator.h",
   ]
 
   sources += get_target_outputs(":make_generated_permissions_policy_helper")
diff --git a/third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h b/third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h
new file mode 100644
index 0000000000000..0861d1f1c18e9
--- /dev/null
+++ b/third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h
@@ -0,0 +1,116 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_IPC_FUZZER_CORE_H_
+#define THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_IPC_FUZZER_CORE_H_
+
+#include <memory>
+#include "base/memory/singleton.h"
+#include "third_party/blink/public/common/ipc_fuzzer/mutation.h"
+#include "third_party/blink/public/common/ipc_fuzzer/mutation_store.h"
+#include "url/gurl.h"
+#include "url/origin.h"
+// #include "content/common/frame.mojom.h"
+#include "content/common/frame.mojom.h"
+#include "services/network/public/mojom/url_request.mojom.h"
+#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom.h"
+#include "third_party/blink/public/mojom/frame/remote_frame.mojom.h"
+
+// #include "net/cookies/site_for_cookies.h"
+// #include "third_party/blink/renderer/modules/ipc_fuzzer/url_store.h"
+// #include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+// #include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+// #include "third_party/blink/renderer/platform/weborigin/kurl.h"
+// #include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+namespace base {
+template <typename T>
+struct DefaultSingletonTraits;
+}
+
+namespace blink {
+    #define MAGIC_LENGTH 32
+    extern char magicString[MAGIC_LENGTH+1];
+
+    extern void leak_sanitizer(const char* data, size_t data_len);
+    bool containsMagicString(const char* data, size_t data_len);
+    char* hexDump(const char* data, size_t len);
+    void appendHex(char *&str, int &len, int &cap, unsigned char byte);
+    void appendChar(char *&str, int &len, int &cap, char c);
+
+class IPCFuzzerCore {
+  friend class BlinkIPCFuzzerCore;
+
+ public:
+  ~IPCFuzzerCore();
+
+  static IPCFuzzerCore* GetInstance();
+
+  IPCFuzzerCore(const IPCFuzzerCore&) = delete;
+  IPCFuzzerCore& operator=(const IPCFuzzerCore&) = delete;
+
+  // JS bindings
+  void enqueue_mutation(Mutation::TARGET target,
+                        Mutation::KIND kind,
+                        std::string url);
+  void send_detach();
+
+  bool check_isolation(const std::string& schemeful_site);
+
+  void deactivate_renderer_checks();
+  bool checks_deactivated = false;
+
+  void activate_leak_sanitizer();
+
+  // fuzzer hooks
+
+  //   std::unique_ptr<const KURL> mutate_kurl_hook(const KURL& url);
+
+  std::unique_ptr<const ::GURL> mutate_gurl_hook(const ::GURL& url);
+
+  ::scoped_refptr<const SecurityOrigin> mutate_security_origin_hook(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin);
+
+  //   std::optional<BlinkSchemefulSite> mutate_schemeful_site_hook(
+  //       const std::optional<BlinkSchemefulSite>& schemeful_site);
+
+  //   std::unique_ptr<const ::net::SiteForCookies>
+  //   mutate_site_for_cookies_hook(
+  //       const ::net::SiteForCookies& site_for_cookies);
+
+  //   std::unique_ptr<const BlinkStorageKey> mutate_storage_key_hook(
+  //       const BlinkStorageKey& storage_key);
+
+  std::unique_ptr<const ::url::Origin> mutate_origin_hook(
+      const ::url::Origin& origin);
+
+  void mutate_open_url_params_ptr_hook(::blink::mojom::OpenURLParamsPtr& ptr);
+  void mutate_fetch_api_request_ptr_hook(
+      ::blink::mojom::FetchAPIRequestPtr& ptr);
+
+  void mutate_trusted_url_request_params_ptr_hook(
+      ::network::mojom::TrustedUrlRequestParamsPtr& ptr);
+  void mutate_url_request_ptr_hook(::network::mojom::URLRequestPtr& ptr);
+
+  void mutate_create_new_window_params_ptr_hook(
+      ::content::mojom::CreateNewWindowParamsPtr& ptr);
+
+  void mutate_did_commit_provisional_load_params_ptr_hook(
+      ::content::mojom::DidCommitProvisionalLoadParamsPtr& ptr);
+
+ private:
+  IPCFuzzerCore();
+  friend struct ::base::DefaultSingletonTraits<IPCFuzzerCore>;
+
+  MutationStore url_mutation_store_;
+  MutationStore security_origin_mutation_store_;
+  MutationStore schemeful_site_mutation_store_;
+  MutationStore site_for_cookies_mutation_store_;
+  MutationStore storage_key_mutation_store_;
+
+  base::Lock lock_;
+  std::optional<std::string> locked_site_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_IPC_FUZZER_CORE_H_
diff --git a/third_party/blink/public/common/ipc_fuzzer/mutation.h b/third_party/blink/public/common/ipc_fuzzer/mutation.h
new file mode 100644
index 0000000000000..8d493964a16ca
--- /dev/null
+++ b/third_party/blink/public/common/ipc_fuzzer/mutation.h
@@ -0,0 +1,42 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATION_H_
+#define THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATION_H_
+
+// #include "third_party/blink/renderer/platform/weborigin/::GURL.h"
+#include <string>
+#include "url/gurl.h"
+
+namespace blink {
+
+class Mutation {
+ public:
+  enum class TARGET {
+    URL,
+    ORIGIN,
+    SITE_FOR_COOKIES,
+    SCHEMEFUL_SITE,
+    STORAGE_KEY,
+  };
+
+  enum class KIND {
+    REPLACE_HOST,
+    REPLACE_WHOLE,
+  };
+
+  Mutation(TARGET target, KIND kind, ::GURL url)
+      : target_(target), kind_(kind), url_(url) {}
+
+  const TARGET& get_target() const { return target_; }
+  const KIND& get_kind() const { return kind_; }
+  const ::GURL& get_url() const { return url_; }
+  std::string to_string() const;
+
+ private:
+  TARGET target_;
+  KIND kind_;
+  ::GURL url_;
+};
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATION_H_
diff --git a/third_party/blink/public/common/ipc_fuzzer/mutation_store.h b/third_party/blink/public/common/ipc_fuzzer/mutation_store.h
new file mode 100644
index 0000000000000..9a7d8db637260
--- /dev/null
+++ b/third_party/blink/public/common/ipc_fuzzer/mutation_store.h
@@ -0,0 +1,29 @@
+#ifndef THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATION_STORE_H_
+#define THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATION_STORE_H_
+
+#include <memory>
+#include <vector>
+#include "base/synchronization/lock.h"
+#include "third_party/blink/public/common/ipc_fuzzer/mutation.h"
+
+namespace blink {
+class MutationStore {
+ public:
+  MutationStore();
+  ~MutationStore();
+
+  void enqueue(Mutation::TARGET target, Mutation::KIND kind, std::string url);
+  void enqueue(Mutation mutation);
+
+  std::unique_ptr<Mutation> dequeue_match(const Mutation::TARGET& target);
+  std::unique_ptr<Mutation> dequeue();
+  std::string to_string();
+
+ private:
+  base::Lock lock_;
+  std::vector<std::unique_ptr<Mutation>> mutations_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATION_STORE_H_
diff --git a/third_party/blink/public/common/ipc_fuzzer/mutator.h b/third_party/blink/public/common/ipc_fuzzer/mutator.h
new file mode 100644
index 0000000000000..075c4462a9061
--- /dev/null
+++ b/third_party/blink/public/common/ipc_fuzzer/mutator.h
@@ -0,0 +1,86 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATOR_H_
+#define THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATOR_H_
+
+#include <memory>
+// #include "net/cookies/site_for_cookies.h"
+#include "third_party/blink/public/common/ipc_fuzzer/mutation.h"
+#include "url/gurl.h"
+#include "url/origin.h"
+
+// #include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+// #include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+// #include "third_party/blink/renderer/platform/weborigin/kurl.h"
+// #include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+namespace blink {
+class Mutator {
+ public:
+  static std::unique_ptr<GURL> mutate_url(const GURL& url,
+                                                const Mutation& mutation);
+
+  static std::unique_ptr<::url::Origin> mutate_origin(const ::url::Origin& origin, const Mutation& mutation);
+
+  // return scoped_refptr because that is used by all Mojo functions
+  //   static ::scoped_refptr<const SecurityOrigin> mutate_security_origin(
+  //       const ::scoped_refptr<const SecurityOrigin>& security_origin,
+  //       const Mutation& mutation);
+
+  //   // return optional because that is used by all Mojo functions
+  //   static std::optional<BlinkSchemefulSite> mutate_schemeful_site(
+  //       const std::optional<BlinkSchemefulSite>& schemeful_site,
+  //       const Mutation& mutation);
+
+  //   static std::unique_ptr<const ::net::SiteForCookies>
+  //   mutate_site_for_cookies(
+  //       const ::net::SiteForCookies& site_for_cookies,
+  //       const Mutation& mutation);
+
+  //   static std::unique_ptr<const BlinkStorageKey> mutate_storage_key(
+  //       const BlinkStorageKey& storage_key,
+  //       const Mutation& mutation);
+
+ private:
+  static std::unique_ptr<GURL> url_replace_host(const GURL& url,
+                                                const GURL& replacement);
+
+  static std::unique_ptr<GURL> url_replace_inner_host(const GURL& url,
+                                                      const GURL& replacement);
+
+  static std::unique_ptr<::url::Origin> origin_replace_host(const ::url::Origin& origin,
+                                                    const GURL& replacement);
+
+  //   static std::optional<BlinkSchemefulSite>
+  //   schemeful_site_replace_host(
+  //       const std::optional<BlinkSchemefulSite>& schemeful_site,
+  //       const KURL& replacement);
+
+  //   static std::unique_ptr<::net::SiteForCookies>
+  //   site_for_cookies_replace_host(
+  //       const ::net::SiteForCookies& site_for_cookies,
+  //       const KURL& replacement);
+
+  //   static std::unique_ptr<BlinkStorageKey> storage_key_replace_host(
+  //       const BlinkStorageKey& storage_key,
+  //       const KURL& replacement);
+
+  //   static std::unique_ptr<BlinkStorageKey> create_storage_key(
+  //       const KURL& url);
+  //   static std::unique_ptr<BlinkStorageKey> create_storage_key(
+  //       const KURL& url,
+  //       mojom::AncestorChainBit ancestor_chain_bit);
+
+  static bool can_replace_host(const GURL& url);
+  static bool can_replace_inner_host(const GURL& url);
+  //   static bool can_replace_host(
+  //       const ::scoped_refptr<const SecurityOrigin>& security_origin);
+  //   static bool can_replace_host(
+  //       const std::optional<BlinkSchemefulSite>& schemeful_site);
+  //   static bool can_replace_host(const ::net::SiteForCookies&
+  //   site_for_cookies);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_MUTATOR_H_
diff --git a/third_party/blink/public/common/ipc_fuzzer/render_process_indicator.h b/third_party/blink/public/common/ipc_fuzzer/render_process_indicator.h
new file mode 100644
index 0000000000000..cc8a87884ec7a
--- /dev/null
+++ b/third_party/blink/public/common/ipc_fuzzer/render_process_indicator.h
@@ -0,0 +1,35 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_RENDER_PROCESS_INDICATOR_H_
+#define THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_RENDER_PROCESS_INDICATOR_H_
+
+#include <memory>
+#include "base/memory/singleton.h"
+
+namespace base {
+template <typename T>
+struct DefaultSingletonTraits;
+}
+
+namespace blink {
+class RenderProcessIndicator {
+ public:
+  ~RenderProcessIndicator();
+
+  static RenderProcessIndicator* GetInstance();
+
+  RenderProcessIndicator(const RenderProcessIndicator&) = delete;
+  RenderProcessIndicator& operator=(const RenderProcessIndicator&) = delete;
+
+  void set_renderer();
+  void crash_if_renderer(std::string interface);
+
+ private:
+  bool is_renderer = false;
+  RenderProcessIndicator();
+  friend struct ::base::DefaultSingletonTraits<RenderProcessIndicator>;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_PUBLIC_COMMON_IPC_FUZZER_RENDER_PROCESS_INDICATOR_H_
diff --git a/third_party/blink/public/mojom/frame/frame.mojom b/third_party/blink/public/mojom/frame/frame.mojom
index 6304eaf5577c5..0d56d66deb1ff 100644
--- a/third_party/blink/public/mojom/frame/frame.mojom
+++ b/third_party/blink/public/mojom/frame/frame.mojom
@@ -729,6 +729,13 @@ interface LocalFrameHost {
                 gfx.mojom.Vector2d cursor_offset_in_dip,
                 gfx.mojom.Rect drag_obj_rect_in_dip,
                 DragEventSourceInfo event_info);
+
+  [Sync]
+  RequestLastCommittedOrigin() => (url.mojom.Origin origin);
+
+  [Sync]
+  RequestProcessLock() => (url.mojom.Url url);
+
 };
 
 // Implemented in Browser, this interface defines frame-specific methods
diff --git a/third_party/blink/renderer/bindings/generated_in_modules.gni b/third_party/blink/renderer/bindings/generated_in_modules.gni
index a7ebcddd92d83..b13349d110642 100644
--- a/third_party/blink/renderer/bindings/generated_in_modules.gni
+++ b/third_party/blink/renderer/bindings/generated_in_modules.gni
@@ -2910,6 +2910,8 @@ generated_interface_sources_in_modules = [
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_layer.h",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_sub_image.cc",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_sub_image.h",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_ipc_fuzzer.cc",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_ipc_fuzzer.h",
 ]
 
 generated_namespace_sources_in_modules = [
diff --git a/third_party/blink/renderer/bindings/idl_in_modules.gni b/third_party/blink/renderer/bindings/idl_in_modules.gni
index 6f42f116ca1b2..a1a9db302fad3 100644
--- a/third_party/blink/renderer/bindings/idl_in_modules.gni
+++ b/third_party/blink/renderer/bindings/idl_in_modules.gni
@@ -1232,6 +1232,7 @@ static_idl_files_in_modules = [
   "//third_party/blink/renderer/modules/xr/xr_webgl_layer.idl",
   "//third_party/blink/renderer/modules/xr/xr_webgl_layer_init.idl",
   "//third_party/blink/renderer/modules/xr/xr_webgl_sub_image.idl",
+  "//third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl",
 ]
 
 # Direct Sockets
diff --git a/third_party/blink/renderer/core/frame/local_frame.cc b/third_party/blink/renderer/core/frame/local_frame.cc
index e3a154d05e4fd..64b5fb335a7e5 100644
--- a/third_party/blink/renderer/core/frame/local_frame.cc
+++ b/third_party/blink/renderer/core/frame/local_frame.cc
@@ -362,8 +362,9 @@ void LocalFrame::Init(Frame* opener,
                       const StorageKey& storage_key,
                       ukm::SourceId document_ukm_source_id,
                       const KURL& creator_base_url) {
-  if (!policy_container)
+  if (!policy_container) {
     policy_container = PolicyContainer::CreateEmpty();
+  }
 
   CoreInitializer::GetInstance().InitLocalFrame(*this);
 
@@ -380,8 +381,9 @@ void LocalFrame::Init(Frame* opener,
 void LocalFrame::SetView(LocalFrameView* view) {
   DCHECK(!view_ || view_ != view);
   DCHECK(!GetDocument() || !GetDocument()->IsActive());
-  if (view_)
+  if (view_) {
     view_->WillBeRemovedFromFrame();
+  }
   view_ = view;
 }
 
@@ -392,8 +394,9 @@ void LocalFrame::CreateView(const gfx::Size& viewport_size,
 
   bool is_local_root = IsLocalRoot();
 
-  if (is_local_root && View())
+  if (is_local_root && View()) {
     View()->SetParentVisible(false);
+  }
 
   SetView(nullptr);
 
@@ -411,8 +414,9 @@ void LocalFrame::CreateView(const gfx::Size& viewport_size,
 
   frame_view->UpdateBaseBackgroundColorRecursively(background_color);
 
-  if (is_local_root)
+  if (is_local_root) {
     frame_view->SetParentVisible(true);
+  }
 
   // FIXME: Not clear what the right thing for OOPI is here.
   if (OwnerLayoutObject()) {
@@ -422,8 +426,9 @@ void LocalFrame::CreateView(const gfx::Size& viewport_size,
     // that it's owned by a FrameOwner that knows nothing about it. If we're
     // lying to this frame, don't let it clobber the existing
     // EmbeddedContentView.
-    if (owner->ContentFrame() == this)
+    if (owner->ContentFrame() == this) {
       owner->SetEmbeddedContentView(frame_view);
+    }
   }
 
   if (Owner()) {
@@ -437,8 +442,9 @@ LocalFrame::~LocalFrame() {
   // the frame owner.
   DCHECK(!view_);
   DCHECK(!frame_color_overlay_);
-  if (IsAdFrame())
+  if (IsAdFrame()) {
     InstanceCounters::DecrementCounter(InstanceCounters::kAdSubframeCounter);
+  }
 }
 
 void LocalFrame::Trace(Visitor* visitor) const {
@@ -481,38 +487,44 @@ void LocalFrame::Trace(Visitor* visitor) const {
 }
 
 bool LocalFrame::IsLocalRoot() const {
-  if (!Tree().Parent())
+  if (!Tree().Parent()) {
     return true;
+  }
 
   return Tree().Parent()->IsRemoteFrame();
 }
 
 void LocalFrame::Navigate(FrameLoadRequest& request,
                           WebFrameLoadType frame_load_type) {
-  if (HTMLFrameOwnerElement* element = DeprecatedLocalOwner())
+  if (HTMLFrameOwnerElement* element = DeprecatedLocalOwner()) {
     element->CancelPendingLazyLoad();
+  }
 
-  if (!navigation_rate_limiter().CanProceed())
+  if (!navigation_rate_limiter().CanProceed()) {
     return;
+  }
 
   TRACE_EVENT2("navigation", "LocalFrame::Navigate", "url",
                request.GetResourceRequest().Url().GetString().Utf8(),
                "load_type", static_cast<int>(frame_load_type));
 
-  if (request.ClientRedirectReason() != ClientNavigationReason::kNone)
+  if (request.ClientRedirectReason() != ClientNavigationReason::kNone) {
     probe::FrameScheduledNavigation(this, request.GetResourceRequest().Url(),
                                     base::TimeDelta(),
                                     request.ClientRedirectReason());
+  }
 
-  if (NavigationShouldReplaceCurrentHistoryEntry(request, frame_load_type))
+  if (NavigationShouldReplaceCurrentHistoryEntry(request, frame_load_type)) {
     frame_load_type = WebFrameLoadType::kReplaceCurrentItem;
+  }
 
   const ClientNavigationReason client_redirect_reason =
       request.ClientRedirectReason();
   loader_.StartNavigation(request, frame_load_type);
 
-  if (client_redirect_reason != ClientNavigationReason::kNone)
+  if (client_redirect_reason != ClientNavigationReason::kNone) {
     probe::FrameClearedScheduledNavigation(this);
+  }
 }
 
 // Much of this function is redundant with the browser process
@@ -651,11 +663,13 @@ bool LocalFrame::DetachImpl(FrameDetachType type) {
     CoreInitializer::GetInstance().EvictSessionStorageCachedData(
         GetDocument()->GetPage());
   }
-  if (!Client())
+  if (!Client()) {
     return false;
+  }
 
-  if (!DetachChildren())
+  if (!DetachChildren()) {
     return false;
+  }
 
   // Detach() needs to be called after detachChildren(), because
   // detachChildren() will trigger the unload event handlers of any child
@@ -676,8 +690,9 @@ bool LocalFrame::DetachImpl(FrameDetachType type) {
   // - FrameLoader::Detach() can fire XHR abort events
   // - Document::Shutdown() can dispose plugins which can run script.
   ScriptForbiddenScope forbid_script;
-  if (!Client())
+  if (!Client()) {
     return false;
+  }
 
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   // END REENTRANCY SAFE BLOCK
@@ -687,27 +702,34 @@ bool LocalFrame::DetachImpl(FrameDetachType type) {
   // !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
   DCHECK(!IsDetached());
 
-  if (frame_color_overlay_)
+  if (frame_color_overlay_) {
     frame_color_overlay_.Release()->Destroy();
+  }
 
   if (IsLocalRoot()) {
     performance_monitor_->Shutdown();
-    if (ad_tracker_)
+    if (ad_tracker_) {
       ad_tracker_->Shutdown();
+    }
     // Unregister only if this is LocalRoot because the paint_image_generator_
     // was created on LocalRoot.
-    if (background_color_paint_image_generator_)
+    if (background_color_paint_image_generator_) {
       background_color_paint_image_generator_->Shutdown();
-    if (box_shadow_paint_image_generator_)
+    }
+    if (box_shadow_paint_image_generator_) {
       box_shadow_paint_image_generator_->Shutdown();
-    if (clip_path_paint_image_generator_)
+    }
+    if (clip_path_paint_image_generator_) {
       clip_path_paint_image_generator_->Shutdown();
+    }
   }
   idleness_detector_->Shutdown();
-  if (inspector_issue_reporter_)
+  if (inspector_issue_reporter_) {
     probe_sink_->RemoveInspectorIssueReporter(inspector_issue_reporter_);
-  if (inspector_trace_events_)
+  }
+  if (inspector_trace_events_) {
     probe_sink_->RemoveInspectorTraceEvents(inspector_trace_events_);
+  }
   inspector_task_runner_->Dispose();
 
   if (content_capture_manager_) {
@@ -715,8 +737,9 @@ bool LocalFrame::DetachImpl(FrameDetachType type) {
     content_capture_manager_ = nullptr;
   }
 
-  if (text_fragment_handler_)
+  if (text_fragment_handler_) {
     text_fragment_handler_->DidDetachDocumentOrFrame();
+  }
 
   not_restored_reasons_.reset();
 
@@ -770,8 +793,9 @@ void LocalFrame::SetBackgroundColorPaintImageGeneratorForTesting(
 BoxShadowPaintImageGenerator* LocalFrame::GetBoxShadowPaintImageGenerator() {
   // There is no compositor thread in certain testing environment, and we should
   // not composite background color animation in those cases.
-  if (!Thread::CompositorThread())
+  if (!Thread::CompositorThread()) {
     return nullptr;
+  }
   LocalFrame& local_root = LocalFrameRoot();
   // One box shadow paint worklet per root frame.
   if (!local_root.box_shadow_paint_image_generator_) {
@@ -885,8 +909,9 @@ void LocalFrame::DidAttachDocument() {
 }
 
 void LocalFrame::OnFirstPaint(bool text_painted, bool image_painted) {
-  if (notified_color_scheme_)
+  if (notified_color_scheme_) {
     return;
+  }
 
   if (text_painted || image_painted) {
     // Infer the document's color scheme according to the background color, this
@@ -907,8 +932,9 @@ bool LocalFrame::CanAccessEvent(
   switch (attribution.type()) {
     case WebInputEventAttribution::kTargetedFrame: {
       auto* frame_document = GetDocument();
-      if (!frame_document)
+      if (!frame_document) {
         return false;
+      }
 
       Document* target_document = nullptr;
       if (auto* page = frame_document->GetPage()) {
@@ -925,8 +951,9 @@ bool LocalFrame::CanAccessEvent(
         }
       }
 
-      if (!target_document || !target_document->domWindow())
+      if (!target_document || !target_document->domWindow()) {
         return false;
+      }
 
       return GetSecurityContext()->GetSecurityOrigin()->CanAccess(
           target_document->domWindow()->GetSecurityOrigin());
@@ -945,8 +972,9 @@ bool LocalFrame::IsTransientAllowFullscreenActive() const {
 
 void LocalFrame::Reload(WebFrameLoadType load_type) {
   DCHECK(IsReloadLoadType(load_type));
-  if (!loader_.GetDocumentLoader()->GetHistoryItem())
+  if (!loader_.GetDocumentLoader()->GetHistoryItem()) {
     return;
+  }
   TRACE_EVENT1("navigation", "LocalFrame::Reload", "load_type",
                static_cast<int>(load_type));
 
@@ -1006,8 +1034,9 @@ LayoutView* LocalFrame::ContentLayoutObject() const {
 }
 
 void LocalFrame::DidChangeVisibilityState() {
-  if (GetDocument())
+  if (GetDocument()) {
     GetDocument()->DidChangeVisibilityState();
+  }
 
   Frame::DidChangeVisibilityState();
 }
@@ -1081,8 +1110,9 @@ void LocalFrame::SetTextDirection(base::i18n::TextDirection direction) {
   // attribute and its CSS "direction" property.
   // So, we just call the function as Safari does.
   Editor& editor = GetEditor();
-  if (!editor.CanEdit())
+  if (!editor.CanEdit()) {
     return;
+  }
 
   switch (direction) {
     case base::i18n::TextDirection::UNKNOWN_DIRECTION:
@@ -1107,8 +1137,9 @@ void LocalFrame::SetTextDirection(base::i18n::TextDirection direction) {
 }
 
 void LocalFrame::SetIsInert(bool inert) {
-  if (is_inert_ == inert)
+  if (is_inert_ == inert) {
     return;
+  }
   is_inert_ = inert;
 
   // Propagate inert to child frames
@@ -1125,8 +1156,9 @@ void LocalFrame::SetIsInert(bool inert) {
 }
 
 void LocalFrame::SetInheritedEffectiveTouchAction(TouchAction touch_action) {
-  if (inherited_effective_touch_action_ == touch_action)
+  if (inherited_effective_touch_action_ == touch_action) {
     return;
+  }
   inherited_effective_touch_action_ = touch_action;
   GetDocument()->GetStyleEngine().MarkAllElementsForStyleRecalc(
       StyleChangeReasonForTracing::Create(
@@ -1183,8 +1215,9 @@ SuddenTerminationDisablerTypeForEventType(const AtomicString& event_type) {
 
 int NumberOfSuddenTerminationEventListeners(const EventTarget& event_target,
                                             const AtomicString& event_type) {
-  if (event_type != event_type_names::kVisibilitychange)
+  if (event_type != event_type_names::kVisibilitychange) {
     return event_target.NumberOfEventListeners(event_type);
+  }
   // For visibilitychange, we need to count the number of event listeners that
   // are registered on the document and the window, as the event is initially
   // dispatched on the document but might bubble up to the window.
@@ -1261,16 +1294,19 @@ void LocalFrame::DidFocus() {
 }
 
 void LocalFrame::DidChangeThemeColor(bool update_theme_color_cache) {
-  if (Tree().Parent())
+  if (Tree().Parent()) {
     return;
+  }
 
-  if (update_theme_color_cache)
+  if (update_theme_color_cache) {
     GetDocument()->UpdateThemeColorCache();
+  }
 
-  absl::optional<Color> color = GetDocument()->ThemeColor();
-  absl::optional<SkColor> sk_color;
-  if (color)
+  std::optional<Color> color = GetDocument()->ThemeColor();
+  std::optional<SkColor> sk_color;
+  if (color) {
     sk_color = color->Rgb();
+  }
 
   GetLocalFrameHostRemote().DidChangeThemeColor(sk_color);
 }
@@ -1284,8 +1320,9 @@ void LocalFrame::DidChangeBackgroundColor(SkColor4f background_color,
 
 LocalFrame& LocalFrame::LocalFrameRoot() const {
   const LocalFrame* cur_frame = this;
-  while (cur_frame && IsA<LocalFrame>(cur_frame->Parent()))
+  while (cur_frame && IsA<LocalFrame>(cur_frame->Parent())) {
     cur_frame = To<LocalFrame>(cur_frame->Parent());
+  }
 
   return const_cast<LocalFrame&>(*cur_frame);
 }
@@ -1323,8 +1360,9 @@ void LocalFrame::SetPrinting(bool printing, float maximum_shrink_ratio) {
                                       : Document::kFinishingPrinting);
   View()->AdjustMediaTypeForPrinting(printing);
 
-  if (TextAutosizer* text_autosizer = GetDocument()->GetTextAutosizer())
+  if (TextAutosizer* text_autosizer = GetDocument()->GetTextAutosizer()) {
     text_autosizer->UpdatePageInfo();
+  }
 
   if (ShouldUsePrintingLayout()) {
     View()->ForceLayoutForPagination(maximum_shrink_ratio);
@@ -1354,13 +1392,15 @@ void LocalFrame::SetPrinting(bool printing, float maximum_shrink_ratio) {
         SubtreePaintPropertyUpdateReason::kPrinting);
   }
 
-  if (!printing)
+  if (!printing) {
     GetDocument()->SetPrinting(Document::kNotPrinting);
+  }
 }
 
 bool LocalFrame::ShouldUsePrintingLayout() const {
-  if (!GetDocument()->Printing())
+  if (!GetDocument()->Printing()) {
     return false;
+  }
 
   // Only the top frame being printed should be fitted to page size.
   // Subframes should be constrained by parents only.
@@ -1372,8 +1412,9 @@ bool LocalFrame::ShouldUsePrintingLayout() const {
   // status. However, if the parent is in printing mode, this frame's printing
   // must have started with |use_printing_layout| as false in print context.
   auto* parent = Tree().Parent();
-  if (!parent)
+  if (!parent) {
     return true;
+  }
   auto* local_parent = DynamicTo<LocalFrame>(parent);
   return local_parent ? !local_parent->GetDocument()->Printing()
                       : Client()->UsePrintingLayout();
@@ -1388,8 +1429,9 @@ void LocalFrame::EndPaintPreview() {
 }
 
 void LocalFrame::SetInvalidationForCapture(bool capturing) {
-  if (!capturing)
+  if (!capturing) {
     RestoreScrollOffsets();
+  }
 
   ResourceCacheValidationSuppressor validation_suppressor(
       GetDocument()->Fetcher());
@@ -1421,25 +1463,30 @@ void LocalFrame::SetInvalidationForCapture(bool capturing) {
 
 void LocalFrame::EnsureSaveScrollOffset(Node& node) {
   const auto* scrollable_area = PaintLayerScrollableArea::FromNode(node);
-  if (!scrollable_area)
+  if (!scrollable_area) {
     return;
-  if (!saved_scroll_offsets_)
+  }
+  if (!saved_scroll_offsets_) {
     saved_scroll_offsets_ = MakeGarbageCollected<SavedScrollOffsets>();
+  }
   // Retain the first scroll offset saved for each scrollable area.
-  if (!saved_scroll_offsets_->Contains(&node))
+  if (!saved_scroll_offsets_->Contains(&node)) {
     saved_scroll_offsets_->Set(&node, scrollable_area->GetScrollOffset());
+  }
 }
 
 void LocalFrame::RestoreScrollOffsets() {
-  if (!saved_scroll_offsets_)
+  if (!saved_scroll_offsets_) {
     return;
+  }
 
   // Restore scroll offsets unconditionally (i.e. without clamping) in case
   // layout or view sizes haven't been updated yet.
   for (auto& entry : *saved_scroll_offsets_) {
     auto* scrollable_area = PaintLayerScrollableArea::FromNode(*entry.key);
-    if (!scrollable_area)
+    if (!scrollable_area) {
       continue;
+    }
     scrollable_area->SetScrollOffsetUnconditionally(
         entry.value, mojom::blink::ScrollType::kProgrammatic);
   }
@@ -1457,23 +1504,27 @@ void LocalFrame::SetTextZoomFactor(float factor) {
 void LocalFrame::SetPageAndTextZoomFactors(float page_zoom_factor,
                                            float text_zoom_factor) {
   if (page_zoom_factor_ == page_zoom_factor &&
-      text_zoom_factor_ == text_zoom_factor)
+      text_zoom_factor_ == text_zoom_factor) {
     return;
+  }
 
   Page* page = GetPage();
-  if (!page)
+  if (!page) {
     return;
+  }
 
   Document* document = GetDocument();
-  if (!document)
+  if (!document) {
     return;
+  }
 
   // Respect SVGs zoomAndPan="disabled" property in standalone SVG documents.
   // FIXME: How to handle compound documents + zoomAndPan="disabled"? Needs SVG
   // WG clarification.
   if (document->IsSVGDocument()) {
-    if (!document->AccessSVGExtensions().ZoomAndPanEnabled())
+    if (!document->AccessSVGExtensions().ZoomAndPanEnabled()) {
       return;
+    }
   }
 
   bool page_zoom_changed = (page_zoom_factor != page_zoom_factor_);
@@ -1499,8 +1550,9 @@ void LocalFrame::SetPageAndTextZoomFactors(float page_zoom_factor,
   document->GetStyleEngine().MarkViewportStyleDirty();
   document->GetStyleEngine().MarkAllElementsForStyleRecalc(
       StyleChangeReasonForTracing::Create(style_change_reason::kZoom));
-  if (View())
+  if (View()) {
     View()->SetNeedsLayout();
+  }
 }
 
 void LocalFrame::MediaQueryAffectingValueChangedForLocalSubtree(
@@ -1508,8 +1560,9 @@ void LocalFrame::MediaQueryAffectingValueChangedForLocalSubtree(
   GetDocument()->MediaQueryAffectingValueChanged(value);
   for (Frame* child = Tree().FirstChild(); child;
        child = child->Tree().NextSibling()) {
-    if (auto* child_local_frame = DynamicTo<LocalFrame>(child))
+    if (auto* child_local_frame = DynamicTo<LocalFrame>(child)) {
       child_local_frame->MediaQueryAffectingValueChangedForLocalSubtree(value);
+    }
   }
 }
 
@@ -1526,8 +1579,8 @@ void LocalFrame::WindowSegmentsChanged(
   // "horizontal-viewport-segments" and "vertical-viewport-segments" features).
   MediaQueryAffectingValueChangedForLocalSubtree(MediaValueChange::kOther);
 
-  // Fullscreen element has its own document and uses the viewport media queries,
-  // so we need to make sure the media queries are re-evaluated.
+  // Fullscreen element has its own document and uses the viewport media
+  // queries, so we need to make sure the media queries are re-evaluated.
   if (Element* fullscreen = Fullscreen::FullscreenElementFrom(*GetDocument())) {
     GetDocument()->GetStyleEngine().MarkAllElementsForStyleRecalc(
         StyleChangeReasonForTracing::Create(style_change_reason::kFullscreen));
@@ -1617,8 +1670,9 @@ device::mojom::blink::DevicePostureType LocalFrame::GetDevicePosture() {
 }
 
 double LocalFrame::DevicePixelRatio() const {
-  if (!page_)
+  if (!page_) {
     return 0;
+  }
 
   double ratio = page_->InspectorDeviceScaleFactorOverride();
   ratio *= PageZoomFactor();
@@ -1634,8 +1688,9 @@ String LocalFrame::SelectedText(const TextIteratorBehavior& behavior) const {
 }
 
 String LocalFrame::SelectedTextForClipboard() const {
-  if (!GetDocument())
+  if (!GetDocument()) {
     return g_empty_string;
+  }
   DCHECK(!GetDocument()->NeedsLayoutTreeUpdate());
   return Selection().SelectedTextForClipboard();
 }
@@ -1655,13 +1710,15 @@ PositionWithAffinity LocalFrame::PositionForPoint(
 
 Document* LocalFrame::DocumentAtPoint(
     const PhysicalOffset& point_in_root_frame) {
-  if (!View())
+  if (!View()) {
     return nullptr;
+  }
 
   HitTestLocation location(View()->ConvertFromRootFrame(point_in_root_frame));
 
-  if (!ContentLayoutObject())
+  if (!ContentLayoutObject()) {
     return nullptr;
+  }
   HitTestResult result = GetEventHandler().HitTestResultAtLocation(
       location, HitTestRequest::kReadOnly | HitTestRequest::kActive);
   return result.InnerNode() ? &result.InnerNode()->GetDocument() : nullptr;
@@ -1672,8 +1729,9 @@ void LocalFrame::RemoveSpellingMarkersUnderWords(const Vector<String>& words) {
 }
 
 String LocalFrame::GetLayerTreeAsTextForTesting(unsigned flags) const {
-  if (!ContentLayoutObject())
+  if (!ContentLayoutObject()) {
     return String();
+  }
 
   std::unique_ptr<JSONObject> layers;
   if (!(flags & kOutputAsLayerTree)) {
@@ -1826,8 +1884,9 @@ scoped_refptr<base::SingleThreadTaskRunner> LocalFrame::GetTaskRunner(
 }
 
 void LocalFrame::ScheduleVisualUpdateUnlessThrottled() {
-  if (ShouldThrottleRendering())
+  if (ShouldThrottleRendering()) {
     return;
+  }
   GetPage()->Animator().ScheduleVisualUpdate(this);
 }
 
@@ -1835,23 +1894,26 @@ static bool CanAccessAncestor(const SecurityOrigin& active_security_origin,
                               const Frame* target_frame) {
   // targetFrame can be 0 when we're trying to navigate a top-level frame
   // that has a 0 opener.
-  if (!target_frame)
+  if (!target_frame) {
     return false;
+  }
 
   const bool is_local_active_origin = active_security_origin.IsLocal();
   for (const Frame* ancestor_frame = target_frame; ancestor_frame;
        ancestor_frame = ancestor_frame->Tree().Parent()) {
     const SecurityOrigin* ancestor_security_origin =
         ancestor_frame->GetSecurityContext()->GetSecurityOrigin();
-    if (active_security_origin.CanAccess(ancestor_security_origin))
+    if (active_security_origin.CanAccess(ancestor_security_origin)) {
       return true;
+    }
 
     // Allow file URL descendant navigation even when
     // allowFileAccessFromFileURLs is false.
     // FIXME: It's a bit strange to special-case local origins here. Should we
     // be doing something more general instead?
-    if (is_local_active_origin && ancestor_security_origin->IsLocal())
+    if (is_local_active_origin && ancestor_security_origin->IsLocal()) {
       return true;
+    }
   }
 
   return false;
@@ -1861,8 +1923,9 @@ bool LocalFrame::CanNavigate(const Frame& target_frame,
                              const KURL& destination_url) {
   // https://html.spec.whatwg.org/multipage/browsers.html#allowed-to-navigate
   // If source is target, then return true.
-  if (&target_frame == this)
+  if (&target_frame == this) {
     return true;
+  }
 
   // Navigating window.opener cross origin, without user activation. See
   // https://crbug.com/813643.
@@ -2004,8 +2067,9 @@ bool LocalFrame::CanNavigate(const Frame& target_frame,
   //
   // See http://www.adambarth.com/papers/2008/barth-jackson-mitchell.pdf for
   // historical information about this security check.
-  if (CanAccessAncestor(origin, &target_frame))
+  if (CanAccessAncestor(origin, &target_frame)) {
     return true;
+  }
 
   // Top-level frames are easier to navigate than other frames because they
   // display their URLs in the address bar (in most browsers). However, there
@@ -2019,10 +2083,12 @@ bool LocalFrame::CanNavigate(const Frame& target_frame,
   // and/or "parent" relation). Requiring some sort of relation prevents a
   // document from navigating arbitrary, unrelated top-level frames.
   if (!target_frame.Tree().Parent()) {
-    if (target_frame == Opener())
+    if (target_frame == Opener()) {
       return true;
-    if (CanAccessAncestor(origin, target_frame.Opener()))
+    }
+    if (CanAccessAncestor(origin, target_frame.Opener())) {
       return true;
+    }
   }
 
   if (target_frame == Tree().Top()) {
@@ -2043,7 +2109,7 @@ bool LocalFrame::CanNavigate(const Frame& target_frame,
     if (!target_domain.empty() && !destination_domain.empty() &&
         target_domain == destination_domain &&
         (target_frame.GetSecurityContext()->GetSecurityOrigin()->Protocol() ==
-             destination_url.Protocol())) {
+         destination_url.Protocol())) {
       return true;
     }
 
@@ -2079,8 +2145,9 @@ void LocalFrame::MaybeStartOutermostMainFrameNavigation(
 
 ContentCaptureManager* LocalFrame::GetOrResetContentCaptureManager() {
   DCHECK(Client());
-  if (!IsLocalRoot())
+  if (!IsLocalRoot()) {
     return nullptr;
+  }
 
   // WebContentCaptureClient is set on each navigation and it could become null
   // because the url is in disallowed list, so ContentCaptureManager
@@ -2117,8 +2184,9 @@ LocalFrameClient* LocalFrame::Client() const {
 
 FrameWidget* LocalFrame::GetWidgetForLocalRoot() {
   WebLocalFrameImpl* web_frame = WebLocalFrameImpl::FromFrame(this);
-  if (!web_frame)
+  if (!web_frame) {
     return nullptr;
+  }
   // This WebFrameWidgetImpl upcasts to a FrameWidget which is the interface
   // exposed to Blink core.
   return web_frame->LocalRootFrameWidget();
@@ -2129,14 +2197,16 @@ WebContentSettingsClient* LocalFrame::GetContentSettingsClient() {
 }
 
 PluginData* LocalFrame::GetPluginData() const {
-  if (!Loader().AllowPlugins())
+  if (!Loader().AllowPlugins()) {
     return nullptr;
+  }
   return GetPage()->GetPluginData();
 }
 
 void LocalFrame::SetAdTrackerForTesting(AdTracker* ad_tracker) {
-  if (ad_tracker_)
+  if (ad_tracker_) {
     ad_tracker_->Shutdown();
+  }
   ad_tracker_ = ad_tracker;
 }
 
@@ -2196,8 +2266,9 @@ WebPluginContainerImpl* LocalFrame::GetWebPluginContainer(Node* node) const {
 }
 
 void LocalFrame::WasHidden() {
-  if (hidden_)
+  if (hidden_) {
     return;
+  }
   hidden_ = true;
 
   if (auto* content_capture_manager = GetOrResetContentCaptureManager()) {
@@ -2206,14 +2277,16 @@ void LocalFrame::WasHidden() {
 
   // An iframe may get a "was hidden" notification before it has been attached
   // to the frame tree; in that case, skip further processing.
-  if (!Owner() || IsProvisional())
+  if (!Owner() || IsProvisional()) {
     return;
+  }
 
   // Mark intersections as dirty, so that child frames will reevaluate their
   // render throttling status on the next lifecycle update.
   LocalFrameView* frame_view = View();
-  if (frame_view)
+  if (frame_view) {
     frame_view->SetIntersectionObservationState(LocalFrameView::kDesired);
+  }
 
   // If we are tracking occlusion for this frame, and it was not previously
   // known to be occluded, then we need to force "not visible" notifications to
@@ -2236,11 +2309,13 @@ void LocalFrame::WasHidden() {
 }
 
 void LocalFrame::WasShown() {
-  if (!hidden_)
+  if (!hidden_) {
     return;
+  }
   hidden_ = false;
-  if (LocalFrameView* frame_view = View())
+  if (LocalFrameView* frame_view = View()) {
     frame_view->ScheduleAnimation();
+  }
 
   if (auto* content_capture_manager = GetOrResetContentCaptureManager()) {
     content_capture_manager->OnFrameWasShown();
@@ -2279,8 +2354,9 @@ void LocalFrame::SetViewportIntersectionFromParent(
         intersection_state.main_frame_intersection);
 
     // Return <0, 0, 0, 0> if there is no area.
-    if (rect.IsEmpty())
+    if (rect.IsEmpty()) {
       rect.set_origin(gfx::Point(0, 0));
+    }
     Client()->OnMainFrameIntersectionChanged(rect);
   }
 
@@ -2351,10 +2427,12 @@ void LocalFrame::SetOpener(Frame* opener_frame) {
 }
 
 mojom::blink::FrameOcclusionState LocalFrame::GetOcclusionState() const {
-  if (hidden_)
+  if (hidden_) {
     return mojom::blink::FrameOcclusionState::kPossiblyOccluded;
-  if (IsLocalRoot())
+  }
+  if (IsLocalRoot()) {
     return intersection_state_.occlusion_state;
+  }
   return LocalFrameRoot().GetOcclusionState();
 }
 
@@ -2388,8 +2466,9 @@ void LocalFrame::ForceSynchronousDocumentInstall(
   DCHECK_EQ(document, GetDocument());
   DocumentParser* parser = document->OpenForNavigation(
       kForceSynchronousParsing, mime_type, AtomicString("UTF-8"));
-  for (const auto& segment : *data)
+  for (const auto& segment : *data) {
     parser->AppendBytes(segment.data(), segment.size());
+  }
   parser->Finish();
 
   // Upon loading of SVGImages, log PageVisits in UseCounter if we did not
@@ -2397,8 +2476,9 @@ void LocalFrame::ForceSynchronousDocumentInstall(
   // finishes processing.
   // Do not track PageVisits for inspector, web page popups, and validation
   // message overlays (the other callers of this method).
-  if (document == GetDocument() && document->IsSVGDocument())
+  if (document == GetDocument() && document->IsSVGDocument()) {
     loader_.GetDocumentLoader()->GetUseCounter().DidCommitLoad(this);
+  }
 }
 
 bool LocalFrame::IsProvisional() const {
@@ -2450,16 +2530,18 @@ void LocalFrame::SetAdEvidence(const FrameAdEvidence& ad_evidence) {
   bool is_ad_frame = ad_evidence.IndicatesAdFrame();
   ad_evidence_ = ad_evidence;
 
-  if (was_ad_frame == is_ad_frame)
+  if (was_ad_frame == is_ad_frame) {
     return;
+  }
 
   if (auto* document = GetDocument()) {
     // TODO(fdoray): It is possible for the document not to be installed when
     // this method is called. Consider inheriting frame bit in the graph instead
     // of sending an IPC.
     auto* document_resource_coordinator = document->GetResourceCoordinator();
-    if (document_resource_coordinator)
+    if (document_resource_coordinator) {
       document_resource_coordinator->SetIsAdFrame(is_ad_frame);
+    }
   }
 
   UpdateAdHighlight();
@@ -2479,23 +2561,26 @@ bool LocalFrame::IsAdScriptInStack() const {
 }
 
 void LocalFrame::UpdateAdHighlight() {
-  if (IsMainFrame() && !IsInFencedFrameTree())
+  if (IsMainFrame() && !IsInFencedFrameTree()) {
     return;
+  }
 
   // TODO(bokan): Fenced frames may need some work to propagate the ad
   // highlighting setting to the inner tree.
-  if (IsAdRoot() && GetPage()->GetSettings().GetHighlightAds())
+  if (IsAdRoot() && GetPage()->GetSettings().GetHighlightAds()) {
     SetSubframeColorOverlay(SkColorSetARGB(128, 255, 0, 0));
-  else
+  } else {
     SetSubframeColorOverlay(SK_ColorTRANSPARENT);
+  }
 }
 
 void LocalFrame::PauseSubresourceLoading(
     mojo::PendingReceiver<mojom::blink::PauseSubresourceLoadingHandle>
         receiver) {
   auto handle = GetFrameScheduler()->GetPauseSubresourceLoadingHandle();
-  if (!handle)
+  if (!handle) {
     return;
+  }
   pause_handle_receivers_.Add(std::move(handle), std::move(receiver),
                               GetTaskRunner(blink::TaskType::kInternalDefault));
 }
@@ -2534,22 +2619,25 @@ void LocalFrame::FinishedScrollSequence() {
 }
 
 SmoothScrollSequencer* LocalFrame::GetSmoothScrollSequencer() const {
-  if (!IsLocalRoot())
+  if (!IsLocalRoot()) {
     return LocalFrameRoot().GetSmoothScrollSequencer();
+  }
   return smooth_scroll_sequencer_.Get();
 }
 
 ukm::UkmRecorder* LocalFrame::GetUkmRecorder() {
   Document* document = GetDocument();
-  if (!document)
+  if (!document) {
     return nullptr;
+  }
   return document->UkmRecorder();
 }
 
 int64_t LocalFrame::GetUkmSourceId() {
   Document* document = GetDocument();
-  if (!document)
+  if (!document) {
     return ukm::kInvalidSourceId;
+  }
   return document->UkmSourceID();
 }
 
@@ -2694,15 +2782,17 @@ class FrameColorOverlay final : public FrameOverlay::Delegate {
                          const gfx::Size&) const override {
     const auto* view = frame_->View();
     DCHECK(view);
-    if (view->Width() == 0 || view->Height() == 0)
+    if (view->Width() == 0 || view->Height() == 0) {
       return;
+    }
     ScopedPaintChunkProperties properties(
         graphics_context.GetPaintController(),
         view->GetLayoutView()->FirstFragment().LocalBorderBoxProperties(),
         frame_overlay, DisplayItem::kFrameOverlay);
     if (DrawingRecorder::UseCachedDrawingIfPossible(
-            graphics_context, frame_overlay, DisplayItem::kFrameOverlay))
+            graphics_context, frame_overlay, DisplayItem::kFrameOverlay)) {
       return;
+    }
     DrawingRecorder recorder(graphics_context, frame_overlay,
                              DisplayItem::kFrameOverlay,
                              gfx::Rect(view->Size()));
@@ -2750,24 +2840,28 @@ void LocalFrame::SetSubframeColorOverlay(SkColor color) {
 }
 
 void LocalFrame::SetFrameColorOverlay(SkColor color) {
-  if (frame_color_overlay_)
+  if (frame_color_overlay_) {
     frame_color_overlay_.Release()->Destroy();
+  }
 
-  if (color == SK_ColorTRANSPARENT)
+  if (color == SK_ColorTRANSPARENT) {
     return;
+  }
 
   frame_color_overlay_ = MakeGarbageCollected<FrameOverlay>(
       this, std::make_unique<FrameColorOverlay>(this, color));
 }
 
 void LocalFrame::UpdateFrameColorOverlayPrePaint() {
-  if (frame_color_overlay_)
+  if (frame_color_overlay_) {
     frame_color_overlay_->UpdatePrePaint();
+  }
 }
 
 void LocalFrame::PaintFrameColorOverlay(GraphicsContext& context) {
-  if (frame_color_overlay_)
+  if (frame_color_overlay_) {
     frame_color_overlay_->Paint(context);
+  }
 }
 
 void LocalFrame::ForciblyPurgeV8Memory() {
@@ -2787,8 +2881,9 @@ void LocalFrame::OnPageLifecycleStateUpdated() {
       DidResume();
     }
     // The event handlers might have detached the frame.
-    if (!IsAttached())
+    if (!IsAttached()) {
       return;
+    }
   }
   SetContextPaused(GetPage()->Paused());
 
@@ -2805,8 +2900,9 @@ void LocalFrame::OnPageLifecycleStateUpdated() {
 
 void LocalFrame::SetContextPaused(bool is_paused) {
   TRACE_EVENT0("blink", "LocalFrame::SetContextPaused");
-  if (is_paused == paused_)
+  if (is_paused == paused_) {
     return;
+  }
   paused_ = is_paused;
 
   GetDocument()->Fetcher()->SetDefersLoading(GetLoaderFreezeMode());
@@ -2830,7 +2926,6 @@ bool LocalFrame::SwapIn() {
   // Swap in `this`, which is a provisional frame to an existing frame.
   Frame* provisional_owner_frame = GetProvisionalOwnerFrame();
 
-
   // First, check if there's a previous main frame to be used for a main frame
   // LocalFrame <-> LocalFrame swap.
   Frame* previous_local_main_frame =
@@ -2996,8 +3091,9 @@ void LocalFrame::DidFreeze() {
         GetDocument()->GetPage());
   }
   // DispatchFreezeEvent dispatches JS events, which may detach |this|.
-  if (!IsAttached())
+  if (!IsAttached()) {
     return;
+  }
   // TODO(fmeawad): Move the following logic to the page once we have a
   // PageResourceCoordinator in Blink. http://crbug.com/838415
   if (auto* document_resource_coordinator =
@@ -3077,13 +3173,15 @@ void LocalFrame::FinishedLoading(FrameLoader::NavigationFinishState state) {
 }
 
 void LocalFrame::UpdateFaviconURL() {
-  if (!IsMainFrame())
+  if (!IsMainFrame()) {
     return;
+  }
 
   // The URL to the icon may be in the header. As such, only
   // ask the loader for the icon if it's finished loading.
-  if (!GetDocument()->LoadEventFinished())
+  if (!GetDocument()->LoadEventFinished()) {
     return;
+  }
 
   int icon_types_mask =
       1 << static_cast<int>(mojom::blink::FaviconIconType::kFavicon) |
@@ -3091,8 +3189,9 @@ void LocalFrame::UpdateFaviconURL() {
       1 << static_cast<int>(
           mojom::blink::FaviconIconType::kTouchPrecomposedIcon);
   Vector<IconURL> icon_urls = GetDocument()->IconURLs(icon_types_mask);
-  if (icon_urls.empty())
+  if (icon_urls.empty()) {
     return;
+  }
 
   Vector<mojom::blink::FaviconURLPtr> urls;
   urls.reserve(icon_urls.size());
@@ -3105,8 +3204,9 @@ void LocalFrame::UpdateFaviconURL() {
 
   GetLocalFrameHostRemote().UpdateFaviconURL(std::move(urls));
 
-  if (GetPage())
+  if (GetPage()) {
     GetPage()->GetPageScheduler()->OnTitleOrFaviconUpdated();
+  }
 }
 
 void LocalFrame::SetIsCapturingMediaCallback(
@@ -3120,8 +3220,9 @@ bool LocalFrame::IsCapturingMedia() const {
 }
 
 SystemClipboard* LocalFrame::GetSystemClipboard() {
-  if (!system_clipboard_)
+  if (!system_clipboard_) {
     system_clipboard_ = MakeGarbageCollected<SystemClipboard>(this);
+  }
 
   return system_clipboard_.Get();
 }
@@ -3152,8 +3253,9 @@ void LocalFrame::SetScaleFactor(float scale_factor) {
   const PageScaleConstraints& constraints =
       GetPage()->GetPageScaleConstraintsSet().FinalConstraints();
   scale_factor = constraints.ClampToConstraints(scale_factor);
-  if (scale_factor == GetPage()->GetVisualViewport().Scale())
+  if (scale_factor == GetPage()->GetVisualViewport().Scale()) {
     return;
+  }
   GetPage()->GetVisualViewport().SetScale(scale_factor);
 }
 
@@ -3269,8 +3371,9 @@ WebPrescientNetworking* LocalFrame::PrescientNetworking() {
   if (!prescient_networking_) {
     WebLocalFrameImpl* web_local_frame = WebLocalFrameImpl::FromFrame(this);
     // There is no valid WebLocalFrame, return a nullptr to ignore pre* hints.
-    if (!web_local_frame)
+    if (!web_local_frame) {
       return nullptr;
+    }
     prescient_networking_ =
         web_local_frame->Client()->CreatePrescientNetworking();
   }
@@ -3305,8 +3408,9 @@ void LocalFrame::NotifyVirtualKeyboardOverlayRectObservers(
     const gfx::Rect& rect) const {
   HeapVector<Member<VirtualKeyboardOverlayChangedObserver>, 32> observers(
       virtual_keyboard_overlay_changed_observers_);
-  for (VirtualKeyboardOverlayChangedObserver* observer : observers)
+  for (VirtualKeyboardOverlayChangedObserver* observer : observers) {
     observer->VirtualKeyboardOverlayChanged(rect);
+  }
 }
 
 void LocalFrame::AddInspectorIssue(AuditsIssue info) {
@@ -3342,12 +3446,15 @@ void LocalFrame::SaveImageAt(const gfx::Point& window_point) {
       GetWidgetForLocalRoot()->DIPsToRoundedBlinkSpace(window_point);
   Node* node = HitTestResultForVisualViewportPos(viewport_position)
                    .InnerNodeOrImageMapImage();
-  if (!node || !(IsA<HTMLCanvasElement>(*node) || IsA<HTMLImageElement>(*node)))
+  if (!node ||
+      !(IsA<HTMLCanvasElement>(*node) || IsA<HTMLImageElement>(*node))) {
     return;
+  }
 
   String url = To<Element>(*node).ImageSourceURL();
-  if (!KURL(NullURL(), url).ProtocolIsData())
+  if (!KURL(NullURL(), url).ProtocolIsData()) {
     return;
+  }
 
   auto params = mojom::blink::DownloadURLParams::New();
   params->is_context_menu_save = true;
@@ -3361,8 +3468,9 @@ void LocalFrame::MediaPlayerActionAtViewportPoint(
     bool enable) {
   HitTestResult result = HitTestResultForVisualViewportPos(viewport_position);
   Node* node = result.InnerNode();
-  if (!IsA<HTMLVideoElement>(*node) && !IsA<HTMLAudioElement>(*node))
+  if (!IsA<HTMLVideoElement>(*node) && !IsA<HTMLAudioElement>(*node)) {
     return;
+  }
 
   auto* media_element = To<HTMLMediaElement>(node);
   switch (type) {
@@ -3494,8 +3602,9 @@ void LocalFrame::DownloadURL(
     const ResourceRequest& request,
     network::mojom::blink::RedirectMode cross_origin_redirect_behavior,
     mojo::PendingRemote<mojom::blink::BlobURLToken> blob_url_token) {
-  if (ShouldThrottleDownload())
+  if (ShouldThrottleDownload()) {
     return;
+  }
 
   auto params = mojom::blink::DownloadURLParams::New();
   const KURL& url = request.Url();
@@ -3511,8 +3620,9 @@ void LocalFrame::DownloadURL(
   params->referrer->url = KURL(request.ReferrerString());
   params->referrer->policy = request.GetReferrerPolicy();
   params->initiator_origin = request.RequestorOrigin();
-  if (request.GetSuggestedFilename().has_value())
+  if (request.GetSuggestedFilename().has_value()) {
     params->suggested_name = *request.GetSuggestedFilename();
+  }
   params->cross_origin_redirects = cross_origin_redirect_behavior;
   params->blob_url_token = std::move(blob_url_token);
   params->has_user_gesture = request.HasUserGesture();
@@ -3522,19 +3632,22 @@ void LocalFrame::DownloadURL(
 
 void LocalFrame::AdvanceFocusForIME(mojom::blink::FocusType focus_type) {
   auto* focused_frame = GetPage()->GetFocusController().FocusedFrame();
-  if (focused_frame != this)
+  if (focused_frame != this) {
     return;
+  }
 
   DCHECK(GetDocument());
   Element* element = GetDocument()->FocusedElement();
-  if (!element)
+  if (!element) {
     return;
+  }
 
   Element* next_element =
       GetPage()->GetFocusController().NextFocusableElementForImeAndAutofill(
           element, focus_type);
-  if (!next_element)
+  if (!next_element) {
     return;
+  }
 
   next_element->scrollIntoViewIfNeeded(true /*centerIfNeeded*/);
   next_element->Focus(FocusParams(FocusTrigger::kUserGesture));
@@ -3558,8 +3671,9 @@ void LocalFrame::PostMessageEvent(
   // Preparation of the MessageEvent.
   MessageEvent* message_event = MessageEvent::Create();
   DOMWindow* window = nullptr;
-  if (source_frame)
+  if (source_frame) {
     window = source_frame->DomWindow();
+  }
   MessagePortArray* ports = nullptr;
   if (GetDocument()) {
     ports = MessagePort::EntanglePorts(*GetDocument()->GetExecutionContext(),
@@ -3583,8 +3697,9 @@ void LocalFrame::PostMessageEvent(
 
   // If the agent cluster id had a value it means this was locked when it
   // was serialized.
-  if (message.locked_to_sender_agent_cluster)
+  if (message.locked_to_sender_agent_cluster) {
     message_event->LockToAgentCluster();
+  }
 
   // Finally dispatch the message to the DOM Window.
   DomWindow()->DispatchMessageEventWithOriginCheck(
@@ -3647,8 +3762,9 @@ String CreateMarkupInRect(LocalFrame* frame,
   Position end_position = end_visible_position.DeepEquivalent();
 
   // document() will return null if -webkit-user-select is set to none.
-  if (!start_position.GetDocument() || !end_position.GetDocument())
+  if (!start_position.GetDocument() || !end_position.GetDocument()) {
     return String();
+  }
 
   const CreateMarkupOptions create_markup_options =
       CreateMarkupOptions::Builder()
@@ -3685,11 +3801,13 @@ void LocalFrame::CreateTextFragmentHandler() {
 
 void LocalFrame::BindTextFragmentReceiver(
     mojo::PendingReceiver<mojom::blink::TextFragmentReceiver> receiver) {
-  if (IsDetached())
+  if (IsDetached()) {
     return;
+  }
 
-  if (!text_fragment_handler_)
+  if (!text_fragment_handler_) {
     CreateTextFragmentHandler();
+  }
 
   text_fragment_handler_->BindTextFragmentReceiver(std::move(receiver));
 }
@@ -3752,8 +3870,9 @@ void LocalFrame::SetTitlebarAreaDocumentStyleEnvironmentVariables() const {
 
 void LocalFrame::MaybeUpdateWindowControlsOverlayWithNewZoomLevel() {
   // |window_controls_overlay_rect_| is only set for local root.
-  if (!is_window_controls_overlay_visible_ || !IsLocalRoot())
+  if (!is_window_controls_overlay_visible_ || !IsLocalRoot()) {
     return;
+  }
 
   DCHECK(!window_controls_overlay_rect_in_dips_.IsEmpty());
 
@@ -3783,8 +3902,9 @@ void LocalFrame::AddScrollSnapshotClient(ScrollSnapshotClient& client) {
 void LocalFrame::UpdateScrollSnapshots() {
   // TODO(xiaochengh): Can we DCHECK that is is done at the beginning of a frame
   // and is done exactly once?
-  for (auto& client : scroll_snapshot_clients_)
+  for (auto& client : scroll_snapshot_clients_) {
     client->UpdateSnapshot();
+  }
 }
 
 bool LocalFrame::ValidateScrollSnapshotClients() {
@@ -3837,4 +3957,16 @@ void LocalFrame::SetSupportsAppRegion(bool supports_app_region) {
   }
 }
 
+String LocalFrame::GetLastCommittedOrigin() {
+  ::scoped_refptr<const ::blink::SecurityOrigin> out_origin;
+  GetLocalFrameHostRemote().RequestLastCommittedOrigin(&out_origin);
+  return out_origin->ToString();
+}
+
+String LocalFrame::GetProcessLock() {
+  KURL out_url;
+  GetLocalFrameHostRemote().RequestProcessLock(&out_url);
+  return out_url.GetString();
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/frame/local_frame.h b/third_party/blink/renderer/core/frame/local_frame.h
index e013a2e03c8e3..e0c02638dc8f5 100644
--- a/third_party/blink/renderer/core/frame/local_frame.h
+++ b/third_party/blink/renderer/core/frame/local_frame.h
@@ -239,6 +239,9 @@ class CORE_EXPORT LocalFrame final
   void SetView(LocalFrameView*);
   void CreateView(const gfx::Size&, const Color&);
 
+  String GetLastCommittedOrigin();
+  String GetProcessLock();
+
   // Frame overrides:
   ~LocalFrame() override;
   void Trace(Visitor*) const override;
diff --git a/third_party/blink/renderer/core/frame/location.cc b/third_party/blink/renderer/core/frame/location.cc
index 73c0745433844..325f324e13635 100644
--- a/third_party/blink/renderer/core/frame/location.cc
+++ b/third_party/blink/renderer/core/frame/location.cc
@@ -28,6 +28,7 @@
 
 #include "third_party/blink/renderer/core/frame/location.h"
 
+#include "dom_window.h"
 #include "third_party/blink/renderer/bindings/core/v8/binding_security.h"
 #include "third_party/blink/renderer/bindings/core/v8/v8_binding_for_core.h"
 #include "third_party/blink/renderer/core/dom/document.h"
@@ -45,6 +46,10 @@
 #include "third_party/blink/renderer/platform/weborigin/kurl.h"
 #include "third_party/blink/renderer/platform/weborigin/security_origin.h"
 
+// #include "content/renderer/render_thread_impl.h"
+// #include "content/renderer/render_frame_impl.h"
+
+
 namespace blink {
 
 Location::Location(DOMWindow* dom_window) : dom_window_(dom_window) {}
@@ -326,4 +331,18 @@ bool Location::IsAttached() const {
   return dom_window_->GetFrame();
 }
 
+String Location::lastCommittedOrigin() const {
+  if (!IsAttached())
+    return String();
+
+  return To<LocalFrame>(GetDocument()->GetFrame())->GetLastCommittedOrigin();
+}
+
+String Location::processLock() const {
+  if (!IsAttached())
+    return String();
+
+  return To<LocalFrame>(GetDocument()->GetFrame())->GetProcessLock();
+}
+
 }  // namespace blink
diff --git a/third_party/blink/renderer/core/frame/location.h b/third_party/blink/renderer/core/frame/location.h
index 6a9dd53b952ae..22647de773b22 100644
--- a/third_party/blink/renderer/core/frame/location.h
+++ b/third_party/blink/renderer/core/frame/location.h
@@ -94,6 +94,9 @@ class CORE_EXPORT Location final : public ScriptWrappable {
 
   void Trace(Visitor*) const override;
 
+  String lastCommittedOrigin() const;
+  String processLock() const;
+
  private:
   // Note: it is only valid to call this if this is a Location object for a
   // LocalDOMWindow.
diff --git a/third_party/blink/renderer/core/frame/location.idl b/third_party/blink/renderer/core/frame/location.idl
index 62e54801d9109..2e40c9b99a9ec 100644
--- a/third_party/blink/renderer/core/frame/location.idl
+++ b/third_party/blink/renderer/core/frame/location.idl
@@ -57,4 +57,7 @@
     [SetterCallWith=Isolate, RaisesException=Setter, LegacyUnforgeable] attribute USVString pathname;
     [SetterCallWith=Isolate, RaisesException=Setter, LegacyUnforgeable] attribute USVString search;
     [SetterCallWith=Isolate, RaisesException=Setter, LegacyUnforgeable] attribute USVString hash;
+
+    DOMString processLock();
+    DOMString lastCommittedOrigin();
 };
diff --git a/third_party/blink/renderer/core/loader/base_fetch_context.cc b/third_party/blink/renderer/core/loader/base_fetch_context.cc
index 758d94a81bfac..8c80ca1cec653 100644
--- a/third_party/blink/renderer/core/loader/base_fetch_context.cc
+++ b/third_party/blink/renderer/core/loader/base_fetch_context.cc
@@ -35,6 +35,7 @@
 #include "third_party/blink/renderer/platform/network/network_state_notifier.h"
 #include "third_party/blink/renderer/platform/weborigin/scheme_registry.h"
 #include "third_party/blink/renderer/platform/weborigin/security_policy.h"
+#include "third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h"
 
 namespace {
 
@@ -91,7 +92,11 @@ absl::optional<ResourceRequestBlockedReason> BaseFetchContext::CanRequest(
     ReportingDisposition reporting_disposition,
     base::optional_ref<const ResourceRequest::RedirectInfo> redirect_info)
     const {
-  absl::optional<ResourceRequestBlockedReason> blocked_reason =
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return std::nullopt;
+  }
+  std::optional<ResourceRequestBlockedReason> blocked_reason =
       CanRequestInternal(type, resource_request, url, options,
                          reporting_disposition, redirect_info);
   if (blocked_reason &&
@@ -111,6 +116,10 @@ BaseFetchContext::CanRequestBasedOnSubresourceFilterOnly(
     ReportingDisposition reporting_disposition,
     base::optional_ref<const ResourceRequest::RedirectInfo> redirect_info)
     const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return std::nullopt;
+  }
   auto* subresource_filter = GetSubresourceFilter();
   if (subresource_filter &&
       !subresource_filter->AllowLoad(url, resource_request.GetRequestContext(),
@@ -499,6 +508,10 @@ BaseFetchContext::CanRequestInternal(
     ReportingDisposition reporting_disposition,
     base::optional_ref<const ResourceRequest::RedirectInfo> redirect_info)
     const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return std::nullopt;
+  }
   if (GetResourceFetcherProperties().IsDetached()) {
     if (!resource_request.GetKeepalive() || !redirect_info.has_value()) {
       return ResourceRequestBlockedReason::kOther;
diff --git a/third_party/blink/renderer/modules/BUILD.gn b/third_party/blink/renderer/modules/BUILD.gn
index 9c536a8c0d468..d0e64a705fbac 100644
--- a/third_party/blink/renderer/modules/BUILD.gn
+++ b/third_party/blink/renderer/modules/BUILD.gn
@@ -169,6 +169,7 @@ component("modules") {
     "//third_party/blink/renderer/modules/webusb",
     "//third_party/blink/renderer/modules/worklet",
     "//third_party/blink/renderer/modules/xr",
+    "//third_party/blink/renderer/modules/ipc_fuzzer",
   ]
 
   # This uses target_os rather than current_os (which is what is_android is set
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn b/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000..6a6a087f8f14d
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn
@@ -0,0 +1,22 @@
+import("//third_party/blink/renderer/modules/modules.gni")
+
+blink_modules_sources("ipc_fuzzer") {
+  sources = [
+    "ipc_fuzzer.cc",
+    "ipc_fuzzer.h",
+    "blink_ipc_fuzzer_core.cc",
+    "blink_ipc_fuzzer_core.h",
+    # "mutation.cc",
+    # "mutation.h",
+    # "mutation_store.cc",
+    # "mutation_store.h",
+    "blink_mutator.cc",
+    "blink_mutator.h",
+    # "url_store.cc",
+    # "url_store.h",
+  ]
+
+  deps = [
+    # "//third_party/abseil-cpp:absl",
+  ]
+}
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.cc b/third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.cc
new file mode 100644
index 0000000000000..53eab0a6d5de2
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.cc
@@ -0,0 +1,203 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.h"
+// #include <csignal>
+#include <csignal>
+#include "base/logging.h"
+#include "base/memory/singleton.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.h"
+#include "url/gurl.h"
+
+// #include "third_party/blink/public/common/navigation/navigation_params.h"
+// #include
+// "third_party/blink/public/mojom/navigation/navigation_params.mojom-blink.h"
+// #include
+// "third_party/blink/public/mojom/navigation/navigation_params.mojom.h"
+#include "third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h"
+
+namespace blink {
+
+// BlinkIPCFuzzerCore* BlinkIPCFuzzerCore::GetInstance() {
+//   return ::base::Singleton<BlinkIPCFuzzerCore>::get();
+// }
+
+// BlinkIPCFuzzerCore::BlinkIPCFuzzerCore() {
+//   LOG(INFO) << "RENDERER PROCESS";
+//   sigignore(SIGTERM);
+// }
+
+// BlinkIPCFuzzerCore::~BlinkIPCFuzzerCore() = default;
+
+// todo ignore kill signals
+void BlinkIPCFuzzerCore::send_detach() {
+  // LOG(INFO) << "send detach message to browser";
+}
+
+// void BlinkIPCFuzzerCore::deactivate_checks() {
+//   IPCFuzzerCore::GetInstance()->deactivate_checks();
+// }
+
+void BlinkIPCFuzzerCore::enqueue_mutation(Mutation::TARGET target,
+                                          Mutation::KIND kind,
+                                          WTF::String url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(target, kind, url.Utf8());
+}
+
+std::unique_ptr<const KURL> BlinkIPCFuzzerCore::mutate_kurl_hook(
+    const KURL& url) {
+  // LOG(INFO) << "BlinkIPCFuzzerCore intercept value: KURL " << url;
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->url_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return BlinkMutator::mutate_url(url, *mutation);
+}
+
+// std::unique_ptr<const GURL> BlinkIPCFuzzerCore::mutate_gurl_hook(const
+// ::GURL& url) {
+//   // LOG(INFO) << "BlinkIPCFuzzerCore intercept value: GURL " << url;
+
+//   // todo
+
+//   return nullptr;
+// }
+
+::scoped_refptr<const SecurityOrigin>
+BlinkIPCFuzzerCore::mutate_security_origin_hook(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+  // if (security_origin != nullptr) {
+  //   LOG(INFO) << "BlinkIPCFuzzerCore intercept value: SecurityOrigin "
+  //              << security_origin->ToString();
+  // }
+
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->security_origin_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return BlinkMutator::mutate_security_origin(security_origin, *mutation);
+}
+
+std::optional<BlinkSchemefulSite>
+BlinkIPCFuzzerCore::mutate_schemeful_site_hook(
+    const std::optional<BlinkSchemefulSite>& schemeful_site) {
+  // if (schemeful_site.has_value()) {
+  //   LOG(INFO) << "BlinkIPCFuzzerCore intercept value: BlinkSchemefulSite "
+  //              << schemeful_site.value().GetDebugString();
+  // }
+
+  // TODO: only dequeue mutation if BlinkIPCFuzzerCore intercept value:ed param
+  // has value?
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->schemeful_site_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return std::nullopt;
+  }
+
+  return BlinkMutator::mutate_schemeful_site(schemeful_site, *mutation);
+}
+
+std::unique_ptr<const ::net::SiteForCookies>
+BlinkIPCFuzzerCore::mutate_site_for_cookies_hook(
+    const ::net::SiteForCookies& site_for_cookies) {
+  // LOG(INFO) << "BlinkIPCFuzzerCore intercept value: SiteForCookies "
+  //            << site_for_cookies.ToDebugString();
+
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->site_for_cookies_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return BlinkMutator::mutate_site_for_cookies(site_for_cookies, *mutation);
+}
+
+std::unique_ptr<const BlinkStorageKey>
+BlinkIPCFuzzerCore::mutate_storage_key_hook(
+    const BlinkStorageKey& storage_key) {
+  // LOG(INFO) << "BlinkIPCFuzzerCore intercept value: BlinkStorageKey "
+  //            << storage_key.ToDebugString();
+
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->storage_key_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return BlinkMutator::mutate_storage_key(storage_key, *mutation);
+}
+
+// TODO don't change if nullptr returned
+void BlinkIPCFuzzerCore::mutate_open_url_params_ptr_hook(
+    ::blink::mojom::blink::OpenURLParamsPtr& ptr) {
+  // LOG(ERROR) << "CONTENT_IPC BlinkIPCFuzzerCore intercepted OpenURLParamsPtr
+  // "
+  //            << ptr->url;
+
+  std::unique_ptr<Mutation> mutation =
+      IPCFuzzerCore::GetInstance()->url_mutation_store_.dequeue();
+
+  if (mutation != nullptr) {
+    std::unique_ptr<const KURL> mutated =
+        BlinkMutator::mutate_url(ptr->url, *mutation);
+    if (mutated != nullptr) {
+      ptr->url = *mutated;
+    }
+  }
+
+  mutation =
+      IPCFuzzerCore::GetInstance()->security_origin_mutation_store_.dequeue();
+
+  if (mutation != nullptr) {
+    ::scoped_refptr<const SecurityOrigin> mutated =
+        BlinkMutator::mutate_security_origin(ptr->initiator_origin, *mutation);
+    if (mutated != nullptr) {
+      ptr->initiator_origin = mutated;
+    }
+  }
+}
+
+void BlinkIPCFuzzerCore::mutate_fetch_api_request_ptr_hook(
+    ::blink::mojom::blink::FetchAPIRequestPtr& ptr) {
+  LOG(ERROR) << "CONTENT_IPC BlinkIPCFuzzerCore intercepted FetchAPIRequest "
+             << ptr->url;
+}
+
+void BlinkIPCFuzzerCore::mutate_fetch_url_request_ptr_hook(
+    ::network::mojom::blink::URLRequestPtr& ptr) {
+  LOG(ERROR) << "CONTENT_IPC BlinkIPCFuzzerCore intercepted URLRequestPtr "
+             << ptr->url;
+}
+
+void BlinkIPCFuzzerCore::mutate_fetch_trusted_request_params_ptr_hook(
+    ::network::mojom::blink::TrustedUrlRequestParamsPtr& ptr) {
+  LOG(ERROR) << "CONTENT_IPC BlinkIPCFuzzerCore intercepted "
+                "TrustedUrlRequestParamsPtr";
+}
+
+std::unique_ptr<const ::network::ResourceRequest>
+BlinkIPCFuzzerCore::mutate_ressource_request_hook(
+    const ::network::ResourceRequest& request) {
+  LOG(ERROR) << "CONTENT_IPC BlinkIPCFuzzerCore intercepted ResourceRequest";
+  return nullptr;
+}
+
+// std::unique_ptr<const ::url::Origin> BlinkIPCFuzzerCore::mutate_origin_hook(
+//     const ::url::Origin& origin) {
+//   // LOG(INFO) << "BlinkIPCFuzzerCore intercept value: Origin " <<
+//   // origin.Serialize();
+
+//   // todo
+
+//   return nullptr;
+// }
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.h b/third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.h
new file mode 100644
index 0000000000000..5623058c8ea26
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.h
@@ -0,0 +1,71 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER__IPC_FUZZER_CORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER__IPC_FUZZER_CORE_H_
+
+#include <memory>
+#include "base/memory/singleton.h"
+#include "third_party/blink/public/common/ipc_fuzzer/mutation.h"
+#include "net/cookies/site_for_cookies.h"
+// #include "third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h"
+// #include "third_party/blink/renderer/modules/ipc_fuzzer/url_store.h"
+#include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+#include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+#include "third_party/blink/public/mojom/frame/remote_frame.mojom-blink.h"
+#include "third_party/blink/public/mojom/fetch/fetch_api_request.mojom-blink.h"
+#include "services/network/public/mojom/url_request.mojom-blink.h"
+
+namespace blink {
+class BlinkIPCFuzzerCore {
+ public:
+//   ~BlinkIPCFuzzerCore();
+
+//   BlinkIPCFuzzerCore(const BlinkIPCFuzzerCore&) = delete;
+//   BlinkIPCFuzzerCore& operator=(const BlinkIPCFuzzerCore&) = delete;
+
+  // JS bindings
+  static void enqueue_mutation(Mutation::TARGET target,
+                        Mutation::KIND kind,
+                        WTF::String url);
+
+  static void send_detach();
+
+  // fuzzer hooks
+
+  static std::unique_ptr<const KURL> mutate_kurl_hook(const KURL& url);
+
+  //   std::unique_ptr<const ::GURL> mutate_gurl_hook(const GURL& url);
+
+  static ::scoped_refptr<const SecurityOrigin> mutate_security_origin_hook(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin);
+
+  static std::optional<BlinkSchemefulSite> mutate_schemeful_site_hook(
+      const std::optional<BlinkSchemefulSite>& schemeful_site);
+
+  static std::unique_ptr<const ::net::SiteForCookies>
+  mutate_site_for_cookies_hook(const ::net::SiteForCookies& site_for_cookies);
+
+  static std::unique_ptr<const BlinkStorageKey> mutate_storage_key_hook(
+      const BlinkStorageKey& storage_key);
+
+  //   std::unique_ptr<const ::url::Origin> mutate_origin_hook(
+  //       const ::url::Origin& origin);
+
+  static void mutate_open_url_params_ptr_hook(::blink::mojom::blink::OpenURLParamsPtr& ptr);
+  static void mutate_fetch_api_request_ptr_hook(::blink::mojom::blink::FetchAPIRequestPtr& ptr);
+  static void mutate_fetch_url_request_ptr_hook(::network::mojom::blink::URLRequestPtr& ptr);
+  static void mutate_fetch_trusted_request_params_ptr_hook(::network::mojom::blink::TrustedUrlRequestParamsPtr& ptr);
+
+  static std::unique_ptr<const ::network::ResourceRequest> mutate_ressource_request_hook(const ::network::ResourceRequest& request);
+
+
+
+ private:
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_CORE_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.cc b/third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.cc
new file mode 100644
index 0000000000000..34e2897d458b7
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.cc
@@ -0,0 +1,330 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.h"
+#include "base/logging.h"
+#include "url/gurl.h"
+
+namespace blink {
+
+std::unique_ptr<const KURL> BlinkMutator::mutate_url(
+    const KURL& url,
+    const Mutation& mutation) {
+  std::unique_ptr<const KURL> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated = url_replace_host(url, KURL(mutation.get_url()));
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = std::make_unique<const KURL>(KURL(mutation.get_url()));
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   LOG(INFO) << "IPCFuzzer mutated: KURL " << *mutated;
+  // }
+  return mutated;
+}
+
+// return scoped_refptr because that is used by all Mojo functions
+::scoped_refptr<const SecurityOrigin> BlinkMutator::mutate_security_origin(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin,
+    const Mutation& mutation) {
+  ::scoped_refptr<const SecurityOrigin> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated =
+          security_origin_replace_host(security_origin, KURL(mutation.get_url()));
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = SecurityOrigin::CreateWithReferenceOrigin(
+          KURL(mutation.get_url()), nullptr);
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   LOG(INFO) << "IPCFuzzer mutated: SecurityOrigin " << mutated->ToString();
+  // }
+  return mutated;
+}
+
+// return optional because that is used by all Mojo functions
+std::optional<BlinkSchemefulSite> BlinkMutator::mutate_schemeful_site(
+    const std::optional<BlinkSchemefulSite>& schemeful_site,
+    const Mutation& mutation) {
+  std::optional<BlinkSchemefulSite> mutated = std::nullopt;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated = schemeful_site_replace_host(schemeful_site, KURL(mutation.get_url()));
+      break;
+    case Mutation::KIND::REPLACE_WHOLE: {
+      auto security_origin = SecurityOrigin::CreateWithReferenceOrigin(
+          KURL(mutation.get_url()), nullptr);
+      mutated = BlinkSchemefulSite(security_origin);
+    } break;
+  }
+  // if (mutated.has_value()) {
+  //   LOG(INFO) << "IPCFuzzer mutated: BlinkSchemefulSite "
+  //              << mutated.value().GetDebugString();
+  // }
+  return mutated;
+}
+
+std::unique_ptr<const ::net::SiteForCookies> BlinkMutator::mutate_site_for_cookies(
+    const ::net::SiteForCookies& site_for_cookies,
+    const Mutation& mutation) {
+  std::unique_ptr<const ::net::SiteForCookies> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated =
+          site_for_cookies_replace_host(site_for_cookies, KURL(mutation.get_url()));
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = std::make_unique<const ::net::SiteForCookies>(
+          ::net::SiteForCookies::FromUrl(GURL(KURL(mutation.get_url()))));
+      break;
+  }
+  // if (mutated != nullptr) {KURL(mutation.get_url())
+  //   LOG(INFO) << "IPCFuzzer mutated: SiteForCookies "
+  //              << mutated->ToDebugString();
+  // }
+  return mutated;
+}
+
+// TODO: implement more different mutations
+std::unique_ptr<const BlinkStorageKey> BlinkMutator::mutate_storage_key(
+    const BlinkStorageKey& storage_key,
+    const Mutation& mutation) {
+  std::unique_ptr<const BlinkStorageKey> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated = storage_key_replace_host(storage_key, KURL(mutation.get_url()));
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      if (storage_key.GetTopLevelSite().IsOpaque()) {
+        mutated = create_storage_key(KURL(mutation.get_url()));
+      } else {
+        mutated = create_storage_key(KURL(mutation.get_url()),
+                                     storage_key.GetAncestorChainBit());
+      }
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   LOG(INFO) << "IPCFuzzer mutated: BlinkStorageKey "
+  //              << mutated->ToDebugString();
+  // }
+  return mutated;
+}
+
+// private helper functions
+
+std::unique_ptr<KURL> BlinkMutator::url_replace_host(
+    const KURL& url,
+    const KURL& replacement) {
+  if (!can_replace_host(url)) {
+    return url_replace_inner_host(url, replacement);
+  }
+
+  std::unique_ptr<KURL> new_url = std::make_unique<KURL>(url);
+  new_url->SetHost(replacement.Host());
+  if (replacement.HasPort()) {
+    new_url->SetPort(replacement.Port());
+  } else {
+    new_url->RemovePort();
+  }
+  return new_url;
+}
+
+std::unique_ptr<KURL> BlinkMutator::url_replace_inner_host(
+    const KURL& url,
+    const KURL& replacement) {
+  if (!can_replace_inner_host(url)) {
+    return nullptr;
+  }
+
+  WTF::String protocol;
+  if (url.ProtocolIs("blob")) {
+    protocol = "blob:";
+  } else if (url.ProtocolIs("filesystem")) {
+    protocol = "filesystem:";
+  }
+
+  WTF::String url_str = url.GetString();
+  url_str.Replace(protocol, "");
+
+  KURL inner_url(url_str);
+
+  // if (inner_url.IsNull() || inner_url.IsEmpty()) {
+  //   LOG(INFO) << "IPCFuzzer mutating inner url failed";
+  //   return nullptr;
+  // }
+
+  inner_url.SetHost(replacement.Host());
+  if (replacement.HasPort()) {
+    inner_url.SetPort(replacement.Port());
+  } else {
+    inner_url.RemovePort();
+  }
+  std::unique_ptr<KURL> new_url =
+      std::make_unique<KURL>(protocol + inner_url.GetString());
+  return new_url;
+}
+
+::scoped_refptr<const SecurityOrigin>
+BlinkMutator::security_origin_replace_host(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin,
+    const KURL& replacement) {
+  if (!can_replace_host(security_origin)) {
+    return nullptr;
+  }
+  KURL url(security_origin->ToString());
+
+  std::unique_ptr<blink::KURL> new_url = url_replace_host(url, replacement);
+  if (new_url == nullptr) {
+    // replacing host failed
+    return nullptr;
+  }
+
+  return SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+}
+
+std::optional<BlinkSchemefulSite>
+BlinkMutator::schemeful_site_replace_host(
+    const std::optional<BlinkSchemefulSite>& schemeful_site,
+    const KURL& replacement) {
+  if (!can_replace_host(schemeful_site)) {
+    return std::nullopt;
+  }
+
+  String schemeful_site_str = schemeful_site.value().Serialize();
+
+  std::unique_ptr<KURL> new_url =
+      url_replace_host(KURL(schemeful_site_str), replacement);
+  if (new_url == nullptr) {
+    return std::nullopt;
+  }
+
+  auto origin =
+      SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+  return BlinkSchemefulSite(origin);
+}
+
+std::unique_ptr<::net::SiteForCookies> BlinkMutator::site_for_cookies_replace_host(
+    const ::net::SiteForCookies& site_for_cookies,
+    const KURL& replacement) {
+  if (!can_replace_host(site_for_cookies)) {
+    return nullptr;
+  }
+
+  GURL url = site_for_cookies.RepresentativeUrl();
+  std::unique_ptr<KURL> new_url =
+      url_replace_host(KURL(url), replacement);
+  if (new_url == nullptr) {
+    return nullptr;
+  }
+
+  return std::make_unique<::net::SiteForCookies>(
+      ::net::SiteForCookies::FromUrl(GURL(*new_url)));
+}
+
+std::unique_ptr<BlinkStorageKey> BlinkMutator::storage_key_replace_host(
+    const BlinkStorageKey& storage_key,
+    const KURL& replacement) {
+  auto security_origin = storage_key.GetSecurityOrigin();
+  ::scoped_refptr<const SecurityOrigin> new_security_origin =
+      security_origin_replace_host(security_origin, replacement);
+  if (new_security_origin == nullptr) {
+    return nullptr;
+  }
+
+  // if the storage key has a nonce, just replace the host and reuse the
+  // nonce
+  // QUESTION: is this right??
+  auto token = storage_key.GetNonce();
+  if (token.has_value()) {
+    return std::make_unique<BlinkStorageKey>(
+        BlinkStorageKey::CreateWithNonce(new_security_origin,
+                                                  token.value()));
+  }
+
+  auto schemeful_site = storage_key.GetTopLevelSite();
+  std::optional<BlinkSchemefulSite> new_schemeful_site =
+      schemeful_site_replace_host(schemeful_site, replacement);
+  if (new_schemeful_site.has_value()) {
+    return std::make_unique<BlinkStorageKey>(
+        BlinkStorageKey::Create(new_security_origin,
+                                         new_schemeful_site.value(),
+                                         storage_key.GetAncestorChainBit()));
+  }
+
+  return std::make_unique<BlinkStorageKey>(
+      BlinkStorageKey::CreateFirstParty(new_security_origin));
+}
+
+std::unique_ptr<BlinkStorageKey> BlinkMutator::create_storage_key(
+    const KURL& url) {
+  auto security_origin =
+      SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+  return std::make_unique<BlinkStorageKey>(
+      BlinkStorageKey::CreateFirstParty(security_origin));
+}
+
+std::unique_ptr<BlinkStorageKey> BlinkMutator::create_storage_key(
+    const KURL& url,
+    mojom::AncestorChainBit ancestor_chain_bit) {
+  auto security_origin =
+      SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+  auto schemeful_site = BlinkSchemefulSite(security_origin);
+  return std::make_unique<BlinkStorageKey>(
+      BlinkStorageKey::Create(security_origin, schemeful_site,
+                                       ancestor_chain_bit));
+}
+
+bool BlinkMutator::can_replace_host(const KURL& url) {
+  if (url.IsNull()) {
+    // LOG(INFO) << "IPCFuzzer KURL is null";
+    return false;
+  }
+  if (url.IsEmpty()) {
+    // LOG(INFO) << "IPCFuzzer KURL is empty";
+    return false;
+  }
+  if (!url.CanSetHostOrPort() || url.ProtocolIs("blob") ||
+      url.ProtocolIs("filesystem")) {
+    return false;
+  }
+  return true;
+}
+
+bool BlinkMutator::can_replace_inner_host(const KURL& url) {
+  if (url.ProtocolIs("blob") || url.ProtocolIs("filesystem")) {
+    return true;
+  }
+  return false;
+}
+
+bool BlinkMutator::can_replace_host(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+  if (security_origin == nullptr || security_origin->IsOpaque()) {
+    return false;
+  }
+  return true;
+}
+
+bool BlinkMutator::can_replace_host(
+    const std::optional<BlinkSchemefulSite>& schemeful_site) {
+  if (!schemeful_site.has_value()) {
+    return false;
+  }
+  if (schemeful_site.value().IsOpaque() ||
+      schemeful_site.value().Serialize() == "null") {
+    return false;
+  }
+  return true;
+}
+
+bool BlinkMutator::can_replace_host(const ::net::SiteForCookies& site_for_cookies) {
+  if (site_for_cookies.IsNull()) {
+    return false;
+  }
+  return true;
+}
+
+}  // namespace ipc_fuzzer
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.h b/third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.h
new file mode 100644
index 0000000000000..bde863426f5a8
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/blink_mutator.h
@@ -0,0 +1,83 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
+
+#include <memory>
+#include "net/cookies/site_for_cookies.h"
+#include "third_party/blink/public/common/ipc_fuzzer/mutation.h"
+#include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+#include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+namespace blink {
+class BlinkMutator {
+ public:
+  static std::unique_ptr<const KURL> mutate_url(
+      const KURL& url,
+      const Mutation& mutation);
+
+  // return scoped_refptr because that is used by all Mojo functions
+  static ::scoped_refptr<const SecurityOrigin> mutate_security_origin(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin,
+      const Mutation& mutation);
+
+  // return optional because that is used by all Mojo functions
+  static std::optional<BlinkSchemefulSite> mutate_schemeful_site(
+      const std::optional<BlinkSchemefulSite>& schemeful_site,
+      const Mutation& mutation);
+
+  static std::unique_ptr<const ::net::SiteForCookies> mutate_site_for_cookies(
+      const ::net::SiteForCookies& site_for_cookies,
+      const Mutation& mutation);
+
+  static std::unique_ptr<const BlinkStorageKey> mutate_storage_key(
+      const BlinkStorageKey& storage_key,
+      const Mutation& mutation);
+
+ private:
+  static std::unique_ptr<KURL> url_replace_host(
+      const KURL& url,
+      const KURL& replacement);
+
+  static std::unique_ptr<KURL> url_replace_inner_host(
+      const KURL& url,
+      const KURL& replacement);
+
+  static ::scoped_refptr<const SecurityOrigin>
+  security_origin_replace_host(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin,
+      const KURL& replacement);
+
+  static std::optional<BlinkSchemefulSite>
+  schemeful_site_replace_host(
+      const std::optional<BlinkSchemefulSite>& schemeful_site,
+      const KURL& replacement);
+
+  static std::unique_ptr<::net::SiteForCookies> site_for_cookies_replace_host(
+      const ::net::SiteForCookies& site_for_cookies,
+      const KURL& replacement);
+
+  static std::unique_ptr<BlinkStorageKey> storage_key_replace_host(
+      const BlinkStorageKey& storage_key,
+      const KURL& replacement);
+
+  static std::unique_ptr<BlinkStorageKey> create_storage_key(
+      const KURL& url);
+  static std::unique_ptr<BlinkStorageKey> create_storage_key(
+      const KURL& url,
+      mojom::AncestorChainBit ancestor_chain_bit);
+
+  static bool can_replace_host(const KURL& url);
+  static bool can_replace_inner_host(const KURL& url);
+  static bool can_replace_host(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin);
+  static bool can_replace_host(
+      const std::optional<BlinkSchemefulSite>& schemeful_site);
+  static bool can_replace_host(const ::net::SiteForCookies& site_for_cookies);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc
new file mode 100644
index 0000000000000..7b00d0762dfdf
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc
@@ -0,0 +1,84 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h"
+#include "base/logging.h"
+#include "third_party/blink/public/mojom/frame/frame.mojom-blink.h"
+#include "third_party/blink/renderer/core/frame/local_dom_window.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
+#include "third_party/blink/renderer/core/frame/local_frame_client.h"
+#include "third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/blink_ipc_fuzzer_core.h"
+
+namespace blink {
+void IPCFuzzer::send_detach(ExecutionContext* context) {
+  LOG(INFO) << "detach frame";
+  BlinkIPCFuzzerCore::send_detach();
+  auto* window = DynamicTo<LocalDOMWindow>(context);
+  // window->GetFrame()->GetLocalFrameHostRemote().Detach();
+  window->GetFrame()->GetLocalFrameHostRemote().DidFailLoadWithError(
+      KURL("http://127.0.0.1:8080"), -1);
+}
+
+void IPCFuzzer::mutate_url(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::URL,
+      Mutation::KIND::REPLACE_WHOLE, new_url.Utf8());
+}
+
+void IPCFuzzer::mutate_url_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::URL, Mutation::KIND::REPLACE_HOST,
+      new_host.Utf8());
+}
+// void IPCFuzzer::mutate_origin(const String& new_url) {
+//   IPCFuzzerCore::GetInstance()->enqueue_mutation(
+//       Mutation::TARGET::ORIGIN,
+//       Mutation::KIND::REPLACE_WHOLE, new_url);
+// }
+void IPCFuzzer::mutate_origin_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::ORIGIN,
+      Mutation::KIND::REPLACE_HOST, new_host.Utf8());
+}
+void IPCFuzzer::mutate_site_for_cookies(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SITE_FOR_COOKIES,
+      Mutation::KIND::REPLACE_WHOLE, new_url.Utf8());
+}
+void IPCFuzzer::mutate_site_for_cookies_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SITE_FOR_COOKIES,
+      Mutation::KIND::REPLACE_HOST, new_host.Utf8());
+}
+void IPCFuzzer::mutate_schemeful_site(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SCHEMEFUL_SITE,
+      Mutation::KIND::REPLACE_WHOLE, new_url.Utf8());
+}
+void IPCFuzzer::mutate_schemeful_site_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SCHEMEFUL_SITE,
+      Mutation::KIND::REPLACE_HOST, new_host.Utf8());
+}
+void IPCFuzzer::mutate_storage_key(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::STORAGE_KEY,
+      Mutation::KIND::REPLACE_WHOLE, new_url.Utf8());
+}
+void IPCFuzzer::mutate_storage_key_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::STORAGE_KEY,
+      Mutation::KIND::REPLACE_HOST, new_host.Utf8());
+}
+
+bool IPCFuzzer::check_isolation(const String& site_url) {
+  return IPCFuzzerCore::GetInstance()->check_isolation(site_url.Utf8());
+}
+
+void IPCFuzzer::deactivate_renderer_checks() {
+  IPCFuzzerCore::GetInstance()->deactivate_renderer_checks();
+}
+
+void IPCFuzzer::activate_leak_sanitizer() {
+  IPCFuzzerCore::GetInstance()->activate_leak_sanitizer();
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h
new file mode 100644
index 0000000000000..597aae0859706
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h
@@ -0,0 +1,33 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
+
+#include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
+#include "third_party/blink/renderer/modules/modules_export.h"
+// #include "third_party/blink/renderer/platform/bindings/script_state.h"
+#include "third_party/blink/renderer/core/execution_context/execution_context.h"
+
+// this is a wrapper around IPCFuzzerCore that exposes the JS API
+
+namespace blink {
+
+class IPCFuzzer final: public ScriptWrappable {
+  DEFINE_WRAPPERTYPEINFO();
+
+ public:
+  static void send_detach(ExecutionContext* context);
+  static void mutate_url(const String& new_url);
+  static void mutate_url_replace_host(const String& new_host);
+  // static void mutate_origin(const String& new_url);
+  static void mutate_origin_replace_host(const String& new_host);
+  static void mutate_site_for_cookies(const String& new_url);
+  static void mutate_site_for_cookies_replace_host(const String& new_host);
+  static void mutate_schemeful_site(const String& new_url);
+  static void mutate_schemeful_site_replace_host(const String& new_host);
+  static void mutate_storage_key(const String& new_url);
+  static void mutate_storage_key_replace_host(const String& new_host);
+  static bool check_isolation(const String& site_url);
+  static void deactivate_renderer_checks();
+  static void activate_leak_sanitizer();
+};
+}  // namespace blink
+#endif // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl
new file mode 100644
index 0000000000000..1fefb2aa325a1
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl
@@ -0,0 +1,16 @@
+[Exposed=*]
+interface IPCFuzzer {
+    [CallWith=ExecutionContext] static void send_detach();
+    static void mutate_url(DOMString new_url);
+    static void mutate_url_replace_host(DOMString new_host);
+    static void mutate_origin_replace_host(DOMString new_host);
+    static void mutate_site_for_cookies(DOMString new_url);
+    static void mutate_site_for_cookies_replace_host(DOMString new_host);
+    static void mutate_schemeful_site(DOMString new_url);
+    static void mutate_schemeful_site_replace_host(DOMString new_host);
+    static void mutate_storage_key(DOMString new_url);
+    static void mutate_storage_key_replace_host(DOMString new_host);
+    static boolean check_isolation(DOMString site_url);
+    static void deactivate_renderer_checks();
+    static void activate_leak_sanitizer();
+};
\ No newline at end of file
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc
new file mode 100644
index 0000000000000..1a7ed14d489f4
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc
@@ -0,0 +1,26 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/url_store.h"
+#include "base/logging.h"
+
+namespace blink {
+UrlStore::UrlStore() = default;
+UrlStore::~UrlStore() = default;
+
+void UrlStore::store(const KURL& url) {
+  if (url.IsNull()) {
+    return;
+  }
+
+  lock_.Acquire();
+  WTF::String s = url.GetString();
+  urls_.insert(s);
+  lock_.Release();
+}
+
+WTF::Vector<WTF::String> UrlStore::get() {
+  lock_.Acquire();
+  WTF::Vector<WTF::String> result(urls_);
+  lock_.Release();
+  return result;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h
new file mode 100644
index 0000000000000..2763393112f83
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h
@@ -0,0 +1,26 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
+
+#include <memory>
+#include "base/synchronization/lock.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/hash_set.h"
+
+namespace blink {
+class UrlStore {
+ public:
+  UrlStore();
+  ~UrlStore();
+
+  void store(const KURL& url);
+  WTF::Vector<WTF::String> get();
+
+ private:
+  base::Lock lock_;
+  WTF::HashSet<WTF::String> urls_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
diff --git a/third_party/blink/renderer/platform/exported/web_security_origin.cc b/third_party/blink/renderer/platform/exported/web_security_origin.cc
index f2d133dffd476..e9ab3aa8e0f29 100644
--- a/third_party/blink/renderer/platform/exported/web_security_origin.cc
+++ b/third_party/blink/renderer/platform/exported/web_security_origin.cc
@@ -34,6 +34,7 @@
 #include "third_party/blink/public/platform/web_url.h"
 #include "third_party/blink/renderer/platform/weborigin/kurl.h"
 #include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+#include "third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h"
 
 namespace blink {
 
@@ -74,22 +75,38 @@ bool WebSecurityOrigin::IsOpaque() const {
 }
 
 bool WebSecurityOrigin::CanAccess(const WebSecurityOrigin& other) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   DCHECK(other.private_);
   return private_->CanAccess(other.private_.Get());
 }
 
 bool WebSecurityOrigin::CanRequest(const WebURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanRequest(url);
 }
 
 bool WebSecurityOrigin::CanDisplay(const WebURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanDisplay(url);
 }
 
 bool WebSecurityOrigin::IsPotentiallyTrustworthy() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->IsPotentiallyTrustworthy();
 }
@@ -100,11 +117,16 @@ WebString WebSecurityOrigin::ToString() const {
 }
 
 bool WebSecurityOrigin::CanAccessPasswordManager() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanAccessPasswordManager();
 }
 
 bool WebSecurityOrigin::IsSameOriginWith(const WebSecurityOrigin& other) const {
+  // TODO(j.drescher) check if this can be disabled or how
   DCHECK(private_);
   DCHECK(other.private_);
   return private_->IsSameOriginWith(other.private_.Get());
diff --git a/third_party/blink/renderer/platform/weborigin/security_origin.cc b/third_party/blink/renderer/platform/weborigin/security_origin.cc
index 93912a10ba65c..4e3f89e3800a8 100644
--- a/third_party/blink/renderer/platform/weborigin/security_origin.cc
+++ b/third_party/blink/renderer/platform/weborigin/security_origin.cc
@@ -52,6 +52,7 @@
 #include "url/url_canon.h"
 #include "url/url_canon_ip.h"
 #include "url/url_util.h"
+#include "third_party/blink/public/common/ipc_fuzzer/ipc_fuzzer_core.h"
 
 namespace blink {
 
@@ -322,6 +323,10 @@ const base::UnguessableToken* SecurityOrigin::GetNonceForSerialization() const {
 
 bool SecurityOrigin::CanAccess(const SecurityOrigin* other,
                                AccessResultDomainDetail& detail) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_) {
     detail = AccessResultDomainDetail::kDomainNotRelevant;
     return true;
@@ -341,6 +346,10 @@ bool SecurityOrigin::CanAccess(const SecurityOrigin* other,
 }
 
 bool SecurityOrigin::PassesFileCheck(const SecurityOrigin* other) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(IsLocal());
   DCHECK(other->IsLocal());
 
@@ -349,6 +358,10 @@ bool SecurityOrigin::PassesFileCheck(const SecurityOrigin* other) const {
 }
 
 bool SecurityOrigin::CanRequest(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_)
     return true;
 
@@ -387,6 +400,10 @@ bool SecurityOrigin::CanRequest(const KURL& url) const {
 }
 
 bool SecurityOrigin::CanReadContent(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (CanRequest(url))
     return true;
 
@@ -401,6 +418,10 @@ bool SecurityOrigin::CanReadContent(const KURL& url) const {
 }
 
 bool SecurityOrigin::CanDisplay(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_)
     return true;
 
@@ -422,6 +443,10 @@ bool SecurityOrigin::CanDisplay(const KURL& url) const {
 }
 
 bool SecurityOrigin::IsPotentiallyTrustworthy() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   // TODO(https://crbug.com/1153336): The code below can hopefully be eventually
   // deleted and IsOriginPotentiallyTrustworthy can be used instead (from
   // //services/network/public/cpp/is_potentially_trustworthy.h).
