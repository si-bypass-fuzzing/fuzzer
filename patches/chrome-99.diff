diff --git a/mojo/public/cpp/bindings/lib/message.cc b/mojo/public/cpp/bindings/lib/message.cc
index de137099f3f75..186c639aa7de6 100644
--- a/mojo/public/cpp/bindings/lib/message.cc
+++ b/mojo/public/cpp/bindings/lib/message.cc
@@ -28,6 +28,7 @@
 #include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
 
 namespace mojo {
+  void (*leakSanitizerCallback)(const char* data, size_t data_len) = nullptr;
 
 namespace {
 
@@ -325,6 +326,10 @@ Message Message::CreateFromMessageHandle(ScopedMessageHandle* message_handle) {
       return Message();
     }
 
+    if (::mojo::leakSanitizerCallback != nullptr) {
+      (*::mojo::leakSanitizerCallback)((char*)(buffer), num_bytes);
+    }
+
     return Message(std::move(*message_handle), std::move(handles),
                    internal::Buffer(buffer, num_bytes, num_bytes),
                    true /* serialized */);
diff --git a/mojo/public/cpp/bindings/message.h b/mojo/public/cpp/bindings/message.h
index 8183c6becc16d..bd3e7005c8619 100644
--- a/mojo/public/cpp/bindings/message.h
+++ b/mojo/public/cpp/bindings/message.h
@@ -28,6 +28,8 @@
 #include "third_party/perfetto/include/perfetto/tracing/traced_value_forward.h"
 
 namespace mojo {
+  extern void (*leakSanitizerCallback)(const char*, size_t);
+
 
 class AssociatedGroupController;
 
diff --git a/mojo/public/tools/bindings/BUILD.gn b/mojo/public/tools/bindings/BUILD.gn
index 3f10dae2f4b2d..4db91d9cce584 100644
--- a/mojo/public/tools/bindings/BUILD.gn
+++ b/mojo/public/tools/bindings/BUILD.gn
@@ -89,6 +89,7 @@ action("precompile_templates") {
     "$mojom_generator_root/generators/mojolpm_templates/mojolpm_traits_specialization_macros.tmpl",
     "$mojom_generator_root/generators/ts_templates/module_definition.tmpl",
     "$mojom_generator_root/generators/ts_templates/mojom.tmpl",
+    "$mojom_generator_root/generators/cpp_templates/interface_fuzzer.tmpl",
   ]
   script = mojom_generator_script
 
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
index d382e27149bd5..411cd9c247d90 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
@@ -1,5 +1,6 @@
 {%- import "interface_macros.tmpl" as interface_macros %}
 {%- import "struct_macros.tmpl" as struct_macros %}
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
 
 {%- set class_name = interface.name %}
 {%- set proxy_name = interface.name ~ "Proxy" %}
@@ -125,8 +126,10 @@ class {{class_name}}_{{method.name}}_ForwardToCallback
 {%-   endif %}
 
 {%-   if method.sync %}
-bool {{proxy_name}}::{{method.name}}(
-    {{interface_macros.declare_sync_method_params("param_", method)}}) {
+bool {{proxy_name}}::{{method.name}}({{interface_fuzzer.declare_sync_method_params_fuzzed(qualified_class_name,"param_", method)}}) {
+{{interface_fuzzer.insert_fuzzer_hook(qualified_class_name,"param_", method.parameters, method.name)}}
+// WORK
+
 #if BUILDFLAG(MOJO_TRACE_ENABLED)
 {%-     set event_name = "Call %s::%s::%s (sync)" % (namespace_as_string,
                                                     class_name, method.name) %}
@@ -184,8 +187,10 @@ bool {{proxy_name}}::{{method.name}}(
 }
 {%-   endif %}  {#- if method.sync #}
 
-void {{proxy_name}}::{{method.name}}(
-    {{interface_macros.declare_request_params("in_", method)}}) {
+void {{proxy_name}}::{{method.name}}({{interface_fuzzer.declare_request_params_fuzzed(qualified_class_name, "in_", method)}}) {
+{{interface_fuzzer.insert_fuzzer_hook(qualified_class_name,"in_", method.parameters, method.name)}}
+// WORK
+
 #if BUILDFLAG(MOJO_TRACE_ENABLED)
 {%- set event_name = "Send %s::%s::%s" % (namespace_as_string, class_name,
                                           method.name) %}
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl
new file mode 100644
index 0000000000000..f468e3f7f8864
--- /dev/null
+++ b/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl
@@ -0,0 +1,111 @@
+{%- import "interface_macros.tmpl" as interface_macros %}
+
+{# "::network::mojom::blink::NetworkContext" #}
+{%- set classes_to_fuzz = ["::blink::mojom::blink::BlobURLStore", "::network::mojom::blink::RestrictedCookieManager", "::blink::mojom::blink::FileSystemManager", "::network::mojom::blink::NetworkContext", "::blink::mojom::blink::DomStorage", "::network::mojom::blink::URLLoaderFactory", "::blink::mojom::blink::RemoteFrameHost", "::blink::mojom::blink::LocalFrameHost"] %}
+{%- set other_classes = ["::content_settings::mojom::ContentSettingsManager", "::content::mojom::FrameHost"] %}
+
+{%- macro insert_fuzzer_hook(qualified_class_name, prefix, parameters, method_name) %}
+// {{qualified_class_name}}
+
+{# log all IPC calls that have interesting parameters #}
+{%-   for param in parameters %}
+{%-   if param.is_mutated or param.is_interesting  %}
+{# DLOG(INFO) << "PARAM {{qualified_class_name}}::{{method_name}}() - {{param.kind|cpp_wrapper_param_type}} {{prefix}}{{param.name}}"; #}
+{%-   endif %}
+{%-   endfor %}
+
+{%- if qualified_class_name in classes_to_fuzz %}
+// FUZZME
+{# DLOG(INFO) << "IPCFuzzer intercept function: {{qualified_class_name}}::{{method_name}}()"; #}
+{%-   for param in parameters %}
+{%-   if param.is_mutated  %}
+{%- if param.kind|cpp_wrapper_param_type == "const ::blink::KURL&" %}
+std::unique_ptr<const ::blink::KURL> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_kurl_hook({{prefix}}{{param.name}}_original);
+const ::blink::KURL& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::GURL&" %}
+std::unique_ptr<const ::GURL> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_gurl_hook({{prefix}}{{param.name}}_original);
+const ::GURL& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::net::SiteForCookies&" %}
+std::unique_ptr<const ::net::SiteForCookies> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_site_for_cookies_hook({{prefix}}{{param.name}}_original);
+const ::net::SiteForCookies& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::scoped_refptr<const ::blink::SecurityOrigin>&" %}
+::scoped_refptr<const ::blink::SecurityOrigin> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_security_origin_hook({{prefix}}{{param.name}}_original);
+const ::scoped_refptr<const ::blink::SecurityOrigin>& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? {{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const absl::optional<::blink::BlinkSchemefulSite>&" %}
+absl::optional<::blink::BlinkSchemefulSite> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_schemeful_site_hook({{prefix}}{{param.name}}_original);
+const absl::optional<::blink::BlinkSchemefulSite>& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated.has_value()) ? {{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::blink::BlinkStorageKey&" %}
+std::unique_ptr<const ::blink::BlinkStorageKey> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_storage_key_hook({{prefix}}{{param.name}}_original);
+const ::blink::BlinkStorageKey& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::url::Origin&" %}
+std::unique_ptr<const ::url::Origin> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_origin_hook({{prefix}}{{param.name}}_original);
+const ::url::Origin& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- endif %}
+{%-   endif %}
+{%-   endfor %}
+{%-   endif %} {#- if qualified_class_name in classes_to_fuzz #}
+{%- endmacro %}
+
+
+{%- macro insert_fuzzer_dependency(all_interfaces, all_namespaces, variant) %}
+{%- set insert_condition = namespace(bool=false) %}
+{%- set class_namespace = "::" %}
+{%- if all_namespaces|length > 1 %}
+{%- set class_namespace = class_namespace ~ all_namespaces|join("::") ~ "::" ~ (variant ~ "::" if variant) %}
+{%- endif %}
+
+{%- for interface in all_interfaces %}
+{%- set class_name = interface.name %}
+{%- set qualified_class_name = class_namespace ~ class_name %}
+  {%- if qualified_class_name in classes_to_fuzz %}
+    {%- set insert_condition.bool = true %}
+  {%- endif %}
+{%- endfor %}
+
+{%-   if insert_condition.bool  %}
+#include "base/logging.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+{%-   endif %} {#- if insert_condition.bool #}
+{%- endmacro %}
+
+{%- macro declare_params_mutated(prefix, parameters) %}
+{%-   for param in parameters -%}
+{{param.kind|cpp_wrapper_param_type}} {{prefix}}{{param.name}}{{"_original" if param.is_mutated else ""}}
+{%- if not loop.last %}, {% endif %}
+{%-   endfor %}
+{%- endmacro %}
+
+{%- macro declare_sync_method_params_mutated(prefix, method) -%}
+{{declare_params_mutated(prefix, method.parameters)}}
+{%-   if method.response_parameters %}
+{%-     if method.parameters %}, {% endif %}
+{%-     for param in method.response_parameters -%}
+{{param.kind|cpp_wrapper_call_type}}* out_{{prefix}}{{param.name}}
+{%-       if not loop.last %}, {% endif %}
+{%-     endfor %}
+{%-   endif -%}
+{%- endmacro -%}
+
+{%- macro declare_request_params_mutated(prefix, method) -%}
+{{declare_params_mutated(prefix, method.parameters)}}
+{%-   if method.response_parameters != None -%}
+{%-     if method.parameters %}, {% endif -%}
+{{method.name}}Callback callback
+{%-   endif -%}
+{%- endmacro -%}
+
+{%- macro declare_request_params_fuzzed(qualified_class_name, prefix, method) -%}
+{%- if qualified_class_name in classes_to_fuzz %}
+{{declare_request_params_mutated(prefix, method)}}
+{%- else %}
+{{interface_macros.declare_request_params(prefix, method)}}
+{%- endif %}
+{%- endmacro -%}
+
+{%- macro declare_sync_method_params_fuzzed(qualified_class_name, prefix, method) -%}
+{%- if qualified_class_name in classes_to_fuzz %}
+{{declare_sync_method_params_mutated(prefix, method)}} 
+{%- else %}
+{{interface_macros.declare_sync_method_params(prefix, method)}}
+{%- endif %}
+{%- endmacro -%}
\ No newline at end of file
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
index 38234e83bd157..d7554e542bbc1 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
@@ -1,6 +1,7 @@
 // Copyright 2016 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
 
 #include "{{module.path}}-shared.h"
 
@@ -21,6 +22,8 @@
 #include "{{header}}"
 {%- endfor %}
 
+{{interface_fuzzer.insert_fuzzer_dependency(interfaces, namespaces_as_array)}}
+
 {%- for namespace in namespaces_as_array %}
 namespace {{namespace}} {
 {%- endfor %}
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
index ee5fa3492f222..518ae01165070 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
+
 {%- if variant -%}
 {%-   set variant_path = "%s-%s"|format(module.path, variant) -%}
 {%- else -%}
@@ -59,6 +61,7 @@
 {%- endfor %}
 #endif
 
+{{interface_fuzzer.insert_fuzzer_dependency(interfaces, namespaces_as_array, variant)}}
 
 {%- macro namespace_begin() %}
 {%-   for namespace in namespaces_as_array %}
diff --git a/mojo/public/tools/mojom/mojom/generate/module.py b/mojo/public/tools/mojom/mojom/generate/module.py
index 3bba7dd285812..7722f1ebd07f8 100644
--- a/mojo/public/tools/mojom/mojom/generate/module.py
+++ b/mojo/public/tools/mojom/mojom/generate/module.py
@@ -990,6 +990,37 @@ class Parameter(object):
   def min_version(self):
     return self.attributes.get(ATTRIBUTE_MIN_VERSION) \
         if self.attributes else None
+  
+  @property
+  def is_mutated(self):
+    # is one of the parameters types targeted by the IPC fuzzer mutation?
+    if not isinstance(self.kind, Struct):
+      return False
+    if self.kind.module is None or not isinstance(self.kind.module, Module):
+      return False
+    if self.kind.mojom_name == 'Url' and self.kind.module.mojom_namespace == 'url.mojom':
+      return True
+    if self.kind.mojom_name == 'SiteForCookies' and self.kind.module.mojom_namespace == 'network.mojom':
+      return True
+    if self.kind.mojom_name == 'SchemefulSite' and self.kind.module.mojom_namespace == 'network.mojom':
+      return True
+    if self.kind.mojom_name == 'Origin' and self.kind.module.mojom_namespace == 'url.mojom':
+      return True
+    if self.kind.mojom_name == 'StorageKey' and self.kind.module.mojom_namespace == 'blink.mojom':
+      return True
+    
+    return False
+  
+  @property
+  def is_interesting(self):
+    if self.kind.mojom_name == "OpenURLParams" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True
+    if self.kind.mojom_name == "FetchAPIRequest" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True # probably not relevant
+    if self.kind.mojom_name == "CommonNavigationParams" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True
+    
+    return False
 
   def __eq__(self, rhs):
     return (isinstance(rhs, Parameter)
diff --git a/third_party/blink/renderer/bindings/generated_in_modules.gni b/third_party/blink/renderer/bindings/generated_in_modules.gni
index 3fb1274d8cd07..e950fdc099a45 100644
--- a/third_party/blink/renderer/bindings/generated_in_modules.gni
+++ b/third_party/blink/renderer/bindings/generated_in_modules.gni
@@ -2483,6 +2483,8 @@ generated_interface_sources_in_modules = [
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_depth_information.h",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_layer.cc",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_webgl_layer.h",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_ipc_fuzzer.cc",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_ipc_fuzzer.h",
 ]
 
 generated_namespace_sources_in_modules = [
diff --git a/third_party/blink/renderer/bindings/idl_in_modules.gni b/third_party/blink/renderer/bindings/idl_in_modules.gni
index e52909ef88b7e..c60ef44283878 100644
--- a/third_party/blink/renderer/bindings/idl_in_modules.gni
+++ b/third_party/blink/renderer/bindings/idl_in_modules.gni
@@ -1141,6 +1141,7 @@ static_idl_files_in_modules = get_path_info(
           "//third_party/blink/renderer/modules/xr/xr_webgl_depth_information.idl",
           "//third_party/blink/renderer/modules/xr/xr_webgl_layer.idl",
           "//third_party/blink/renderer/modules/xr/xr_webgl_layer_init.idl",
+          "//third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl",
         ],
         "abspath")
 
diff --git a/third_party/blink/renderer/core/dom/document.cc b/third_party/blink/renderer/core/dom/document.cc
index 3af2462a30929..281433b397955 100644
--- a/third_party/blink/renderer/core/dom/document.cc
+++ b/third_party/blink/renderer/core/dom/document.cc
@@ -344,6 +344,7 @@
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_buffer.h"
 #include "third_party/blink/renderer/platform/wtf/text/text_encoding_registry.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
 
 #ifndef NDEBUG
 using WeakDocumentSet = blink::HeapHashSet<blink::WeakMember<blink::Document>>;
@@ -2679,6 +2680,8 @@ StyleResolver& Document::GetStyleResolver() const {
 }
 
 void Document::Initialize() {
+  ::blink::IPCFuzzerCore::GetInstance()->register_document(Url());
+  
   DCHECK_EQ(lifecycle_.GetState(), DocumentLifecycle::kInactive);
   DCHECK(!ax_object_cache_ || this != &AXObjectCacheOwner());
 
diff --git a/third_party/blink/renderer/core/loader/base_fetch_context.cc b/third_party/blink/renderer/core/loader/base_fetch_context.cc
index 539bc71d59d66..531679f0ac846 100644
--- a/third_party/blink/renderer/core/loader/base_fetch_context.cc
+++ b/third_party/blink/renderer/core/loader/base_fetch_context.cc
@@ -33,6 +33,8 @@
 #include "third_party/blink/renderer/platform/weborigin/scheme_registry.h"
 #include "third_party/blink/renderer/platform/weborigin/security_policy.h"
 
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+
 namespace {
 
 // Creates a serialized AtomicString header value out of the input string, using
@@ -71,6 +73,10 @@ absl::optional<ResourceRequestBlockedReason> BaseFetchContext::CanRequest(
     const ResourceLoaderOptions& options,
     ReportingDisposition reporting_disposition,
     const absl::optional<ResourceRequest::RedirectInfo>& redirect_info) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return absl::nullopt;
+  }
   absl::optional<ResourceRequestBlockedReason> blocked_reason =
       CanRequestInternal(type, resource_request, url, options,
                          reporting_disposition, redirect_info);
@@ -90,6 +96,10 @@ BaseFetchContext::CanRequestBasedOnSubresourceFilterOnly(
     const ResourceLoaderOptions& options,
     ReportingDisposition reporting_disposition,
     const absl::optional<ResourceRequest::RedirectInfo>& redirect_info) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return absl::nullopt;
+  }
   auto* subresource_filter = GetSubresourceFilter();
   if (subresource_filter &&
       !subresource_filter->AllowLoad(url, resource_request.GetRequestContext(),
diff --git a/third_party/blink/renderer/modules/BUILD.gn b/third_party/blink/renderer/modules/BUILD.gn
index 9c2d9c9c2abb7..9d5481ab8ea87 100644
--- a/third_party/blink/renderer/modules/BUILD.gn
+++ b/third_party/blink/renderer/modules/BUILD.gn
@@ -161,6 +161,7 @@ component("modules") {
     "//third_party/blink/renderer/modules/webusb",
     "//third_party/blink/renderer/modules/worklet",
     "//third_party/blink/renderer/modules/xr",
+    "//third_party/blink/renderer/modules/ipc_fuzzer",
   ]
 
   # This uses target_os rather than current_os (which is what is_android is set
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn b/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000..01904ed089c09
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn
@@ -0,0 +1,22 @@
+import("//third_party/blink/renderer/modules/modules.gni")
+
+blink_modules_sources("ipc_fuzzer") {
+  sources = [
+    "ipc_fuzzer.cc",
+    "ipc_fuzzer.h",
+    "ipc_fuzzer_core.cc",
+    "ipc_fuzzer_core.h",
+    "mutation.cc",
+    "mutation.h",
+    "mutation_store.cc",
+    "mutation_store.h",
+    "mutator.cc",
+    "mutator.h",
+    "url_store.cc",
+    "url_store.h",
+  ]
+
+  deps = [
+    "//third_party/abseil-cpp:absl",
+  ]
+}
\ No newline at end of file
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc
new file mode 100644
index 0000000000000..3bf90e56fb1d6
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc
@@ -0,0 +1,80 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h"
+#include "base/logging.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+#include "third_party/blink/renderer/core/frame/local_dom_window.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
+#include "third_party/blink/renderer/core/frame/local_frame_client.h"
+#include "third_party/blink/public/mojom/frame/frame.mojom-blink.h"
+
+namespace blink {
+void IPCFuzzer::send_detach(ExecutionContext* context) {
+  DLOG(INFO) << "detach frame";
+  IPCFuzzerCore::GetInstance()->send_detach();
+  auto* window = DynamicTo<LocalDOMWindow>(context);
+  // window->GetFrame()->GetLocalFrameHostRemote().Detach();
+  window->GetFrame()->GetLocalFrameHostRemote().DidFailLoadWithError(KURL("http://127.0.0.1:8080"), -1);
+}
+void IPCFuzzer::mutate_url(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::URL, Mutation::KIND::REPLACE_WHOLE, new_url);
+}
+
+void IPCFuzzer::mutate_url_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::URL, Mutation::KIND::REPLACE_HOST, new_host);
+}
+// void IPCFuzzer::mutate_origin(const String& new_url) {
+//   IPCFuzzerCore::GetInstance()->enqueue_mutation(
+//       Mutation::TARGET::ORIGIN, Mutation::KIND::REPLACE_WHOLE, new_url);
+// }
+void IPCFuzzer::mutate_origin_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::ORIGIN, Mutation::KIND::REPLACE_HOST, new_host);
+}
+void IPCFuzzer::mutate_site_for_cookies(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SITE_FOR_COOKIES, Mutation::KIND::REPLACE_WHOLE,
+      new_url);
+}
+void IPCFuzzer::mutate_site_for_cookies_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SITE_FOR_COOKIES, Mutation::KIND::REPLACE_HOST,
+      new_host);
+}
+void IPCFuzzer::mutate_schemeful_site(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SCHEMEFUL_SITE, Mutation::KIND::REPLACE_WHOLE, new_url);
+}
+void IPCFuzzer::mutate_schemeful_site_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SCHEMEFUL_SITE, Mutation::KIND::REPLACE_HOST, new_host);
+}
+void IPCFuzzer::mutate_storage_key(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::STORAGE_KEY, Mutation::KIND::REPLACE_WHOLE, new_url);
+}
+void IPCFuzzer::mutate_storage_key_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::STORAGE_KEY, Mutation::KIND::REPLACE_HOST, new_host);
+}
+String IPCFuzzer::mutations() {
+  return IPCFuzzerCore::GetInstance()->list_mutations();
+}
+
+Vector<String> IPCFuzzer::leak() {
+  return IPCFuzzerCore::GetInstance()->leak();
+}
+
+bool IPCFuzzer::check_isolation(const String& site_url){
+  return IPCFuzzerCore::GetInstance()->check_isolation(site_url);
+}
+
+void IPCFuzzer::deactivate_renderer_checks(){
+  IPCFuzzerCore::GetInstance()->deactivate_renderer_checks();
+}
+
+void IPCFuzzer::activate_leak_sanitizer(){
+  IPCFuzzerCore::GetInstance()->activate_leak_sanitizer();
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h
new file mode 100644
index 0000000000000..43ee7c1213f5f
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h
@@ -0,0 +1,35 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
+
+#include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
+#include "third_party/blink/renderer/modules/modules_export.h"
+// #include "third_party/blink/renderer/platform/bindings/script_state.h"
+#include "third_party/blink/renderer/core/execution_context/execution_context.h"
+
+// this is a wrapper around IPCFuzzerCore that exposes the JS API
+
+namespace blink {
+
+class IPCFuzzer final: public ScriptWrappable {
+  DEFINE_WRAPPERTYPEINFO();
+
+ public:
+  static void send_detach(ExecutionContext* context);
+  static void mutate_url(const String& new_url);
+  static void mutate_url_replace_host(const String& new_host);
+  // static void mutate_origin(const String& new_url);
+  static void mutate_origin_replace_host(const String& new_host);
+  static void mutate_site_for_cookies(const String& new_url);
+  static void mutate_site_for_cookies_replace_host(const String& new_host);
+  static void mutate_schemeful_site(const String& new_url);
+  static void mutate_schemeful_site_replace_host(const String& new_host);
+  static void mutate_storage_key(const String& new_url);
+  static void mutate_storage_key_replace_host(const String& new_host);
+  static String mutations();
+  static Vector<String> leak();
+  static bool check_isolation(const String& site_url);
+  static void deactivate_renderer_checks();
+  static void activate_leak_sanitizer();
+};
+}  // namespace blink
+#endif // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl
new file mode 100644
index 0000000000000..24f0854ed6e1d
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl
@@ -0,0 +1,18 @@
+[Exposed=Window]
+interface IPCFuzzer {
+    [CallWith=ExecutionContext] static void send_detach();
+    static void mutate_url(DOMString new_url);
+    static void mutate_url_replace_host(DOMString new_host);
+    static void mutate_origin_replace_host(DOMString new_host);
+    static void mutate_site_for_cookies(DOMString new_url);
+    static void mutate_site_for_cookies_replace_host(DOMString new_host);
+    static void mutate_schemeful_site(DOMString new_url);
+    static void mutate_schemeful_site_replace_host(DOMString new_host);
+    static void mutate_storage_key(DOMString new_url);
+    static void mutate_storage_key_replace_host(DOMString new_host);
+    static DOMString mutations();
+    static sequence<DOMString> leak();
+    static boolean check_isolation(DOMString site_url);
+    static void deactivate_renderer_checks();
+    static void activate_leak_sanitizer();
+};
\ No newline at end of file
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.cc b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.cc
new file mode 100644
index 0000000000000..9baf3240c70b2
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.cc
@@ -0,0 +1,292 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+// #include <csignal>
+#include <csignal>
+#include "base/logging.h"
+#include "base/memory/singleton.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutator.h"
+#include "url/gurl.h"
+
+#include "mojo/public/cpp/bindings/message.h"
+
+// #include "third_party/blink/public/common/navigation/navigation_params.h"
+// #include
+// "third_party/blink/public/mojom/navigation/navigation_params.mojom-blink.h"
+#include "third_party/blink/public/mojom/navigation/navigation_params.mojom.h"
+
+namespace blink {
+
+  char magicString[MAGIC_LENGTH+1] = "8bf18cb9455f4a8e8fa93d14ab5ebb5d";
+
+bool containsMagicString(const char *data, size_t data_len){
+  // search for utf-8 magic string
+  if (data_len < MAGIC_LENGTH) {
+    return false;
+  }
+  for (size_t i = 0; i < data_len - MAGIC_LENGTH; i++) {
+    bool found = true;
+    for (size_t j = 0; j < MAGIC_LENGTH; j++) {
+      if (data[i + j] != magicString[j]) {
+        found = false;
+        break;
+      }
+    }
+    if (found) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Basic function to append a character to a buffer, expanding it if necessary
+void appendChar(char *&str, int &len, int &cap, char c) {
+    if (len + 1 >= cap) {
+        cap *= 2;  // Double the capacity
+        char *newStr = new char[cap];  // Allocate new buffer
+        for (int i = 0; i < len; ++i) {
+            newStr[i] = str[i];  // Copy old content
+        }
+        delete[] str;  // Free old buffer
+        str = newStr;
+    }
+    str[len++] = c;  // Append the character
+    str[len] = '\0';  // Null-terminate the string
+}
+
+// Function to append a hexadecimal representation of a byte to a string
+void appendHex(char *&str, int &len, int &cap, unsigned char byte) {
+    const char *hexDigits = "0123456789ABCDEF";
+    appendChar(str, len, cap, hexDigits[byte >> 4]);
+    appendChar(str, len, cap, hexDigits[byte & 0x0F]);
+}
+
+// Main hexDump function that returns a dynamically allocated string
+char* hexDump(const char* data, size_t len) {
+    int capacity = 256;  // Initial capacity of the string
+    char *result = new char[capacity];
+    int resultLen = 0;
+    result[resultLen] = '\0';  // Start with an empty string
+
+    for (size_t i = 0; i < len; ++i) {
+        unsigned char byte = data[i];
+        if (byte >= 0x20 && byte < 0x7E) {  // Printable ASCII range
+            appendChar(result, resultLen, capacity, byte);
+        } else {
+            appendChar(result, resultLen, capacity, '\\');
+            appendChar(result, resultLen, capacity, 'x');
+            appendHex(result, resultLen, capacity, byte);
+        }
+    }
+
+    return result;
+}
+
+void leakSanitizer(const char* data, size_t data_len) {
+  // char* output = hexDump(data, data_len);
+  // LOG(ERROR) << output;
+  // delete[] output;
+
+  if (data != nullptr && data_len > 0 && containsMagicString(data, data_len)) {
+    char* output = hexDump(data, data_len);
+    LOG(ERROR) << "[UXSS] leak in IPC message: " << output;
+    delete[] output;
+  }
+}
+
+void IPCFuzzerCore::activate_leak_sanitizer() {
+  // ::IPC::leakSanitizerCallback = &leakSanitizer;
+  ::mojo::leakSanitizerCallback = &leakSanitizer;
+}
+
+IPCFuzzerCore* IPCFuzzerCore::GetInstance() {
+  return ::base::Singleton<IPCFuzzerCore>::get();
+}
+
+IPCFuzzerCore::IPCFuzzerCore()
+    : url_mutation_store_(),
+      security_origin_mutation_store_(),
+      schemeful_site_mutation_store_(),
+      site_for_cookies_mutation_store_(),
+      storage_key_mutation_store_(),
+      url_store_(),
+      lock_(),
+      locked_site_(absl::nullopt) {
+  LOG(INFO) << "RENDERER PROCESS";
+  sigignore(SIGTERM);
+}
+
+IPCFuzzerCore::~IPCFuzzerCore() = default;
+
+// todo ignore kill signals
+void IPCFuzzerCore::send_detach() {
+  // DLOG(INFO) << "send detach message to browser";
+}
+
+void IPCFuzzerCore::register_document(const KURL& url) {
+  url_store_.store(url);
+}
+
+WTF::Vector<WTF::String> IPCFuzzerCore::leak() {
+  // WTF::String result;
+  // for (const WTF::String& s : url_store_.get()) {
+  //   result = result + s + "\n";
+  // }
+  // return result;
+  return url_store_.get();
+}
+
+void IPCFuzzerCore::deactivate_renderer_checks() {
+  LOG(ERROR) << "deadbeef" ;
+  checks_deactivated = true;
+}
+
+void IPCFuzzerCore::enqueue_mutation(Mutation::TARGET target,
+                                     Mutation::KIND kind,
+                                     WTF::String url) {
+  switch (target) {
+    case Mutation::TARGET::URL:
+      url_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::ORIGIN:
+      security_origin_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::SITE_FOR_COOKIES:
+      site_for_cookies_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::SCHEMEFUL_SITE:
+      schemeful_site_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::STORAGE_KEY:
+      storage_key_mutation_store_.enqueue(target, kind, url);
+      break;
+  }
+}
+
+WTF::String IPCFuzzerCore::list_mutations() {
+  // return mutation_store_.to_string();
+  // TODO fix for multiple stores
+  return "";
+}
+
+std::unique_ptr<const KURL> IPCFuzzerCore::mutate_kurl_hook(const KURL& url) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: KURL " << url;
+  std::unique_ptr<Mutation> mutation = url_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return Mutator::mutate_url(url, *mutation);
+}
+
+std::unique_ptr<const GURL> IPCFuzzerCore::mutate_gurl_hook(const ::GURL& url) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: GURL " << url;
+
+  // todo
+
+  return nullptr;
+}
+
+::scoped_refptr<const SecurityOrigin>
+IPCFuzzerCore::mutate_security_origin_hook(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+  if (security_origin != nullptr) {
+    DLOG(INFO) << "IPCFuzzerCore intercept value: SecurityOrigin "
+               << security_origin->ToString();
+  }
+
+  std::unique_ptr<Mutation> mutation =
+      security_origin_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return Mutator::mutate_security_origin(security_origin, *mutation);
+}
+
+absl::optional<BlinkSchemefulSite> IPCFuzzerCore::mutate_schemeful_site_hook(
+    const absl::optional<BlinkSchemefulSite>& schemeful_site) {
+  if (schemeful_site.has_value()) {
+    DLOG(INFO) << "IPCFuzzerCore intercept value: BlinkSchemefulSite "
+               << schemeful_site.value().GetDebugString();
+  }
+
+  // TODO: only dequeue mutation if IPCFuzzerCore intercept value:ed param has
+  // value?
+  std::unique_ptr<Mutation> mutation = schemeful_site_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return absl::nullopt;
+  }
+
+  return Mutator::mutate_schemeful_site(schemeful_site, *mutation);
+}
+
+std::unique_ptr<const ::net::SiteForCookies>
+IPCFuzzerCore::mutate_site_for_cookies_hook(
+    const ::net::SiteForCookies& site_for_cookies) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: SiteForCookies "
+             << site_for_cookies.ToDebugString();
+
+  std::unique_ptr<Mutation> mutation =
+      site_for_cookies_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return Mutator::mutate_site_for_cookies(site_for_cookies, *mutation);
+}
+
+std::unique_ptr<const BlinkStorageKey> IPCFuzzerCore::mutate_storage_key_hook(
+    const BlinkStorageKey& storage_key) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: BlinkStorageKey "
+             << storage_key.ToDebugString();
+
+  std::unique_ptr<Mutation> mutation = storage_key_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return Mutator::mutate_storage_key(storage_key, *mutation);
+}
+
+std::unique_ptr<const ::url::Origin> IPCFuzzerCore::mutate_origin_hook(
+    const ::url::Origin& origin) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: Origin " << origin.Serialize();
+
+  // todo
+
+  return nullptr;
+}
+
+bool IPCFuzzerCore::check_isolation(const WTF::String& site_url) {
+  KURL url(site_url);
+  auto security_origin =
+      SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+  BlinkSchemefulSite schemeful_site(security_origin);
+
+  lock_.Acquire();
+  if (locked_site_.has_value()) {
+    if (locked_site_.value() == schemeful_site) {
+      lock_.Release();
+      return false;
+    } else {
+      LOG(ERROR) << "[blink] [UXSS] " << schemeful_site.GetDebugString() << " "
+                 << locked_site_.value().GetDebugString();
+      lock_.Release();
+      return true;
+    }
+
+  } else {
+    locked_site_ = schemeful_site;
+    lock_.Release();
+    LOG(INFO) << "LOCK " << schemeful_site.GetDebugString();
+    return false;
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h
new file mode 100644
index 0000000000000..76010b849faa4
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h
@@ -0,0 +1,95 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER__IPC_FUZZER_CORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER__IPC_FUZZER_CORE_H_
+
+#include <memory>
+#include "base/memory/singleton.h"
+#include "net/cookies/site_for_cookies.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/url_store.h"
+#include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+#include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+namespace base {
+template <typename T>
+struct DefaultSingletonTraits;
+}
+
+namespace blink {
+    #define MAGIC_LENGTH 32
+    extern char magicString[MAGIC_LENGTH+1];
+
+    extern void leak_sanitizer(const char* data, size_t data_len);
+    bool containsMagicString(const char* data, size_t data_len);
+    char* hexDump(const char* data, size_t len);
+    void appendHex(char *&str, int &len, int &cap, unsigned char byte);
+    void appendChar(char *&str, int &len, int &cap, char c);
+
+class IPCFuzzerCore {
+ public:
+  ~IPCFuzzerCore();
+
+  static IPCFuzzerCore* GetInstance();
+
+  IPCFuzzerCore(const IPCFuzzerCore&) = delete;
+  IPCFuzzerCore& operator=(const IPCFuzzerCore&) = delete;
+
+  // JS bindings
+  void enqueue_mutation(Mutation::TARGET target,
+                        Mutation::KIND kind,
+                        WTF::String url);
+  void send_detach();
+  WTF::String list_mutations();
+  bool check_isolation(const WTF::String& site_url);
+
+  void register_document(const KURL& url);
+  WTF::Vector<WTF::String> leak();
+
+  void deactivate_renderer_checks();
+  bool checks_deactivated = false;
+
+  void activate_leak_sanitizer();
+
+  // fuzzer hooks
+
+  std::unique_ptr<const KURL> mutate_kurl_hook(const KURL& url);
+
+  std::unique_ptr<const ::GURL> mutate_gurl_hook(const GURL& url);
+
+  ::scoped_refptr<const SecurityOrigin> mutate_security_origin_hook(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin);
+
+  absl::optional<BlinkSchemefulSite> mutate_schemeful_site_hook(
+      const absl::optional<BlinkSchemefulSite>& schemeful_site);
+
+  std::unique_ptr<const ::net::SiteForCookies> mutate_site_for_cookies_hook(
+      const ::net::SiteForCookies& site_for_cookies);
+
+  std::unique_ptr<const BlinkStorageKey> mutate_storage_key_hook(
+      const BlinkStorageKey& storage_key);
+
+  std::unique_ptr<const ::url::Origin> mutate_origin_hook(
+      const ::url::Origin& origin);
+
+ private:
+  IPCFuzzerCore();
+  friend struct ::base::DefaultSingletonTraits<IPCFuzzerCore>;
+
+  MutationStore url_mutation_store_;
+  MutationStore security_origin_mutation_store_;
+  MutationStore schemeful_site_mutation_store_;
+  MutationStore site_for_cookies_mutation_store_;
+  MutationStore storage_key_mutation_store_;
+  UrlStore url_store_;
+
+  base::Lock lock_;
+  absl::optional<BlinkSchemefulSite> locked_site_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_CORE_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation.cc b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.cc
new file mode 100644
index 0000000000000..dc118621c0405
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.cc
@@ -0,0 +1,40 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+
+namespace blink {
+WTF::String Mutation::to_string() const {
+  WTF::String target_str;
+  switch (target_) {
+    case Mutation::TARGET::URL:
+      target_str = "URL";
+      break;
+    case Mutation::TARGET::ORIGIN:
+      target_str = "ORIGIN";
+      break;
+    case Mutation::TARGET::SITE_FOR_COOKIES:
+      target_str = "SITE_FOR_COOKIES";
+      break;
+    case Mutation::TARGET::SCHEMEFUL_SITE:
+      target_str = "SCHEMEFUL_SITE";
+      break;
+    case Mutation::TARGET::STORAGE_KEY:
+      target_str = "STORAGE_KEY";
+      break;
+  }
+
+  WTF::String kind_str;
+  switch (kind_) {
+    case Mutation::KIND::REPLACE_HOST:
+      kind_str = "REPLACE_HOST";
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      kind_str = "REPLACE_WHOLE";
+      break;
+  }
+
+  WTF::String result = WTF::String("{'target':'") + target_str +
+                       WTF::String("', 'kind':'") + kind_str +
+                       WTF::String("', 'url':'") + url_.GetString() + WTF::String("'}");
+  return result;
+}
+
+}  // namespace ipc_fuzzer
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation.h b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.h
new file mode 100644
index 0000000000000..9a8b654bb7077
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.h
@@ -0,0 +1,41 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_H_
+
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+
+namespace blink {
+
+class Mutation {
+ public:
+
+  enum class TARGET {
+    URL,
+    ORIGIN,
+    SITE_FOR_COOKIES,
+    SCHEMEFUL_SITE,
+    STORAGE_KEY,
+  };
+
+  enum class KIND {
+    REPLACE_HOST,
+    REPLACE_WHOLE,
+  };
+
+  Mutation(TARGET target, KIND kind, KURL url)
+      : target_(target), kind_(kind), url_(url) {}
+
+  const TARGET& get_target() const {return target_;}
+  const KIND& get_kind() const { return kind_; }
+  const KURL& get_url() const { return url_; }
+  WTF::String to_string() const;
+
+ private:
+  TARGET target_;
+  KIND kind_;
+  KURL url_;
+};
+}  // namespace ipc_fuzzer
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.cc b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.cc
new file mode 100644
index 0000000000000..34836b94b3e09
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.cc
@@ -0,0 +1,73 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h"
+#include "base/logging.h"
+
+namespace blink {
+MutationStore::MutationStore() = default;
+MutationStore::~MutationStore() = default;
+
+void MutationStore::enqueue(Mutation::TARGET target,
+                            Mutation::KIND kind,
+                            WTF::String url) {
+  ::blink::KURL parsed_url(url);
+  std::unique_ptr<Mutation> mutation =
+      std::make_unique<Mutation>(target, kind, std::move(parsed_url));
+  DLOG(INFO) << "IPCFuzzer enqueue mutation: " << mutation->to_string();
+
+  lock_.Acquire();
+  mutations_.push_back(std::move(mutation));
+  lock_.Release();
+}
+
+void MutationStore::enqueue(Mutation mutation) {
+  DLOG(INFO) << "IPCFuzzer enqueue mutation: " << mutation.to_string();
+  lock_.Acquire();
+  mutations_.emplace_back(std::make_unique<Mutation>(std::move(mutation)));
+  lock_.Release();
+}
+
+std::unique_ptr<Mutation> MutationStore::dequeue_match(
+    const Mutation::TARGET& target) {
+  lock_.Acquire();
+  if (mutations_.size() == 0) {
+    lock_.Release();
+    return nullptr;
+  }
+
+  if (mutations_.at(0)->get_target() == target) {
+    std::unique_ptr<Mutation> mutation = std::move(mutations_.at(0));
+    mutations_.EraseAt(0);
+    lock_.Release();
+    return mutation;
+  }
+  lock_.Release();
+  return nullptr;
+}
+
+std::unique_ptr<Mutation> MutationStore::dequeue() {
+  lock_.Acquire();
+  if (mutations_.size() == 0) {
+    lock_.Release();
+    return nullptr;
+  }
+
+  std::unique_ptr<Mutation> mutation = std::move(mutations_.at(0));
+  mutations_.EraseAt(0);
+  lock_.Release();
+  return mutation;
+}
+
+WTF::String MutationStore::to_string() {
+  WTF::String result = "[";
+  lock_.Acquire();
+  for (const auto& m : mutations_) {
+    result = result + m->to_string();
+    if (&m != &mutations_.back()) {
+      result = result + ",";
+    }
+  }
+  lock_.Release();
+  result = result + "]";
+  return result;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h
new file mode 100644
index 0000000000000..104c757b6094b
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h
@@ -0,0 +1,28 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_STORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_STORE_H_
+
+#include <memory>
+#include "base/synchronization/lock.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+
+namespace blink {
+class MutationStore {
+ public:
+  MutationStore();
+  ~MutationStore();
+
+  void enqueue(Mutation::TARGET target, Mutation::KIND kind, WTF::String url);
+  void enqueue(Mutation mutation);
+
+  std::unique_ptr<Mutation> dequeue_match(const Mutation::TARGET& target);
+  std::unique_ptr<Mutation> dequeue();
+  WTF::String to_string();
+
+ private:
+  base::Lock lock_;
+  WTF::Vector<std::unique_ptr<Mutation>> mutations_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_STORE_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutator.cc b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.cc
new file mode 100644
index 0000000000000..561bdf8c3b3da
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.cc
@@ -0,0 +1,312 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutator.h"
+#include "base/logging.h"
+#include "url/gurl.h"
+
+namespace blink {
+
+std::unique_ptr<const KURL> Mutator::mutate_url(const KURL& url,
+                                                const Mutation& mutation) {
+  std::unique_ptr<const KURL> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated = url_replace_host(url, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = std::make_unique<const KURL>(mutation.get_url());
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: KURL " << *mutated;
+  // }
+  return mutated;
+}
+
+// return scoped_refptr because that is used by all Mojo functions
+::scoped_refptr<const SecurityOrigin> Mutator::mutate_security_origin(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin,
+    const Mutation& mutation) {
+  ::scoped_refptr<const SecurityOrigin> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated =
+          security_origin_replace_host(security_origin, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = SecurityOrigin::CreateWithReferenceOrigin(mutation.get_url(),
+                                                          nullptr);
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: SecurityOrigin " <<
+  //   mutated->ToString();
+  // }
+  return mutated;
+}
+
+// return optional because that is used by all Mojo functions
+absl::optional<BlinkSchemefulSite> Mutator::mutate_schemeful_site(
+    const absl::optional<BlinkSchemefulSite>& schemeful_site,
+    const Mutation& mutation) {
+  absl::optional<BlinkSchemefulSite> mutated = absl::nullopt;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated = schemeful_site_replace_host(schemeful_site, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE: {
+      auto security_origin = SecurityOrigin::CreateWithReferenceOrigin(
+          mutation.get_url(), nullptr);
+      mutated = BlinkSchemefulSite(security_origin);
+    } break;
+  }
+  // if (mutated.has_value()) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: BlinkSchemefulSite "
+  //              << mutated.value().GetDebugString();
+  // }
+  return mutated;
+}
+
+std::unique_ptr<const ::net::SiteForCookies> Mutator::mutate_site_for_cookies(
+    const ::net::SiteForCookies& site_for_cookies,
+    const Mutation& mutation) {
+  std::unique_ptr<const ::net::SiteForCookies> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated =
+          site_for_cookies_replace_host(site_for_cookies, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = std::make_unique<const ::net::SiteForCookies>(
+          ::net::SiteForCookies::FromUrl(GURL(mutation.get_url())));
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: SiteForCookies "
+  //              << mutated->ToDebugString();
+  // }
+  return mutated;
+}
+
+// TODO: implement more different mutations
+std::unique_ptr<const BlinkStorageKey> Mutator::mutate_storage_key(
+    const BlinkStorageKey& storage_key,
+    const Mutation& mutation) {
+  std::unique_ptr<const BlinkStorageKey> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated = storage_key_replace_host(storage_key, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = create_storage_key(mutation.get_url());
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: BlinkStorageKey "
+  //              << mutated->ToDebugString();
+  // }
+  return mutated;
+}
+
+// private helper functions
+
+std::unique_ptr<KURL> Mutator::url_replace_host(const KURL& url,
+                                                const KURL& replacement) {
+  if (!can_replace_host(url)) {
+    return url_replace_inner_host(url, replacement);
+  }
+
+  std::unique_ptr<KURL> new_url = std::make_unique<KURL>(url);
+  new_url->SetHost(replacement.Host());
+  if (replacement.HasPort()) {
+    new_url->SetPort(replacement.Port());
+  } else {
+    new_url->RemovePort();
+  }
+  return new_url;
+}
+
+std::unique_ptr<KURL> Mutator::url_replace_inner_host(const KURL& url,
+                                                      const KURL& replacement) {
+  if (!can_replace_inner_host(url)) {
+    return nullptr;
+  }
+
+  WTF::String protocol;
+  if (url.ProtocolIs("blob")) {
+    protocol = "blob:";
+  } else if (url.ProtocolIs("filesystem")) {
+    protocol = "filesystem:";
+  }
+
+  WTF::String url_str = url.GetString();
+  url_str.Replace(protocol, "");
+
+  KURL inner_url(url_str);
+
+  // if (inner_url.IsNull() || inner_url.IsEmpty()) {
+  //   DLOG(INFO) << "IPCFuzzer mutating inner url failed";
+  //   return nullptr;
+  // }
+
+  inner_url.SetHost(replacement.Host());
+  if (replacement.HasPort()) {
+    inner_url.SetPort(replacement.Port());
+  } else {
+    inner_url.RemovePort();
+  }
+  std::unique_ptr<KURL> new_url =
+      std::make_unique<KURL>(protocol + inner_url.GetString());
+  return new_url;
+}
+
+::scoped_refptr<const SecurityOrigin> Mutator::security_origin_replace_host(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin,
+    const KURL& replacement) {
+  if (!can_replace_host(security_origin)) {
+    return nullptr;
+  }
+  KURL url(security_origin->ToString());
+
+  std::unique_ptr<blink::KURL> new_url = url_replace_host(url, replacement);
+  if (new_url == nullptr) {
+    // replacing host failed
+    return nullptr;
+  }
+
+  return SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+}
+
+absl::optional<BlinkSchemefulSite> Mutator::schemeful_site_replace_host(
+    const absl::optional<BlinkSchemefulSite>& schemeful_site,
+    const KURL& replacement) {
+  if (!can_replace_host(schemeful_site)) {
+    return absl::nullopt;
+  }
+
+  String schemeful_site_str = schemeful_site.value().Serialize();
+
+  std::unique_ptr<KURL> new_url =
+      url_replace_host(KURL(schemeful_site_str), replacement);
+  if (new_url == nullptr) {
+    return absl::nullopt;
+  }
+
+  auto origin = SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+  return BlinkSchemefulSite(origin);
+}
+
+std::unique_ptr<::net::SiteForCookies> Mutator::site_for_cookies_replace_host(
+    const ::net::SiteForCookies& site_for_cookies,
+    const KURL& replacement) {
+  if (!can_replace_host(site_for_cookies)) {
+    return nullptr;
+  }
+
+  GURL url = site_for_cookies.RepresentativeUrl();
+  std::unique_ptr<KURL> new_url = url_replace_host(KURL(url), replacement);
+  if (new_url == nullptr) {
+    return nullptr;
+  }
+
+  return std::make_unique<::net::SiteForCookies>(
+      ::net::SiteForCookies::FromUrl(GURL(*new_url)));
+}
+
+std::unique_ptr<BlinkStorageKey> Mutator::storage_key_replace_host(
+    const BlinkStorageKey& storage_key,
+    const KURL& replacement) {
+  auto security_origin = storage_key.GetSecurityOrigin();
+  ::scoped_refptr<const SecurityOrigin> new_security_origin =
+      security_origin_replace_host(security_origin, replacement);
+  if (new_security_origin == nullptr) {
+    return nullptr;
+  }
+
+  // if the storage key has a nonce, just replace the host and reuse the
+  // nonce
+  // QUESTION: is this right??
+  auto token = storage_key.GetNonce();
+  if (token.has_value()) {
+    return std::make_unique<BlinkStorageKey>(
+        BlinkStorageKey::CreateWithNonce(new_security_origin, token.value()));
+  }
+
+  auto schemeful_site = storage_key.GetTopLevelSite();
+  absl::optional<BlinkSchemefulSite> new_schemeful_site =
+      schemeful_site_replace_host(schemeful_site, replacement);
+  if (new_schemeful_site.has_value()) {
+    return std::make_unique<BlinkStorageKey>(new_security_origin,
+                                             new_schemeful_site.value());
+  }
+
+  return std::make_unique<BlinkStorageKey>(new_security_origin);
+}
+
+std::unique_ptr<BlinkStorageKey> Mutator::create_storage_key(const KURL& url) {
+  auto security_origin =
+      SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+  return std::make_unique<BlinkStorageKey>(security_origin);
+}
+
+// std::unique_ptr<BlinkStorageKey> Mutator::create_storage_key(
+//     const KURL& url,
+//     mojom::AncestorChainBit ancestor_chain_bit) {
+//   auto security_origin =
+//       SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+//   auto schemeful_site = BlinkSchemefulSite(security_origin);
+//   return std::make_unique<BlinkStorageKey>(
+//       BlinkStorageKey::Create(security_origin, schemeful_site,
+//                                        ancestor_chain_bit));
+// }
+
+bool Mutator::can_replace_host(const KURL& url) {
+  if (url.IsNull()) {
+    // DLOG(INFO) << "IPCFuzzer KURL is null";
+    return false;
+  }
+  if (url.IsEmpty()) {
+    // DLOG(INFO) << "IPCFuzzer KURL is empty";
+    return false;
+  }
+  if (!url.CanSetHostOrPort() || url.ProtocolIs("blob") ||
+      url.ProtocolIs("filesystem")) {
+    return false;
+  }
+  return true;
+}
+
+bool Mutator::can_replace_inner_host(const KURL& url) {
+  if (url.ProtocolIs("blob") || url.ProtocolIs("filesystem")) {
+    return true;
+  }
+  return false;
+}
+
+bool Mutator::can_replace_host(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+  if (security_origin == nullptr || security_origin->IsOpaque()) {
+    return false;
+  }
+  return true;
+}
+
+bool Mutator::can_replace_host(
+    const absl::optional<BlinkSchemefulSite>& schemeful_site) {
+  if (!schemeful_site.has_value()) {
+    return false;
+  }
+  if (schemeful_site.value().Serialize() == "null") {
+    return false;
+  }
+  return true;
+}
+
+bool Mutator::can_replace_host(const ::net::SiteForCookies& site_for_cookies) {
+  if (site_for_cookies.IsNull()) {
+    return false;
+  }
+  return true;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutator.h b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.h
new file mode 100644
index 0000000000000..58befb3e32c38
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.h
@@ -0,0 +1,83 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
+
+#include <memory>
+#include "net/cookies/site_for_cookies.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+#include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+#include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+namespace blink {
+class Mutator {
+ public:
+  static std::unique_ptr<const KURL> mutate_url(
+      const KURL& url,
+      const Mutation& mutation);
+
+  // return scoped_refptr because that is used by all Mojo functions
+  static ::scoped_refptr<const SecurityOrigin> mutate_security_origin(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin,
+      const Mutation& mutation);
+
+  // return optional because that is used by all Mojo functions
+  static absl::optional<BlinkSchemefulSite> mutate_schemeful_site(
+      const absl::optional<BlinkSchemefulSite>& schemeful_site,
+      const Mutation& mutation);
+
+  static std::unique_ptr<const ::net::SiteForCookies> mutate_site_for_cookies(
+      const ::net::SiteForCookies& site_for_cookies,
+      const Mutation& mutation);
+
+  static std::unique_ptr<const BlinkStorageKey> mutate_storage_key(
+      const BlinkStorageKey& storage_key,
+      const Mutation& mutation);
+
+ private:
+  static std::unique_ptr<KURL> url_replace_host(
+      const KURL& url,
+      const KURL& replacement);
+
+  static std::unique_ptr<KURL> url_replace_inner_host(
+      const KURL& url,
+      const KURL& replacement);
+
+  static ::scoped_refptr<const SecurityOrigin>
+  security_origin_replace_host(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin,
+      const KURL& replacement);
+
+  static absl::optional<BlinkSchemefulSite>
+  schemeful_site_replace_host(
+      const absl::optional<BlinkSchemefulSite>& schemeful_site,
+      const KURL& replacement);
+
+  static std::unique_ptr<::net::SiteForCookies> site_for_cookies_replace_host(
+      const ::net::SiteForCookies& site_for_cookies,
+      const KURL& replacement);
+
+  static std::unique_ptr<BlinkStorageKey> storage_key_replace_host(
+      const BlinkStorageKey& storage_key,
+      const KURL& replacement);
+
+  static std::unique_ptr<BlinkStorageKey> create_storage_key(
+      const KURL& url);
+//   static std::unique_ptr<BlinkStorageKey> create_storage_key(
+//       const KURL& url,
+//       mojom::AncestorChainBit ancestor_chain_bit);
+
+  static bool can_replace_host(const KURL& url);
+  static bool can_replace_inner_host(const KURL& url);
+  static bool can_replace_host(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin);
+  static bool can_replace_host(
+      const absl::optional<BlinkSchemefulSite>& schemeful_site);
+  static bool can_replace_host(const ::net::SiteForCookies& site_for_cookies);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc
new file mode 100644
index 0000000000000..fbd1d14cfce87
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc
@@ -0,0 +1,26 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/url_store.h"
+#include "base/logging.h"
+
+namespace blink {
+UrlStore::UrlStore() = default;
+UrlStore::~UrlStore() = default;
+
+void UrlStore::store(const KURL& url) {
+  if (url.IsNull()) {
+    return;
+  }
+
+  lock_.Acquire();
+  WTF::String s = url.GetString();
+  urls_.insert(s);
+  lock_.Release();
+}
+
+WTF::Vector<WTF::String> UrlStore::get() {
+  lock_.Acquire();
+  WTF::Vector<WTF::String> result; // urls_
+  lock_.Release();
+  return result;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h
new file mode 100644
index 0000000000000..2763393112f83
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h
@@ -0,0 +1,26 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
+
+#include <memory>
+#include "base/synchronization/lock.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/hash_set.h"
+
+namespace blink {
+class UrlStore {
+ public:
+  UrlStore();
+  ~UrlStore();
+
+  void store(const KURL& url);
+  WTF::Vector<WTF::String> get();
+
+ private:
+  base::Lock lock_;
+  WTF::HashSet<WTF::String> urls_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
diff --git a/third_party/blink/renderer/platform/exported/web_security_origin.cc b/third_party/blink/renderer/platform/exported/web_security_origin.cc
index f2d133dffd476..58834b1594d3e 100644
--- a/third_party/blink/renderer/platform/exported/web_security_origin.cc
+++ b/third_party/blink/renderer/platform/exported/web_security_origin.cc
@@ -35,6 +35,8 @@
 #include "third_party/blink/renderer/platform/weborigin/kurl.h"
 #include "third_party/blink/renderer/platform/weborigin/security_origin.h"
 
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+
 namespace blink {
 
 WebSecurityOrigin WebSecurityOrigin::CreateFromString(const WebString& origin) {
@@ -74,22 +76,38 @@ bool WebSecurityOrigin::IsOpaque() const {
 }
 
 bool WebSecurityOrigin::CanAccess(const WebSecurityOrigin& other) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   DCHECK(other.private_);
   return private_->CanAccess(other.private_.Get());
 }
 
 bool WebSecurityOrigin::CanRequest(const WebURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanRequest(url);
 }
 
 bool WebSecurityOrigin::CanDisplay(const WebURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanDisplay(url);
 }
 
 bool WebSecurityOrigin::IsPotentiallyTrustworthy() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->IsPotentiallyTrustworthy();
 }
@@ -100,6 +118,10 @@ WebString WebSecurityOrigin::ToString() const {
 }
 
 bool WebSecurityOrigin::CanAccessPasswordManager() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanAccessPasswordManager();
 }
diff --git a/third_party/blink/renderer/platform/weborigin/security_origin.cc b/third_party/blink/renderer/platform/weborigin/security_origin.cc
index 2db34d308c94d..9a317dc056e43 100644
--- a/third_party/blink/renderer/platform/weborigin/security_origin.cc
+++ b/third_party/blink/renderer/platform/weborigin/security_origin.cc
@@ -53,6 +53,8 @@
 #include "url/url_canon_ip.h"
 #include "url/url_util.h"
 
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+
 namespace blink {
 
 namespace {
@@ -323,6 +325,10 @@ SecurityOrigin::GetNonceForSerialization() const {
 
 bool SecurityOrigin::CanAccess(const SecurityOrigin* other,
                                AccessResultDomainDetail& detail) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_) {
     detail = AccessResultDomainDetail::kDomainNotRelevant;
     return true;
@@ -342,6 +348,10 @@ bool SecurityOrigin::CanAccess(const SecurityOrigin* other,
 }
 
 bool SecurityOrigin::PassesFileCheck(const SecurityOrigin* other) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(IsLocal());
   DCHECK(other->IsLocal());
 
@@ -350,6 +360,10 @@ bool SecurityOrigin::PassesFileCheck(const SecurityOrigin* other) const {
 }
 
 bool SecurityOrigin::CanRequest(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_)
     return true;
 
@@ -388,6 +402,10 @@ bool SecurityOrigin::CanRequest(const KURL& url) const {
 }
 
 bool SecurityOrigin::CanReadContent(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (CanRequest(url))
     return true;
 
@@ -402,6 +420,10 @@ bool SecurityOrigin::CanReadContent(const KURL& url) const {
 }
 
 bool SecurityOrigin::CanDisplay(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_)
     return true;
 
@@ -423,6 +445,10 @@ bool SecurityOrigin::CanDisplay(const KURL& url) const {
 }
 
 bool SecurityOrigin::IsPotentiallyTrustworthy() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   // TODO(https://crbug.com/1153336): The code below can hopefully be eventually
   // deleted and IsOriginPotentiallyTrustworthy can be used instead (from
   // //services/network/public/cpp/is_potentially_trustworthy.h).
