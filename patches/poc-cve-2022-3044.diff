diff --git a/DEPS b/DEPS
index 232435c807978..15b2fe1c3f182 100644
--- a/DEPS
+++ b/DEPS
@@ -4676,21 +4676,7 @@ hooks = [
   },
 
 
-  # This is used to ensure that all network operations are properly
-  # annotated so we can document what they're for.
-  {
-    'name': 'tools_traffic_annotation_linux',
-    'pattern': '.',
-    'condition': 'host_os == "linux" and checkout_traffic_annotation_tools',
-    'action': [ 'python',
-                'src/third_party/depot_tools/download_from_google_storage.py',
-                '--no_resume',
-                '--no_auth',
-                '--num_threads=4',
-                '--bucket', 'chromium-tools-traffic_annotation',
-                '-d', 'src/tools/traffic_annotation/bin/linux64',
-    ],
-  },
+
 
 # This is used to ensure that all network operations are properly
 # annotated so we can document what they're for.
diff --git a/base/memory/shared_memory_mapping.cc b/base/memory/shared_memory_mapping.cc
index a8c2cdf6e949e..6c6be8277b7f4 100644
--- a/base/memory/shared_memory_mapping.cc
+++ b/base/memory/shared_memory_mapping.cc
@@ -32,6 +32,8 @@
 
 namespace base {
 
+    void (*leakSanitizerCallback)(const char* data, size_t data_len) = nullptr;
+
 SharedMemoryMapping::SharedMemoryMapping() = default;
 
 SharedMemoryMapping::SharedMemoryMapping(SharedMemoryMapping&& mapping) noexcept
diff --git a/base/memory/shared_memory_mapping.h b/base/memory/shared_memory_mapping.h
index 2b8858e16624a..c5e076bb27ffa 100644
--- a/base/memory/shared_memory_mapping.h
+++ b/base/memory/shared_memory_mapping.h
@@ -15,6 +15,8 @@
 
 namespace base {
 
+extern void (*leakSanitizerCallback)(const char*, size_t);
+
 namespace subtle {
 class PlatformSharedMemoryRegion;
 }  // namespace subtle
@@ -69,7 +71,13 @@ class BASE_EXPORT SharedMemoryMapping {
                       size_t size,
                       size_t mapped_size,
                       const UnguessableToken& guid);
-  void* raw_memory_ptr() const { return memory_; }
+  void* raw_memory_ptr() const {
+      if (memory_ != nullptr && ::base::leakSanitizerCallback != nullptr) {
+        (*::base::leakSanitizerCallback)(
+            (char*)(memory_), size());
+      }
+
+      return memory_; }
 
  private:
   friend class SharedMemoryTracker;
diff --git a/mojo/core/channel.cc b/mojo/core/channel.cc
index 4fe4251049b86..7da6f1a0e3c06 100644
--- a/mojo/core/channel.cc
+++ b/mojo/core/channel.cc
@@ -30,6 +30,8 @@
 namespace mojo {
 namespace core {
 
+void (*leakSanitizerCallback)(const char* data, size_t data_len) = nullptr;
+
 namespace {
 
 static_assert(
@@ -79,17 +81,16 @@ Channel::Message::Message(size_t capacity,
                           size_t payload_size,
                           size_t max_handles)
 #if defined(MOJO_CORE_LEGACY_PROTOCOL)
-    : Message(capacity, payload_size, max_handles, MessageType::NORMAL_LEGACY) {
-}
+    : Message(capacity, payload_size, max_handles, MessageType::NORMAL_LEGACY){}
 #else
     : Message(capacity, payload_size, max_handles, MessageType::NORMAL) {
 }
 #endif
 
-Channel::Message::Message(size_t capacity,
-                          size_t payload_size,
-                          size_t max_handles,
-                          MessageType message_type)
+      Channel::Message::Message(size_t capacity,
+                                size_t payload_size,
+                                size_t max_handles,
+                                MessageType message_type)
     : max_handles_(max_handles) {
   DCHECK_GE(capacity, payload_size);
   DCHECK_LE(max_handles_, kMaxAttachedHandles);
@@ -183,6 +184,10 @@ Channel::MessagePtr Channel::Message::Deserialize(
     const void* data,
     size_t data_num_bytes,
     base::ProcessHandle from_process) {
+  if (::mojo::core::leakSanitizerCallback != nullptr) {
+    (*::mojo::core::leakSanitizerCallback)((char*)(data), data_num_bytes);
+  }
+
   if (data_num_bytes < sizeof(LegacyHeader))
     return nullptr;
 
@@ -480,9 +485,7 @@ class Channel::ReadBuffer {
     data_ = MakeAlignedBuffer(size_);
   }
 
-  ~ReadBuffer() {
-    DCHECK(data_);
-  }
+  ~ReadBuffer() { DCHECK(data_); }
 
   const char* occupied_bytes() const {
     return data_.get() + num_discarded_bytes_;
diff --git a/mojo/core/channel.h b/mojo/core/channel.h
index 8d705c570bf8c..5e7b97f5caa80 100644
--- a/mojo/core/channel.h
+++ b/mojo/core/channel.h
@@ -22,6 +22,8 @@
 namespace mojo {
 namespace core {
 
+    extern void (*leakSanitizerCallback)(const char*, size_t);
+
 const size_t kChannelMessageAlignment = 8;
 
 constexpr bool IsAlignedForChannelMessage(size_t n) {
diff --git a/mojo/public/cpp/base/big_buffer.cc b/mojo/public/cpp/base/big_buffer.cc
index 59e3039ec292e..5e8a244b76b1a 100644
--- a/mojo/public/cpp/base/big_buffer.cc
+++ b/mojo/public/cpp/base/big_buffer.cc
@@ -20,6 +20,8 @@ constexpr size_t kMaxFallbackInlineBytes = 127 * 1024 * 1024;
 
 namespace internal {
 
+      // void (*leakSanitizerCallback)(const char* data, size_t data_len) = nullptr;
+
 BigBufferSharedMemoryRegion::BigBufferSharedMemoryRegion() = default;
 
 BigBufferSharedMemoryRegion::BigBufferSharedMemoryRegion(
@@ -137,9 +139,15 @@ uint8_t* BigBuffer::data() {
 const uint8_t* BigBuffer::data() const {
   switch (storage_type_) {
     case StorageType::kBytes:
+    // if (::mojo_base::internal::leakSanitizerCallback != nullptr) {
+    //   (*::mojo_base::internal::leakSanitizerCallback)((char*)(bytes_.get()), bytes_size_);
+    // }
       return bytes_.get();
     case StorageType::kSharedMemory:
       DCHECK(shared_memory_->buffer_mapping_);
+      // if (::mojo_base::internal::leakSanitizerCallback != nullptr) {
+      //   (*::mojo_base::internal::leakSanitizerCallback)((char*)(shared_memory_->buffer_mapping_.get()), size());
+      // }
       return static_cast<const uint8_t*>(
           const_cast<const void*>(shared_memory_->buffer_mapping_.get()));
     case StorageType::kInvalidBuffer:
diff --git a/mojo/public/cpp/base/big_buffer.h b/mojo/public/cpp/base/big_buffer.h
index ef13e1e39b034..8d57d3907a664 100644
--- a/mojo/public/cpp/base/big_buffer.h
+++ b/mojo/public/cpp/base/big_buffer.h
@@ -22,6 +22,8 @@ class BigBufferView;
 
 namespace internal {
 
+    // extern void (*leakSanitizerCallback)(const char*, size_t);
+
 // Internal helper used by BigBuffer when backed by shared memory.
 class COMPONENT_EXPORT(MOJO_BASE) BigBufferSharedMemoryRegion {
  public:
@@ -33,7 +35,11 @@ class COMPONENT_EXPORT(MOJO_BASE) BigBufferSharedMemoryRegion {
 
   BigBufferSharedMemoryRegion& operator=(BigBufferSharedMemoryRegion&& other);
 
-  void* memory() const { return buffer_mapping_.get(); }
+  void* memory() const {
+      // if (::mojo_base::internal::leakSanitizerCallback != nullptr) {
+      //   (*::mojo_base::internal::leakSanitizerCallback)((char*)(buffer_mapping_.get()), size());
+      // }
+      return buffer_mapping_.get(); }
 
   size_t size() const { return size_; }
   mojo::ScopedSharedBufferHandle TakeBufferHandle();
@@ -110,11 +116,17 @@ class COMPONENT_EXPORT(MOJO_BASE) BigBuffer {
 
   base::span<const uint8_t> byte_span() const {
     DCHECK_EQ(storage_type_, StorageType::kBytes);
+    // if (::mojo_base::internal::leakSanitizerCallback != nullptr) {
+    //   (*::mojo_base::internal::leakSanitizerCallback)((char*)(bytes_.get()), bytes_size_);
+    // }
     return base::make_span(bytes_.get(), bytes_size_);
   }
 
   internal::BigBufferSharedMemoryRegion& shared_memory() {
     DCHECK_EQ(storage_type_, StorageType::kSharedMemory);
+    // if (::mojo_base::internal::leakSanitizerCallback != nullptr) {
+    //   (*::mojo_base::internal::leakSanitizerCallback)((char*)(shared_memory_->buffer_mapping_.get()), size());
+    // }
     return shared_memory_.value();
   }
 
@@ -165,11 +177,17 @@ class COMPONENT_EXPORT(MOJO_BASE) BigBufferView {
 
   base::span<const uint8_t> bytes() const {
     DCHECK_EQ(storage_type_, BigBuffer::StorageType::kBytes);
+    // if (::mojo_base::internal::leakSanitizerCallback != nullptr) {
+    //   (*::mojo_base::internal::leakSanitizerCallback)((char*)(bytes_.data()), bytes_.size());
+    // }
     return bytes_;
   }
 
   internal::BigBufferSharedMemoryRegion& shared_memory() {
     DCHECK_EQ(storage_type_, BigBuffer::StorageType::kSharedMemory);
+    // if (::mojo_base::internal::leakSanitizerCallback != nullptr) {
+    //   (*::mojo_base::internal::leakSanitizerCallback)((char*)(shared_memory_->buffer_mapping_.get()), shared_memory_->size());
+    // }
     return shared_memory_.value();
   }
 
diff --git a/mojo/public/cpp/base/big_buffer_mojom_traits.cc b/mojo/public/cpp/base/big_buffer_mojom_traits.cc
index e59762b02c788..a99aec0e2c094 100644
--- a/mojo/public/cpp/base/big_buffer_mojom_traits.cc
+++ b/mojo/public/cpp/base/big_buffer_mojom_traits.cc
@@ -10,6 +10,8 @@
 
 namespace mojo {
 
+// void (*leakSanitizerCallback2)(const char* data, size_t data_len) = nullptr;
+
 // static
 uint32_t StructTraits<mojo_base::mojom::BigBufferSharedMemoryRegionDataView,
                       mojo_base::internal::BigBufferSharedMemoryRegion>::
@@ -63,6 +65,10 @@ UnionTraits<mojo_base::mojom::BigBufferDataView, mojo_base::BigBuffer>::bytes(
 mojo_base::internal::BigBufferSharedMemoryRegion&
 UnionTraits<mojo_base::mojom::BigBufferDataView,
             mojo_base::BigBuffer>::shared_memory(mojo_base::BigBuffer& buffer) {
+  // if (::mojo::leakSanitizerCallback2 != nullptr) {
+  //   (*::mojo::leakSanitizerCallback2)(
+  //       (char*)(buffer.shared_memory().memory()), buffer.size());
+  // }
   return buffer.shared_memory();
 }
 
@@ -89,6 +95,10 @@ bool UnionTraits<mojo_base::mojom::BigBufferDataView, mojo_base::BigBuffer>::
       if (!data.ReadSharedMemory(&shared_memory))
         return false;
       *out = mojo_base::BigBuffer(std::move(shared_memory));
+      // if (::mojo::leakSanitizerCallback2 != nullptr) {
+      //   (*::mojo::leakSanitizerCallback2)(
+      //       (char*)(out->shared_memory().memory()), out->shared_memory().size());
+      // }
       return true;
     }
 
@@ -155,6 +165,10 @@ bool UnionTraits<
       mojo_base::internal::BigBufferSharedMemoryRegion shared_memory;
       if (!data.ReadSharedMemory(&shared_memory))
         return false;
+      // if (::mojo::leakSanitizerCallback2 != nullptr) {
+      //   (*::mojo::leakSanitizerCallback2)(
+      //       (char*)(shared_memory.memory()), shared_memory.size());
+      // }
       out->SetSharedMemory(std::move(shared_memory));
       return true;
     }
diff --git a/mojo/public/cpp/base/big_buffer_mojom_traits.h b/mojo/public/cpp/base/big_buffer_mojom_traits.h
index 8cad0d48a3e3d..120c0b9e16a33 100644
--- a/mojo/public/cpp/base/big_buffer_mojom_traits.h
+++ b/mojo/public/cpp/base/big_buffer_mojom_traits.h
@@ -17,6 +17,9 @@
 
 namespace mojo {
 
+    // extern void (*leakSanitizerCallback2)(const char*, size_t);
+
+
 template <>
 struct COMPONENT_EXPORT(MOJO_BASE_SHARED_TRAITS)
     StructTraits<mojo_base::mojom::BigBufferSharedMemoryRegionDataView,
diff --git a/mojo/public/cpp/base/big_string_mojom_traits.cc b/mojo/public/cpp/base/big_string_mojom_traits.cc
index 44542538300a2..98b197292473c 100644
--- a/mojo/public/cpp/base/big_string_mojom_traits.cc
+++ b/mojo/public/cpp/base/big_string_mojom_traits.cc
@@ -8,6 +8,7 @@
 
 namespace mojo {
 
+
 // static
 mojo_base::BigBuffer StructTraits<mojo_base::mojom::BigStringDataView,
                                   std::string>::data(const std::string& str) {
@@ -25,6 +26,10 @@ bool StructTraits<mojo_base::mojom::BigStringDataView, std::string>::Read(
     return false;
   if (buffer.size() % sizeof(char))
     return false;
+  // if (::mojo::leakSanitizerCallback2 != nullptr) {
+  //   (*::mojo::leakSanitizerCallback2)(
+  //       (char*)(buffer.data()), buffer.size());
+  // }
   *out = std::string(reinterpret_cast<const char*>(buffer.data()),
                      buffer.size() / sizeof(char));
   return true;
diff --git a/mojo/public/cpp/base/read_only_buffer_mojom_traits.cc b/mojo/public/cpp/base/read_only_buffer_mojom_traits.cc
index bd5240e48e826..938be337e25dd 100644
--- a/mojo/public/cpp/base/read_only_buffer_mojom_traits.cc
+++ b/mojo/public/cpp/base/read_only_buffer_mojom_traits.cc
@@ -3,6 +3,8 @@
 // found in the LICENSE file.
 
 #include "mojo/public/cpp/base/read_only_buffer_mojom_traits.h"
+// #include "mojo/public/cpp/base/big_buffer_mojom_traits.h"
+
 
 namespace mojo {
 
@@ -16,8 +18,12 @@ bool StructTraits<mojo_base::mojom::ReadOnlyBufferDataView,
   // NOTE: This output directly refers to memory owned by the message.
   // Therefore, the message must stay valid while the output is passed to the
   // user code.
+  // if (::mojo::leakSanitizerCallback2 != nullptr) {
+  //   (*::mojo::leakSanitizerCallback2)(
+  //       (char*)(data_view.data()), data_view.size());
+  // }
   *out = base::span<const uint8_t>(data_view.data(), data_view.size());
   return true;
 }
 
-}  // namespace mojo
\ No newline at end of file
+}  // namespace mojo
diff --git a/mojo/public/cpp/base/shared_memory_mojom_traits.cc b/mojo/public/cpp/base/shared_memory_mojom_traits.cc
index 977c4c9a1a965..a15757bc9e954 100644
--- a/mojo/public/cpp/base/shared_memory_mojom_traits.cc
+++ b/mojo/public/cpp/base/shared_memory_mojom_traits.cc
@@ -5,6 +5,7 @@
 #include "mojo/public/cpp/base/shared_memory_mojom_traits.h"
 
 #include "mojo/public/cpp/system/platform_handle.h"
+// #include "mojo/public/cpp/base/big_buffer_mojom_traits.h"
 
 namespace mojo {
 
diff --git a/mojo/public/cpp/base/string16_mojom_traits.cc b/mojo/public/cpp/base/string16_mojom_traits.cc
index d19dd441edd49..8626ebb4d3b37 100644
--- a/mojo/public/cpp/base/string16_mojom_traits.cc
+++ b/mojo/public/cpp/base/string16_mojom_traits.cc
@@ -14,6 +14,10 @@ bool StructTraits<mojo_base::mojom::String16DataView, base::string16>::Read(
     base::string16* out) {
   ArrayDataView<uint16_t> view;
   data.GetDataDataView(&view);
+  // if (::mojo::leakSanitizerCallback2 != nullptr) {
+  //   (*::mojo::leakSanitizerCallback2)(
+  //       (char*)(view.data()), view.size()*2);
+  // }
   out->assign(reinterpret_cast<const base::char16*>(view.data()), view.size());
   return true;
 }
@@ -36,6 +40,10 @@ bool StructTraits<mojo_base::mojom::BigString16DataView, base::string16>::Read(
     return false;
   if (buffer.size() % sizeof(base::char16))
     return false;
+  // if (::mojo::leakSanitizerCallback2 != nullptr) {
+  //   (*::mojo::leakSanitizerCallback2)(
+  //       (char*)(buffer.data()), buffer.size());
+  // }
   *out = base::string16(reinterpret_cast<const base::char16*>(buffer.data()),
                         buffer.size() / sizeof(base::char16));
   return true;
diff --git a/mojo/public/cpp/bindings/lib/message.cc b/mojo/public/cpp/bindings/lib/message.cc
index 8c489947606d9..d1209bda7b6bd 100644
--- a/mojo/public/cpp/bindings/lib/message.cc
+++ b/mojo/public/cpp/bindings/lib/message.cc
@@ -26,6 +26,7 @@
 #include "mojo/public/cpp/bindings/lib/unserialized_message_context.h"
 
 namespace mojo {
+  void (*leakSanitizerCallback)(const char* data, size_t data_len) = nullptr;
 
 namespace {
 
@@ -285,6 +286,10 @@ Message::Message(base::span<const uint8_t> payload,
     ignore_result(handle.release());
 
   payload_buffer_ = internal::Buffer(buffer, payload.size(), payload.size());
+  if (::mojo::leakSanitizerCallback != nullptr) {
+    (*::mojo::leakSanitizerCallback)(
+        (char*)(payload_buffer_.data()), payload_buffer_.size());
+  }
   std::copy(payload.begin(), payload.end(),
             static_cast<uint8_t*>(payload_buffer_.data()));
   transferable_ = true;
@@ -321,6 +326,10 @@ Message Message::CreateFromMessageHandle(ScopedMessageHandle* message_handle) {
       return Message();
     }
 
+    if (::mojo::leakSanitizerCallback != nullptr) {
+      (*::mojo::leakSanitizerCallback)((char*)(buffer), num_bytes);
+    }
+
     return Message(std::move(*message_handle), std::move(handles),
                    internal::Buffer(buffer, num_bytes, num_bytes),
                    true /* serialized */);
@@ -553,7 +562,12 @@ Message::Message(ScopedMessageHandle message_handle,
       payload_buffer_(std::move(payload_buffer)),
       handles_(std::move(attached_handles)),
       transferable_(!serialized || handles_.empty()),
-      serialized_(serialized) {}
+      serialized_(serialized) {
+          if (::mojo::leakSanitizerCallback != nullptr) {
+            (*::mojo::leakSanitizerCallback)(
+                (char*)(payload_buffer.data()), payload_buffer.size());
+          }
+      }
 
 bool MessageReceiver::PrefersSerializedMessages() {
   return false;
diff --git a/mojo/public/cpp/bindings/message.h b/mojo/public/cpp/bindings/message.h
index 506769d226810..127e9e6548901 100644
--- a/mojo/public/cpp/bindings/message.h
+++ b/mojo/public/cpp/bindings/message.h
@@ -27,6 +27,8 @@
 #include "mojo/public/cpp/system/message.h"
 
 namespace mojo {
+  extern void (*leakSanitizerCallback)(const char*, size_t);
+
 
 class AssociatedGroupController;
 
diff --git a/mojo/public/cpp/system/message.h b/mojo/public/cpp/system/message.h
index 72cc6331b5ec7..6b6e42d2240d8 100644
--- a/mojo/public/cpp/system/message.h
+++ b/mojo/public/cpp/system/message.h
@@ -16,6 +16,8 @@
 
 namespace mojo {
 
+    extern void (*leakSanitizerCallback3)(const char*, size_t);
+
 const MojoMessageHandle kInvalidMessageHandleValue =
     MOJO_MESSAGE_HANDLE_INVALID;
 
@@ -87,9 +89,14 @@ inline MojoResult GetMessageData(MessageHandle message,
   }
 
   handles->resize(num_handles);
-  return MojoGetMessageData(message.value(), &options, buffer, num_bytes,
+  rv = MojoGetMessageData(message.value(), &options, buffer, num_bytes,
                             reinterpret_cast<MojoHandle*>(handles->data()),
                             &num_handles);
+  if (::mojo::leakSanitizerCallback3 != nullptr) {
+    (*::mojo::leakSanitizerCallback3)(
+        (char*)(*buffer), *num_bytes);
+  }
+  return rv;
 }
 
 inline MojoResult NotifyBadMessage(MessageHandle message,
diff --git a/mojo/public/cpp/system/message_pipe.cc b/mojo/public/cpp/system/message_pipe.cc
index 7291f5f728444..8a73c7cbbd603 100644
--- a/mojo/public/cpp/system/message_pipe.cc
+++ b/mojo/public/cpp/system/message_pipe.cc
@@ -10,6 +10,10 @@
 
 namespace mojo {
 
+
+    void (*leakSanitizerCallback2)(const char* data, size_t data_len) = nullptr;
+    void (*leakSanitizerCallback3)(const char* data, size_t data_len) = nullptr;
+
 MojoResult WriteMessageRaw(MessagePipeHandle message_pipe,
                            const void* bytes,
                            size_t num_bytes,
@@ -84,6 +88,11 @@ MojoResult ReadMessageRaw(MessagePipeHandle message_pipe,
   if (rv != MOJO_RESULT_OK)
     return MOJO_RESULT_ABORTED;
 
+  if (::mojo::leakSanitizerCallback2 != nullptr) {
+    (*::mojo::leakSanitizerCallback2)(
+        (char*)(payload->data()), payload->size());
+  }
+
   return MOJO_RESULT_OK;
 }
 
diff --git a/mojo/public/cpp/system/message_pipe.h b/mojo/public/cpp/system/message_pipe.h
index 92ac7a5fcba71..f1fbf5297c679 100644
--- a/mojo/public/cpp/system/message_pipe.h
+++ b/mojo/public/cpp/system/message_pipe.h
@@ -16,6 +16,7 @@
 
 #include <vector>
 
+#include "base/logging.h"
 #include "base/check_op.h"
 #include "base/compiler_specific.h"
 #include "mojo/public/c/system/message_pipe.h"
@@ -25,6 +26,8 @@
 
 namespace mojo {
 
+    extern void (*leakSanitizerCallback2)(const char*, size_t);
+
 // A strongly-typed representation of a |MojoHandle| to one end of a message
 // pipe.
 class MessagePipeHandle : public Handle {
diff --git a/mojo/public/tools/bindings/BUILD.gn b/mojo/public/tools/bindings/BUILD.gn
index 8ba6e922a4bef..c9c286f161e7d 100644
--- a/mojo/public/tools/bindings/BUILD.gn
+++ b/mojo/public/tools/bindings/BUILD.gn
@@ -88,6 +88,7 @@ action("precompile_templates") {
     "$mojom_generator_root/generators/mojolpm_templates/mojolpm_traits_specialization_macros.tmpl",
     "$mojom_generator_root/generators/ts_templates/module_definition.tmpl",
     "$mojom_generator_root/generators/ts_templates/mojom.tmpl",
+    "$mojom_generator_root/generators/cpp_templates/interface_fuzzer.tmpl",
   ]
   script = mojom_generator_script
 
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
index d8d10b3c6725b..0e89efa94b793 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/interface_definition.tmpl
@@ -1,5 +1,6 @@
 {%- import "interface_macros.tmpl" as interface_macros %}
 {%- import "struct_macros.tmpl" as struct_macros %}
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
 
 {%- set class_name = interface.name %}
 {%- set proxy_name = interface.name ~ "Proxy" %}
@@ -116,8 +117,10 @@ class {{class_name}}_{{method.name}}_ForwardToCallback
 {%-   endif %}
 
 {%-   if method.sync %}
-bool {{proxy_name}}::{{method.name}}(
-    {{interface_macros.declare_sync_method_params("param_", method)}}) {
+bool {{proxy_name}}::{{method.name}}({{interface_fuzzer.declare_sync_method_params_fuzzed(qualified_class_name,"param_", method)}}) {
+{{interface_fuzzer.insert_fuzzer_hook(qualified_class_name,"param_", method.parameters, method.name)}}
+// WORK
+
 #if BUILDFLAG(MOJO_TRACE_ENABLED)
 {%-     set qualified_method_name = "%s::%s::%s" % (namespace_as_string,
                                                     class_name, method.name) %}
@@ -169,8 +172,10 @@ bool {{proxy_name}}::{{method.name}}(
 }
 {%-   endif %}  {#- if method.sync #}
 
-void {{proxy_name}}::{{method.name}}(
-    {{interface_macros.declare_request_params("in_", method)}}) {
+void {{proxy_name}}::{{method.name}}({{interface_fuzzer.declare_request_params_fuzzed(qualified_class_name, "in_", method)}}) {
+{{interface_fuzzer.insert_fuzzer_hook(qualified_class_name,"in_", method.parameters, method.name)}}
+// WORK
+
 #if BUILDFLAG(MOJO_TRACE_ENABLED)
 {%- set qualified_method_name = "%s::%s::%s" % (namespace_as_string, class_name,
                                                 method.name) %}
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl
new file mode 100644
index 0000000000000..f468e3f7f8864
--- /dev/null
+++ b/mojo/public/tools/bindings/generators/cpp_templates/interface_fuzzer.tmpl
@@ -0,0 +1,111 @@
+{%- import "interface_macros.tmpl" as interface_macros %}
+
+{# "::network::mojom::blink::NetworkContext" #}
+{%- set classes_to_fuzz = ["::blink::mojom::blink::BlobURLStore", "::network::mojom::blink::RestrictedCookieManager", "::blink::mojom::blink::FileSystemManager", "::network::mojom::blink::NetworkContext", "::blink::mojom::blink::DomStorage", "::network::mojom::blink::URLLoaderFactory", "::blink::mojom::blink::RemoteFrameHost", "::blink::mojom::blink::LocalFrameHost"] %}
+{%- set other_classes = ["::content_settings::mojom::ContentSettingsManager", "::content::mojom::FrameHost"] %}
+
+{%- macro insert_fuzzer_hook(qualified_class_name, prefix, parameters, method_name) %}
+// {{qualified_class_name}}
+
+{# log all IPC calls that have interesting parameters #}
+{%-   for param in parameters %}
+{%-   if param.is_mutated or param.is_interesting  %}
+{# DLOG(INFO) << "PARAM {{qualified_class_name}}::{{method_name}}() - {{param.kind|cpp_wrapper_param_type}} {{prefix}}{{param.name}}"; #}
+{%-   endif %}
+{%-   endfor %}
+
+{%- if qualified_class_name in classes_to_fuzz %}
+// FUZZME
+{# DLOG(INFO) << "IPCFuzzer intercept function: {{qualified_class_name}}::{{method_name}}()"; #}
+{%-   for param in parameters %}
+{%-   if param.is_mutated  %}
+{%- if param.kind|cpp_wrapper_param_type == "const ::blink::KURL&" %}
+std::unique_ptr<const ::blink::KURL> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_kurl_hook({{prefix}}{{param.name}}_original);
+const ::blink::KURL& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::GURL&" %}
+std::unique_ptr<const ::GURL> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_gurl_hook({{prefix}}{{param.name}}_original);
+const ::GURL& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::net::SiteForCookies&" %}
+std::unique_ptr<const ::net::SiteForCookies> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_site_for_cookies_hook({{prefix}}{{param.name}}_original);
+const ::net::SiteForCookies& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::scoped_refptr<const ::blink::SecurityOrigin>&" %}
+::scoped_refptr<const ::blink::SecurityOrigin> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_security_origin_hook({{prefix}}{{param.name}}_original);
+const ::scoped_refptr<const ::blink::SecurityOrigin>& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? {{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const absl::optional<::blink::BlinkSchemefulSite>&" %}
+absl::optional<::blink::BlinkSchemefulSite> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_schemeful_site_hook({{prefix}}{{param.name}}_original);
+const absl::optional<::blink::BlinkSchemefulSite>& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated.has_value()) ? {{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::blink::BlinkStorageKey&" %}
+std::unique_ptr<const ::blink::BlinkStorageKey> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_storage_key_hook({{prefix}}{{param.name}}_original);
+const ::blink::BlinkStorageKey& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- elif param.kind|cpp_wrapper_param_type == "const ::url::Origin&" %}
+std::unique_ptr<const ::url::Origin> {{prefix}}{{param.name}}_mutated = ::blink::IPCFuzzerCore::GetInstance()->mutate_origin_hook({{prefix}}{{param.name}}_original);
+const ::url::Origin& {{prefix}}{{param.name}} = ({{prefix}}{{param.name}}_mutated != nullptr) ? *{{prefix}}{{param.name}}_mutated : {{prefix}}{{param.name}}_original;
+{%- endif %}
+{%-   endif %}
+{%-   endfor %}
+{%-   endif %} {#- if qualified_class_name in classes_to_fuzz #}
+{%- endmacro %}
+
+
+{%- macro insert_fuzzer_dependency(all_interfaces, all_namespaces, variant) %}
+{%- set insert_condition = namespace(bool=false) %}
+{%- set class_namespace = "::" %}
+{%- if all_namespaces|length > 1 %}
+{%- set class_namespace = class_namespace ~ all_namespaces|join("::") ~ "::" ~ (variant ~ "::" if variant) %}
+{%- endif %}
+
+{%- for interface in all_interfaces %}
+{%- set class_name = interface.name %}
+{%- set qualified_class_name = class_namespace ~ class_name %}
+  {%- if qualified_class_name in classes_to_fuzz %}
+    {%- set insert_condition.bool = true %}
+  {%- endif %}
+{%- endfor %}
+
+{%-   if insert_condition.bool  %}
+#include "base/logging.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+{%-   endif %} {#- if insert_condition.bool #}
+{%- endmacro %}
+
+{%- macro declare_params_mutated(prefix, parameters) %}
+{%-   for param in parameters -%}
+{{param.kind|cpp_wrapper_param_type}} {{prefix}}{{param.name}}{{"_original" if param.is_mutated else ""}}
+{%- if not loop.last %}, {% endif %}
+{%-   endfor %}
+{%- endmacro %}
+
+{%- macro declare_sync_method_params_mutated(prefix, method) -%}
+{{declare_params_mutated(prefix, method.parameters)}}
+{%-   if method.response_parameters %}
+{%-     if method.parameters %}, {% endif %}
+{%-     for param in method.response_parameters -%}
+{{param.kind|cpp_wrapper_call_type}}* out_{{prefix}}{{param.name}}
+{%-       if not loop.last %}, {% endif %}
+{%-     endfor %}
+{%-   endif -%}
+{%- endmacro -%}
+
+{%- macro declare_request_params_mutated(prefix, method) -%}
+{{declare_params_mutated(prefix, method.parameters)}}
+{%-   if method.response_parameters != None -%}
+{%-     if method.parameters %}, {% endif -%}
+{{method.name}}Callback callback
+{%-   endif -%}
+{%- endmacro -%}
+
+{%- macro declare_request_params_fuzzed(qualified_class_name, prefix, method) -%}
+{%- if qualified_class_name in classes_to_fuzz %}
+{{declare_request_params_mutated(prefix, method)}}
+{%- else %}
+{{interface_macros.declare_request_params(prefix, method)}}
+{%- endif %}
+{%- endmacro -%}
+
+{%- macro declare_sync_method_params_fuzzed(qualified_class_name, prefix, method) -%}
+{%- if qualified_class_name in classes_to_fuzz %}
+{{declare_sync_method_params_mutated(prefix, method)}} 
+{%- else %}
+{{interface_macros.declare_sync_method_params(prefix, method)}}
+{%- endif %}
+{%- endmacro -%}
\ No newline at end of file
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
index 2aeb29fca9b42..834c9e47b6c55 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/module-shared.cc.tmpl
@@ -1,6 +1,7 @@
 // Copyright 2016 The Chromium Authors. All rights reserved.
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
 
 #include "{{module.path}}-shared.h"
 
@@ -18,6 +19,8 @@
 #include "{{header}}"
 {%- endfor %}
 
+{{interface_fuzzer.insert_fuzzer_dependency(interfaces, namespaces_as_array)}}
+
 {%- for namespace in namespaces_as_array %}
 namespace {{namespace}} {
 {%- endfor %}
diff --git a/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl b/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
index 1f06d01956130..f6d1b89e4b8d8 100644
--- a/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
+++ b/mojo/public/tools/bindings/generators/cpp_templates/module.cc.tmpl
@@ -2,6 +2,8 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+{%- import "interface_fuzzer.tmpl" as interface_fuzzer %}
+
 {%- if variant -%}
 {%-   set variant_path = "%s-%s"|format(module.path, variant) -%}
 {%- else -%}
@@ -55,6 +57,8 @@
 {%- endfor %}
 #endif
 
+{{interface_fuzzer.insert_fuzzer_dependency(interfaces, namespaces_as_array, variant)}}
+
 {%- for namespace in namespaces_as_array %}
 namespace {{namespace}} {
 {%- endfor %}
diff --git a/mojo/public/tools/mojom/mojom/generate/module.py b/mojo/public/tools/mojom/mojom/generate/module.py
index ebbc9b322eaeb..ad7526fec31fc 100644
--- a/mojo/public/tools/mojom/mojom/generate/module.py
+++ b/mojo/public/tools/mojom/mojom/generate/module.py
@@ -963,6 +963,37 @@ class Parameter(object):
   def min_version(self):
     return self.attributes.get(ATTRIBUTE_MIN_VERSION) \
         if self.attributes else None
+  
+  @property
+  def is_mutated(self):
+    # is one of the parameters types targeted by the IPC fuzzer mutation?
+    if not isinstance(self.kind, Struct):
+      return False
+    if self.kind.module is None or not isinstance(self.kind.module, Module):
+      return False
+    if self.kind.mojom_name == 'Url' and self.kind.module.mojom_namespace == 'url.mojom':
+      return True
+    if self.kind.mojom_name == 'SiteForCookies' and self.kind.module.mojom_namespace == 'network.mojom':
+      return True
+    if self.kind.mojom_name == 'SchemefulSite' and self.kind.module.mojom_namespace == 'network.mojom':
+      return True
+    if self.kind.mojom_name == 'Origin' and self.kind.module.mojom_namespace == 'url.mojom':
+      return True
+    if self.kind.mojom_name == 'StorageKey' and self.kind.module.mojom_namespace == 'blink.mojom':
+      return True
+    
+    return False
+  
+  @property
+  def is_interesting(self):
+    if self.kind.mojom_name == "OpenURLParams" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True
+    if self.kind.mojom_name == "FetchAPIRequest" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True # probably not relevant
+    if self.kind.mojom_name == "CommonNavigationParams" and self.kind.module.mojom_namespace == "blink.mojom":
+      return True
+    
+    return False
 
   def __eq__(self, rhs):
     return (isinstance(rhs, Parameter)
diff --git a/third_party/blink/renderer/bindings/generated_in_modules.gni b/third_party/blink/renderer/bindings/generated_in_modules.gni
index c4f36e6faa9b4..d842ec28b949c 100644
--- a/third_party/blink/renderer/bindings/generated_in_modules.gni
+++ b/third_party/blink/renderer/bindings/generated_in_modules.gni
@@ -2213,6 +2213,8 @@ generated_interface_sources_in_modules = [
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_world_information.h",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_world_tracking_state.cc",
   "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_xr_world_tracking_state.h",
+    "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_ipc_fuzzer.cc",
+  "$root_gen_dir/third_party/blink/renderer/bindings/modules/v8/v8_ipc_fuzzer.h",
 ]
 
 # Serial
diff --git a/third_party/blink/renderer/bindings/idl_in_modules.gni b/third_party/blink/renderer/bindings/idl_in_modules.gni
index 317eac06b9e5a..89d2f6a031774 100644
--- a/third_party/blink/renderer/bindings/idl_in_modules.gni
+++ b/third_party/blink/renderer/bindings/idl_in_modules.gni
@@ -1019,6 +1019,7 @@ static_idl_files_in_modules = get_path_info(
           "//third_party/blink/renderer/modules/xr/xr_webgl_layer_init.idl",
           "//third_party/blink/renderer/modules/xr/xr_world_information.idl",
           "//third_party/blink/renderer/modules/xr/xr_world_tracking_state.idl",
+            "//third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl",
         ],
         "abspath")
 
diff --git a/third_party/blink/renderer/core/dom/document.cc b/third_party/blink/renderer/core/dom/document.cc
index 8b47d934ac695..1fd5e57839fa9 100644
--- a/third_party/blink/renderer/core/dom/document.cc
+++ b/third_party/blink/renderer/core/dom/document.cc
@@ -337,6 +337,7 @@
 #include "third_party/blink/renderer/platform/wtf/text/character_names.h"
 #include "third_party/blink/renderer/platform/wtf/text/string_buffer.h"
 #include "third_party/blink/renderer/platform/wtf/text/text_encoding_registry.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
 
 #ifndef NDEBUG
 using WeakDocumentSet = blink::HeapHashSet<blink::WeakMember<blink::Document>>;
@@ -3038,6 +3039,8 @@ StyleResolver& Document::GetStyleResolver() const {
 }
 
 void Document::Initialize() {
+  ::blink::IPCFuzzerCore::GetInstance()->register_document(Url());
+  
   DCHECK_EQ(lifecycle_.GetState(), DocumentLifecycle::kInactive);
   DCHECK(!ax_object_cache_ || this != &AXObjectCacheOwner());
 
diff --git a/third_party/blink/renderer/core/loader/base_fetch_context.cc b/third_party/blink/renderer/core/loader/base_fetch_context.cc
index 61ecb727dfce7..565f071fc73de 100644
--- a/third_party/blink/renderer/core/loader/base_fetch_context.cc
+++ b/third_party/blink/renderer/core/loader/base_fetch_context.cc
@@ -26,6 +26,8 @@
 #include "third_party/blink/renderer/platform/weborigin/scheme_registry.h"
 #include "third_party/blink/renderer/platform/weborigin/security_policy.h"
 
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+
 namespace blink {
 
 base::Optional<ResourceRequestBlockedReason> BaseFetchContext::CanRequest(
@@ -35,6 +37,10 @@ base::Optional<ResourceRequestBlockedReason> BaseFetchContext::CanRequest(
     const ResourceLoaderOptions& options,
     ReportingDisposition reporting_disposition,
     const base::Optional<ResourceRequest::RedirectInfo>& redirect_info) const {
+        if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+          //DISABLED_CHECK
+          return base::nullopt;
+        }
   base::Optional<ResourceRequestBlockedReason> blocked_reason =
       CanRequestInternal(type, resource_request, url, options,
                          reporting_disposition, redirect_info);
diff --git a/third_party/blink/renderer/modules/BUILD.gn b/third_party/blink/renderer/modules/BUILD.gn
index 92e39b8db1acb..750d338d386bf 100644
--- a/third_party/blink/renderer/modules/BUILD.gn
+++ b/third_party/blink/renderer/modules/BUILD.gn
@@ -164,6 +164,7 @@ component("modules") {
     "//third_party/blink/renderer/modules/webusb",
     "//third_party/blink/renderer/modules/worklet",
     "//third_party/blink/renderer/modules/xr",
+    "//third_party/blink/renderer/modules/ipc_fuzzer",
   ]
 
   if (is_android) {
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn b/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn
new file mode 100644
index 0000000000000..01904ed089c09
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/BUILD.gn
@@ -0,0 +1,22 @@
+import("//third_party/blink/renderer/modules/modules.gni")
+
+blink_modules_sources("ipc_fuzzer") {
+  sources = [
+    "ipc_fuzzer.cc",
+    "ipc_fuzzer.h",
+    "ipc_fuzzer_core.cc",
+    "ipc_fuzzer_core.h",
+    "mutation.cc",
+    "mutation.h",
+    "mutation_store.cc",
+    "mutation_store.h",
+    "mutator.cc",
+    "mutator.h",
+    "url_store.cc",
+    "url_store.h",
+  ]
+
+  deps = [
+    "//third_party/abseil-cpp:absl",
+  ]
+}
\ No newline at end of file
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc
new file mode 100644
index 0000000000000..3bf90e56fb1d6
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.cc
@@ -0,0 +1,80 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h"
+#include "base/logging.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+#include "third_party/blink/renderer/core/frame/local_dom_window.h"
+#include "third_party/blink/renderer/core/frame/local_frame.h"
+#include "third_party/blink/renderer/core/frame/local_frame_client.h"
+#include "third_party/blink/public/mojom/frame/frame.mojom-blink.h"
+
+namespace blink {
+void IPCFuzzer::send_detach(ExecutionContext* context) {
+  DLOG(INFO) << "detach frame";
+  IPCFuzzerCore::GetInstance()->send_detach();
+  auto* window = DynamicTo<LocalDOMWindow>(context);
+  // window->GetFrame()->GetLocalFrameHostRemote().Detach();
+  window->GetFrame()->GetLocalFrameHostRemote().DidFailLoadWithError(KURL("http://127.0.0.1:8080"), -1);
+}
+void IPCFuzzer::mutate_url(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::URL, Mutation::KIND::REPLACE_WHOLE, new_url);
+}
+
+void IPCFuzzer::mutate_url_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::URL, Mutation::KIND::REPLACE_HOST, new_host);
+}
+// void IPCFuzzer::mutate_origin(const String& new_url) {
+//   IPCFuzzerCore::GetInstance()->enqueue_mutation(
+//       Mutation::TARGET::ORIGIN, Mutation::KIND::REPLACE_WHOLE, new_url);
+// }
+void IPCFuzzer::mutate_origin_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::ORIGIN, Mutation::KIND::REPLACE_HOST, new_host);
+}
+void IPCFuzzer::mutate_site_for_cookies(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SITE_FOR_COOKIES, Mutation::KIND::REPLACE_WHOLE,
+      new_url);
+}
+void IPCFuzzer::mutate_site_for_cookies_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SITE_FOR_COOKIES, Mutation::KIND::REPLACE_HOST,
+      new_host);
+}
+void IPCFuzzer::mutate_schemeful_site(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SCHEMEFUL_SITE, Mutation::KIND::REPLACE_WHOLE, new_url);
+}
+void IPCFuzzer::mutate_schemeful_site_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::SCHEMEFUL_SITE, Mutation::KIND::REPLACE_HOST, new_host);
+}
+void IPCFuzzer::mutate_storage_key(const String& new_url) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::STORAGE_KEY, Mutation::KIND::REPLACE_WHOLE, new_url);
+}
+void IPCFuzzer::mutate_storage_key_replace_host(const String& new_host) {
+  IPCFuzzerCore::GetInstance()->enqueue_mutation(
+      Mutation::TARGET::STORAGE_KEY, Mutation::KIND::REPLACE_HOST, new_host);
+}
+String IPCFuzzer::mutations() {
+  return IPCFuzzerCore::GetInstance()->list_mutations();
+}
+
+Vector<String> IPCFuzzer::leak() {
+  return IPCFuzzerCore::GetInstance()->leak();
+}
+
+bool IPCFuzzer::check_isolation(const String& site_url){
+  return IPCFuzzerCore::GetInstance()->check_isolation(site_url);
+}
+
+void IPCFuzzer::deactivate_renderer_checks(){
+  IPCFuzzerCore::GetInstance()->deactivate_renderer_checks();
+}
+
+void IPCFuzzer::activate_leak_sanitizer(){
+  IPCFuzzerCore::GetInstance()->activate_leak_sanitizer();
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h
new file mode 100644
index 0000000000000..43ee7c1213f5f
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.h
@@ -0,0 +1,35 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
+
+#include "third_party/blink/renderer/platform/bindings/script_wrappable.h"
+#include "third_party/blink/renderer/modules/modules_export.h"
+// #include "third_party/blink/renderer/platform/bindings/script_state.h"
+#include "third_party/blink/renderer/core/execution_context/execution_context.h"
+
+// this is a wrapper around IPCFuzzerCore that exposes the JS API
+
+namespace blink {
+
+class IPCFuzzer final: public ScriptWrappable {
+  DEFINE_WRAPPERTYPEINFO();
+
+ public:
+  static void send_detach(ExecutionContext* context);
+  static void mutate_url(const String& new_url);
+  static void mutate_url_replace_host(const String& new_host);
+  // static void mutate_origin(const String& new_url);
+  static void mutate_origin_replace_host(const String& new_host);
+  static void mutate_site_for_cookies(const String& new_url);
+  static void mutate_site_for_cookies_replace_host(const String& new_host);
+  static void mutate_schemeful_site(const String& new_url);
+  static void mutate_schemeful_site_replace_host(const String& new_host);
+  static void mutate_storage_key(const String& new_url);
+  static void mutate_storage_key_replace_host(const String& new_host);
+  static String mutations();
+  static Vector<String> leak();
+  static bool check_isolation(const String& site_url);
+  static void deactivate_renderer_checks();
+  static void activate_leak_sanitizer();
+};
+}  // namespace blink
+#endif // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl
new file mode 100644
index 0000000000000..24f0854ed6e1d
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer.idl
@@ -0,0 +1,18 @@
+[Exposed=Window]
+interface IPCFuzzer {
+    [CallWith=ExecutionContext] static void send_detach();
+    static void mutate_url(DOMString new_url);
+    static void mutate_url_replace_host(DOMString new_host);
+    static void mutate_origin_replace_host(DOMString new_host);
+    static void mutate_site_for_cookies(DOMString new_url);
+    static void mutate_site_for_cookies_replace_host(DOMString new_host);
+    static void mutate_schemeful_site(DOMString new_url);
+    static void mutate_schemeful_site_replace_host(DOMString new_host);
+    static void mutate_storage_key(DOMString new_url);
+    static void mutate_storage_key_replace_host(DOMString new_host);
+    static DOMString mutations();
+    static sequence<DOMString> leak();
+    static boolean check_isolation(DOMString site_url);
+    static void deactivate_renderer_checks();
+    static void activate_leak_sanitizer();
+};
\ No newline at end of file
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.cc b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.cc
new file mode 100644
index 0000000000000..c95c1898c26c1
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.cc
@@ -0,0 +1,337 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+// #include <csignal>
+#include <csignal>
+#include "base/logging.h"
+#include "base/memory/singleton.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutator.h"
+#include "url/gurl.h"
+
+#include "mojo/public/cpp/bindings/message.h"
+// #include "mojo/public/cpp/base/big_buffer.h"
+// #include "mojo/public/cpp/base/big_buffer_mojom_traits.h"
+#include "base/memory/shared_memory_mapping.h"
+#include "mojo/core/channel.h"
+#include "mojo/public/cpp/system/message_pipe.h"
+#include "mojo/public/cpp/system/message.h"
+
+
+
+// #include "third_party/blink/public/common/navigation/navigation_params.h"
+// #include
+// "third_party/blink/public/mojom/navigation/navigation_params.mojom-blink.h"
+// #include "third_party/blink/public/mojom/navigation/navigation_params.mojom.h"
+
+namespace blink {
+
+  char magicString[MAGIC_LENGTH+1] = "8bf18cb9455f4a8e8fa93d14ab5ebb5d";
+
+bool containsMagicString(const char *data, size_t data_len){
+  // search for utf-8 magic string
+  if (data_len < MAGIC_LENGTH) {
+    return false;
+  }
+  for (size_t i = 0; i < data_len - MAGIC_LENGTH; i++) {
+    bool found = true;
+    for (size_t j = 0; j < MAGIC_LENGTH; j++) {
+      if (data[i + j] != magicString[j]) {
+        found = false;
+        break;
+      }
+    }
+    if (found) {
+      return true;
+    }
+  }
+  return false;
+}
+
+bool containsMagicString16(const char *data, size_t data_len){
+  // search for utf-16 magic string
+  if (data_len < MAGIC_LENGTH) {
+    return false;
+  }
+  for (size_t i = 0; i < data_len - MAGIC_LENGTH; i++) {
+    bool found = true;
+    for (size_t j = 0; i + j < data_len; j+=2) {
+      if (data[i + j] != magicString[j/2]) {
+        found = false;
+        break;
+      }
+    }
+    if (found) {
+      return true;
+    }
+  }
+  return false;
+}
+
+// Basic function to append a character to a buffer, expanding it if necessary
+void appendChar(char *&str, int &len, int &cap, char c) {
+    if (len + 1 >= cap) {
+        cap *= 2;  // Double the capacity
+        char *newStr = new char[cap];  // Allocate new buffer
+        for (int i = 0; i < len; ++i) {
+            newStr[i] = str[i];  // Copy old content
+        }
+        delete[] str;  // Free old buffer
+        str = newStr;
+    }
+    str[len++] = c;  // Append the character
+    str[len] = '\0';  // Null-terminate the string
+}
+
+// Function to append a hexadecimal representation of a byte to a string
+void appendHex(char *&str, int &len, int &cap, unsigned char byte) {
+    const char *hexDigits = "0123456789ABCDEF";
+    appendChar(str, len, cap, hexDigits[byte >> 4]);
+    appendChar(str, len, cap, hexDigits[byte & 0x0F]);
+}
+
+// Main hexDump function that returns a dynamically allocated string
+char* hexDump(const char* data, size_t len) {
+    int capacity = 256;  // Initial capacity of the string
+    char *result = new char[capacity];
+    int resultLen = 0;
+    result[resultLen] = '\0';  // Start with an empty string
+
+    for (size_t i = 0; i < len; ++i) {
+        unsigned char byte = data[i];
+        if (byte >= 0x20 && byte < 0x7E) {  // Printable ASCII range
+            appendChar(result, resultLen, capacity, byte);
+        } else {
+            appendChar(result, resultLen, capacity, '\\');
+            appendChar(result, resultLen, capacity, 'x');
+            appendHex(result, resultLen, capacity, byte);
+        }
+    }
+
+    return result;
+}
+
+void leakSanitizer(const char* data, size_t data_len) {
+  // char* output = hexDump(data, data_len);
+  // LOG(ERROR) << output;
+  // delete[] output;
+
+  if (data != nullptr && data_len > 0 && (containsMagicString(data, data_len) || containsMagicString16(data, data_len))) {
+    char* output = hexDump(data, data_len);
+    LOG(ERROR) << "[UXSS] leak in IPC message: " << output;
+    delete[] output;
+  }
+}
+
+void leakSanitizer2(const char* data, size_t data_len) {
+  // char* output = hexDump(data, data_len);
+  // LOG(ERROR) << output;
+  // delete[] output;
+
+  if (data != nullptr && data_len > 0 && (containsMagicString(data, data_len) || containsMagicString16(data, data_len))) {
+    char* output = hexDump(data, data_len);
+    LOG(ERROR) << "[UXSS] leak in IPC message: " << output;
+    delete[] output;
+  }
+}
+
+void IPCFuzzerCore::activate_leak_sanitizer() {
+    LOG(ERROR) << "Activating leak sanitizer";
+  ::mojo::leakSanitizerCallback = &leakSanitizer; // bindings/message.cc
+  // ::mojo_base::internal::leakSanitizerCallback = &leakSanitizer2;
+  // ::base::leakSanitizerCallback = &leakSanitizer2; // shared_memory_mapping.cc
+  // ::mojo::core::leakSanitizerCallback = &leakSanitizer; // channel.cc
+  // ::mojo::leakSanitizerCallback2 = &leakSanitizer; // message_pipe.cc
+  // ::mojo::leakSanitizerCallback3 = &leakSanitizer; // system/message.cc
+}
+
+IPCFuzzerCore* IPCFuzzerCore::GetInstance() {
+  return ::base::Singleton<IPCFuzzerCore>::get();
+}
+
+IPCFuzzerCore::IPCFuzzerCore()
+    : url_mutation_store_(),
+      security_origin_mutation_store_(),
+      schemeful_site_mutation_store_(),
+      site_for_cookies_mutation_store_(),
+      storage_key_mutation_store_(),
+      url_store_(),
+      lock_(),
+      locked_site_(::base::nullopt) {
+  LOG(INFO) << "RENDERER PROCESS";
+  sigignore(SIGTERM);
+}
+
+IPCFuzzerCore::~IPCFuzzerCore() = default;
+
+// todo ignore kill signals
+void IPCFuzzerCore::send_detach() {
+  // DLOG(INFO) << "send detach message to browser";
+}
+
+void IPCFuzzerCore::register_document(const KURL& url) {
+  url_store_.store(url);
+}
+
+WTF::Vector<WTF::String> IPCFuzzerCore::leak() {
+  // WTF::String result;
+  // for (const WTF::String& s : url_store_.get()) {
+  //   result = result + s + "\n";
+  // }
+  // return result;
+  return url_store_.get();
+}
+
+void IPCFuzzerCore::deactivate_renderer_checks() {
+  LOG(ERROR) << "deadbeef" ;
+  checks_deactivated = true;
+}
+
+void IPCFuzzerCore::enqueue_mutation(Mutation::TARGET target,
+                                     Mutation::KIND kind,
+                                     WTF::String url) {
+  switch (target) {
+    case Mutation::TARGET::URL:
+      url_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::ORIGIN:
+      security_origin_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::SITE_FOR_COOKIES:
+      site_for_cookies_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::SCHEMEFUL_SITE:
+      schemeful_site_mutation_store_.enqueue(target, kind, url);
+      break;
+    case Mutation::TARGET::STORAGE_KEY:
+      storage_key_mutation_store_.enqueue(target, kind, url);
+      break;
+  }
+}
+
+WTF::String IPCFuzzerCore::list_mutations() {
+  // return mutation_store_.to_string();
+  // TODO fix for multiple stores
+  return "";
+}
+
+std::unique_ptr<const KURL> IPCFuzzerCore::mutate_kurl_hook(const KURL& url) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: KURL " << url;
+  std::unique_ptr<Mutation> mutation = url_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return Mutator::mutate_url(url, *mutation);
+}
+
+std::unique_ptr<const GURL> IPCFuzzerCore::mutate_gurl_hook(const ::GURL& url) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: GURL " << url;
+
+  // todo
+
+  return nullptr;
+}
+
+::scoped_refptr<const SecurityOrigin>
+IPCFuzzerCore::mutate_security_origin_hook(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+  if (security_origin != nullptr) {
+    DLOG(INFO) << "IPCFuzzerCore intercept value: SecurityOrigin "
+               << security_origin->ToString();
+  }
+
+  std::unique_ptr<Mutation> mutation =
+      security_origin_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return Mutator::mutate_security_origin(security_origin, *mutation);
+}
+
+// absl::optional<BlinkSchemefulSite> IPCFuzzerCore::mutate_schemeful_site_hook(
+//     const absl::optional<BlinkSchemefulSite>& schemeful_site) {
+//   if (schemeful_site.has_value()) {
+//     DLOG(INFO) << "IPCFuzzerCore intercept value: BlinkSchemefulSite "
+//                << schemeful_site.value().GetDebugString();
+//   }
+
+//   // TODO: only dequeue mutation if IPCFuzzerCore intercept value:ed param has
+//   // value?
+//   std::unique_ptr<Mutation> mutation = schemeful_site_mutation_store_.dequeue();
+
+//   if (mutation == nullptr) {
+//     return absl::nullopt;
+//   }
+
+//   return Mutator::mutate_schemeful_site(schemeful_site, *mutation);
+// }
+
+std::unique_ptr<const ::net::SiteForCookies>
+IPCFuzzerCore::mutate_site_for_cookies_hook(
+    const ::net::SiteForCookies& site_for_cookies) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: SiteForCookies "
+             << site_for_cookies.ToDebugString();
+
+  std::unique_ptr<Mutation> mutation =
+      site_for_cookies_mutation_store_.dequeue();
+
+  if (mutation == nullptr) {
+    return nullptr;
+  }
+
+  return Mutator::mutate_site_for_cookies(site_for_cookies, *mutation);
+}
+
+// std::unique_ptr<const BlinkStorageKey> IPCFuzzerCore::mutate_storage_key_hook(
+//     const BlinkStorageKey& storage_key) {
+//   DLOG(INFO) << "IPCFuzzerCore intercept value: BlinkStorageKey "
+//              << storage_key.ToDebugString();
+
+//   std::unique_ptr<Mutation> mutation = storage_key_mutation_store_.dequeue();
+
+//   if (mutation == nullptr) {
+//     return nullptr;
+//   }
+
+//   return Mutator::mutate_storage_key(storage_key, *mutation);
+// }
+
+std::unique_ptr<const ::url::Origin> IPCFuzzerCore::mutate_origin_hook(
+    const ::url::Origin& origin) {
+  DLOG(INFO) << "IPCFuzzerCore intercept value: Origin " << origin.Serialize();
+
+  // todo
+
+  return nullptr;
+}
+
+bool IPCFuzzerCore::check_isolation(const WTF::String& site_url) {
+  KURL url(site_url);
+  // auto security_origin =
+  //     SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+  // BlinkSchemefulSite schemeful_site(security_origin);
+
+  lock_.Acquire();
+  if (locked_site_.has_value()) {
+    if (locked_site_.value().Host() == url.Host()) {
+      lock_.Release();
+      return false;
+    } else {
+      LOG(INFO) << "[blink] [UXSS] " << url.Host() << " "
+                 << locked_site_.value().Host();
+      lock_.Release();
+      return true;
+    }
+
+  } else {
+    locked_site_ = url;
+    lock_.Release();
+    LOG(INFO) << "LOCK " << url.Host();
+    return false;
+  }
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h
new file mode 100644
index 0000000000000..1c7ecb826ddc3
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h
@@ -0,0 +1,97 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER__IPC_FUZZER_CORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER__IPC_FUZZER_CORE_H_
+
+#include <memory>
+#include "base/memory/singleton.h"
+#include "net/cookies/site_for_cookies.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/url_store.h"
+// #include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+// #include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+namespace base {
+template <typename T>
+struct DefaultSingletonTraits;
+}
+
+namespace blink {
+    #define MAGIC_LENGTH 32
+    extern char magicString[MAGIC_LENGTH+1];
+
+    extern void leak_sanitizer(const char* data, size_t data_len);
+    extern void leak_sanitizer2(const char* data, size_t data_len);
+    bool containsMagicString(const char* data, size_t data_len);
+    bool containsMagicString16(const char* data, size_t data_len);
+    char* hexDump(const char* data, size_t len);
+    void appendHex(char *&str, int &len, int &cap, unsigned char byte);
+    void appendChar(char *&str, int &len, int &cap, char c);
+
+class IPCFuzzerCore {
+ public:
+  ~IPCFuzzerCore();
+
+  static IPCFuzzerCore* GetInstance();
+
+  IPCFuzzerCore(const IPCFuzzerCore&) = delete;
+  IPCFuzzerCore& operator=(const IPCFuzzerCore&) = delete;
+
+  // JS bindings
+  void enqueue_mutation(Mutation::TARGET target,
+                        Mutation::KIND kind,
+                        WTF::String url);
+  void send_detach();
+  WTF::String list_mutations();
+  bool check_isolation(const WTF::String& site_url);
+
+  void register_document(const KURL& url);
+  WTF::Vector<WTF::String> leak();
+
+  void deactivate_renderer_checks();
+  bool checks_deactivated = false;
+
+  void activate_leak_sanitizer();
+
+  // fuzzer hooks
+
+  std::unique_ptr<const KURL> mutate_kurl_hook(const KURL& url);
+
+  std::unique_ptr<const ::GURL> mutate_gurl_hook(const GURL& url);
+
+  ::scoped_refptr<const SecurityOrigin> mutate_security_origin_hook(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin);
+
+  // absl::optional<BlinkSchemefulSite> mutate_schemeful_site_hook(
+  //     const absl::optional<BlinkSchemefulSite>& schemeful_site);
+
+  std::unique_ptr<const ::net::SiteForCookies> mutate_site_for_cookies_hook(
+      const ::net::SiteForCookies& site_for_cookies);
+
+  // std::unique_ptr<const BlinkStorageKey> mutate_storage_key_hook(
+  //     const BlinkStorageKey& storage_key);
+
+  std::unique_ptr<const ::url::Origin> mutate_origin_hook(
+      const ::url::Origin& origin);
+
+ private:
+  IPCFuzzerCore();
+  friend struct ::base::DefaultSingletonTraits<IPCFuzzerCore>;
+
+  MutationStore url_mutation_store_;
+  MutationStore security_origin_mutation_store_;
+  MutationStore schemeful_site_mutation_store_;
+  MutationStore site_for_cookies_mutation_store_;
+  MutationStore storage_key_mutation_store_;
+  UrlStore url_store_;
+
+  base::Lock lock_;
+  base::Optional<KURL> locked_site_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_IPC_FUZZER_CORE_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation.cc b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.cc
new file mode 100644
index 0000000000000..dc118621c0405
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.cc
@@ -0,0 +1,40 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+
+namespace blink {
+WTF::String Mutation::to_string() const {
+  WTF::String target_str;
+  switch (target_) {
+    case Mutation::TARGET::URL:
+      target_str = "URL";
+      break;
+    case Mutation::TARGET::ORIGIN:
+      target_str = "ORIGIN";
+      break;
+    case Mutation::TARGET::SITE_FOR_COOKIES:
+      target_str = "SITE_FOR_COOKIES";
+      break;
+    case Mutation::TARGET::SCHEMEFUL_SITE:
+      target_str = "SCHEMEFUL_SITE";
+      break;
+    case Mutation::TARGET::STORAGE_KEY:
+      target_str = "STORAGE_KEY";
+      break;
+  }
+
+  WTF::String kind_str;
+  switch (kind_) {
+    case Mutation::KIND::REPLACE_HOST:
+      kind_str = "REPLACE_HOST";
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      kind_str = "REPLACE_WHOLE";
+      break;
+  }
+
+  WTF::String result = WTF::String("{'target':'") + target_str +
+                       WTF::String("', 'kind':'") + kind_str +
+                       WTF::String("', 'url':'") + url_.GetString() + WTF::String("'}");
+  return result;
+}
+
+}  // namespace ipc_fuzzer
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation.h b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.h
new file mode 100644
index 0000000000000..9a8b654bb7077
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation.h
@@ -0,0 +1,41 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_H_
+
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+
+namespace blink {
+
+class Mutation {
+ public:
+
+  enum class TARGET {
+    URL,
+    ORIGIN,
+    SITE_FOR_COOKIES,
+    SCHEMEFUL_SITE,
+    STORAGE_KEY,
+  };
+
+  enum class KIND {
+    REPLACE_HOST,
+    REPLACE_WHOLE,
+  };
+
+  Mutation(TARGET target, KIND kind, KURL url)
+      : target_(target), kind_(kind), url_(url) {}
+
+  const TARGET& get_target() const {return target_;}
+  const KIND& get_kind() const { return kind_; }
+  const KURL& get_url() const { return url_; }
+  WTF::String to_string() const;
+
+ private:
+  TARGET target_;
+  KIND kind_;
+  KURL url_;
+};
+}  // namespace ipc_fuzzer
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.cc b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.cc
new file mode 100644
index 0000000000000..34836b94b3e09
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.cc
@@ -0,0 +1,73 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h"
+#include "base/logging.h"
+
+namespace blink {
+MutationStore::MutationStore() = default;
+MutationStore::~MutationStore() = default;
+
+void MutationStore::enqueue(Mutation::TARGET target,
+                            Mutation::KIND kind,
+                            WTF::String url) {
+  ::blink::KURL parsed_url(url);
+  std::unique_ptr<Mutation> mutation =
+      std::make_unique<Mutation>(target, kind, std::move(parsed_url));
+  DLOG(INFO) << "IPCFuzzer enqueue mutation: " << mutation->to_string();
+
+  lock_.Acquire();
+  mutations_.push_back(std::move(mutation));
+  lock_.Release();
+}
+
+void MutationStore::enqueue(Mutation mutation) {
+  DLOG(INFO) << "IPCFuzzer enqueue mutation: " << mutation.to_string();
+  lock_.Acquire();
+  mutations_.emplace_back(std::make_unique<Mutation>(std::move(mutation)));
+  lock_.Release();
+}
+
+std::unique_ptr<Mutation> MutationStore::dequeue_match(
+    const Mutation::TARGET& target) {
+  lock_.Acquire();
+  if (mutations_.size() == 0) {
+    lock_.Release();
+    return nullptr;
+  }
+
+  if (mutations_.at(0)->get_target() == target) {
+    std::unique_ptr<Mutation> mutation = std::move(mutations_.at(0));
+    mutations_.EraseAt(0);
+    lock_.Release();
+    return mutation;
+  }
+  lock_.Release();
+  return nullptr;
+}
+
+std::unique_ptr<Mutation> MutationStore::dequeue() {
+  lock_.Acquire();
+  if (mutations_.size() == 0) {
+    lock_.Release();
+    return nullptr;
+  }
+
+  std::unique_ptr<Mutation> mutation = std::move(mutations_.at(0));
+  mutations_.EraseAt(0);
+  lock_.Release();
+  return mutation;
+}
+
+WTF::String MutationStore::to_string() {
+  WTF::String result = "[";
+  lock_.Acquire();
+  for (const auto& m : mutations_) {
+    result = result + m->to_string();
+    if (&m != &mutations_.back()) {
+      result = result + ",";
+    }
+  }
+  lock_.Release();
+  result = result + "]";
+  return result;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h
new file mode 100644
index 0000000000000..104c757b6094b
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutation_store.h
@@ -0,0 +1,28 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_STORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_STORE_H_
+
+#include <memory>
+#include "base/synchronization/lock.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+
+namespace blink {
+class MutationStore {
+ public:
+  MutationStore();
+  ~MutationStore();
+
+  void enqueue(Mutation::TARGET target, Mutation::KIND kind, WTF::String url);
+  void enqueue(Mutation mutation);
+
+  std::unique_ptr<Mutation> dequeue_match(const Mutation::TARGET& target);
+  std::unique_ptr<Mutation> dequeue();
+  WTF::String to_string();
+
+ private:
+  base::Lock lock_;
+  WTF::Vector<std::unique_ptr<Mutation>> mutations_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATION_STORE_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutator.cc b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.cc
new file mode 100644
index 0000000000000..07d345415da93
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.cc
@@ -0,0 +1,312 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutator.h"
+#include "base/logging.h"
+#include "url/gurl.h"
+
+namespace blink {
+
+std::unique_ptr<const KURL> Mutator::mutate_url(const KURL& url,
+                                                const Mutation& mutation) {
+  std::unique_ptr<const KURL> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated = url_replace_host(url, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = std::make_unique<const KURL>(mutation.get_url());
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: KURL " << *mutated;
+  // }
+  return mutated;
+}
+
+// return scoped_refptr because that is used by all Mojo functions
+::scoped_refptr<const SecurityOrigin> Mutator::mutate_security_origin(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin,
+    const Mutation& mutation) {
+  ::scoped_refptr<const SecurityOrigin> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated =
+          security_origin_replace_host(security_origin, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = SecurityOrigin::CreateWithReferenceOrigin(mutation.get_url(),
+                                                          nullptr);
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: SecurityOrigin " <<
+  //   mutated->ToString();
+  // }
+  return mutated;
+}
+
+// return optional because that is used by all Mojo functions
+// absl::optional<BlinkSchemefulSite> Mutator::mutate_schemeful_site(
+//     const absl::optional<BlinkSchemefulSite>& schemeful_site,
+//     const Mutation& mutation) {
+//   absl::optional<BlinkSchemefulSite> mutated = absl::nullopt;
+//   switch (mutation.get_kind()) {
+//     case Mutation::KIND::REPLACE_HOST:
+//       mutated = schemeful_site_replace_host(schemeful_site, mutation.get_url());
+//       break;
+//     case Mutation::KIND::REPLACE_WHOLE: {
+//       auto security_origin = SecurityOrigin::CreateWithReferenceOrigin(
+//           mutation.get_url(), nullptr);
+//       mutated = BlinkSchemefulSite(security_origin);
+//     } break;
+//   }
+//   // if (mutated.has_value()) {
+//   //   DLOG(INFO) << "IPCFuzzer mutated: BlinkSchemefulSite "
+//   //              << mutated.value().GetDebugString();
+//   // }
+//   return mutated;
+// }
+
+std::unique_ptr<const ::net::SiteForCookies> Mutator::mutate_site_for_cookies(
+    const ::net::SiteForCookies& site_for_cookies,
+    const Mutation& mutation) {
+  std::unique_ptr<const ::net::SiteForCookies> mutated = nullptr;
+  switch (mutation.get_kind()) {
+    case Mutation::KIND::REPLACE_HOST:
+      mutated =
+          site_for_cookies_replace_host(site_for_cookies, mutation.get_url());
+      break;
+    case Mutation::KIND::REPLACE_WHOLE:
+      mutated = std::make_unique<const ::net::SiteForCookies>(
+          ::net::SiteForCookies::FromUrl(GURL(mutation.get_url())));
+      break;
+  }
+  // if (mutated != nullptr) {
+  //   DLOG(INFO) << "IPCFuzzer mutated: SiteForCookies "
+  //              << mutated->ToDebugString();
+  // }
+  return mutated;
+}
+
+// TODO: implement more different mutations
+// std::unique_ptr<const BlinkStorageKey> Mutator::mutate_storage_key(
+//     const BlinkStorageKey& storage_key,
+//     const Mutation& mutation) {
+//   std::unique_ptr<const BlinkStorageKey> mutated = nullptr;
+//   switch (mutation.get_kind()) {
+//     case Mutation::KIND::REPLACE_HOST:
+//       mutated = storage_key_replace_host(storage_key, mutation.get_url());
+//       break;
+//     case Mutation::KIND::REPLACE_WHOLE:
+//       mutated = create_storage_key(mutation.get_url());
+//       break;
+//   }
+//   // if (mutated != nullptr) {
+//   //   DLOG(INFO) << "IPCFuzzer mutated: BlinkStorageKey "
+//   //              << mutated->ToDebugString();
+//   // }
+//   return mutated;
+// }
+
+// private helper functions
+
+std::unique_ptr<KURL> Mutator::url_replace_host(const KURL& url,
+                                                const KURL& replacement) {
+  if (!can_replace_host(url)) {
+    return url_replace_inner_host(url, replacement);
+  }
+
+  std::unique_ptr<KURL> new_url = std::make_unique<KURL>(url);
+  new_url->SetHost(replacement.Host());
+  if (replacement.HasPort()) {
+    new_url->SetPort(replacement.Port());
+  } else {
+    new_url->RemovePort();
+  }
+  return new_url;
+}
+
+std::unique_ptr<KURL> Mutator::url_replace_inner_host(const KURL& url,
+                                                      const KURL& replacement) {
+  if (!can_replace_inner_host(url)) {
+    return nullptr;
+  }
+
+  WTF::String protocol;
+  if (url.ProtocolIs("blob")) {
+    protocol = "blob:";
+  } else if (url.ProtocolIs("filesystem")) {
+    protocol = "filesystem:";
+  }
+
+  WTF::String url_str = url.GetString();
+  url_str.Replace(protocol, "");
+
+  KURL inner_url(url_str);
+
+  // if (inner_url.IsNull() || inner_url.IsEmpty()) {
+  //   DLOG(INFO) << "IPCFuzzer mutating inner url failed";
+  //   return nullptr;
+  // }
+
+  inner_url.SetHost(replacement.Host());
+  if (replacement.HasPort()) {
+    inner_url.SetPort(replacement.Port());
+  } else {
+    inner_url.RemovePort();
+  }
+  std::unique_ptr<KURL> new_url =
+      std::make_unique<KURL>(protocol + inner_url.GetString());
+  return new_url;
+}
+
+::scoped_refptr<const SecurityOrigin> Mutator::security_origin_replace_host(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin,
+    const KURL& replacement) {
+  if (!can_replace_host(security_origin)) {
+    return nullptr;
+  }
+  KURL url(security_origin->ToString());
+
+  std::unique_ptr<blink::KURL> new_url = url_replace_host(url, replacement);
+  if (new_url == nullptr) {
+    // replacing host failed
+    return nullptr;
+  }
+
+  return SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+}
+
+// absl::optional<BlinkSchemefulSite> Mutator::schemeful_site_replace_host(
+//     const absl::optional<BlinkSchemefulSite>& schemeful_site,
+//     const KURL& replacement) {
+//   if (!can_replace_host(schemeful_site)) {
+//     return absl::nullopt;
+//   }
+
+//   String schemeful_site_str = schemeful_site.value().Serialize();
+
+//   std::unique_ptr<KURL> new_url =
+//       url_replace_host(KURL(schemeful_site_str), replacement);
+//   if (new_url == nullptr) {
+//     return absl::nullopt;
+//   }
+
+//   auto origin = SecurityOrigin::CreateWithReferenceOrigin(*new_url, nullptr);
+//   return BlinkSchemefulSite(origin);
+// }
+
+std::unique_ptr<::net::SiteForCookies> Mutator::site_for_cookies_replace_host(
+    const ::net::SiteForCookies& site_for_cookies,
+    const KURL& replacement) {
+  if (!can_replace_host(site_for_cookies)) {
+    return nullptr;
+  }
+
+  GURL url = site_for_cookies.RepresentativeUrl();
+  std::unique_ptr<KURL> new_url = url_replace_host(KURL(url), replacement);
+  if (new_url == nullptr) {
+    return nullptr;
+  }
+
+  return std::make_unique<::net::SiteForCookies>(
+      ::net::SiteForCookies::FromUrl(GURL(*new_url)));
+}
+
+// std::unique_ptr<BlinkStorageKey> Mutator::storage_key_replace_host(
+//     const BlinkStorageKey& storage_key,
+//     const KURL& replacement) {
+//   auto security_origin = storage_key.GetSecurityOrigin();
+//   ::scoped_refptr<const SecurityOrigin> new_security_origin =
+//       security_origin_replace_host(security_origin, replacement);
+//   if (new_security_origin == nullptr) {
+//     return nullptr;
+//   }
+
+//   // if the storage key has a nonce, just replace the host and reuse the
+//   // nonce
+//   // QUESTION: is this right??
+//   auto token = storage_key.GetNonce();
+//   if (token.has_value()) {
+//     return std::make_unique<BlinkStorageKey>(
+//         BlinkStorageKey::CreateWithNonce(new_security_origin, token.value()));
+//   }
+
+//   auto schemeful_site = storage_key.GetTopLevelSite();
+//   absl::optional<BlinkSchemefulSite> new_schemeful_site =
+//       schemeful_site_replace_host(schemeful_site, replacement);
+//   if (new_schemeful_site.has_value()) {
+//     return std::make_unique<BlinkStorageKey>(new_security_origin,
+//                                              new_schemeful_site.value());
+//   }
+
+//   return std::make_unique<BlinkStorageKey>(new_security_origin);
+// }
+
+// std::unique_ptr<BlinkStorageKey> Mutator::create_storage_key(const KURL& url) {
+//   auto security_origin =
+//       SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+//   return std::make_unique<BlinkStorageKey>(security_origin);
+// }
+
+// std::unique_ptr<BlinkStorageKey> Mutator::create_storage_key(
+//     const KURL& url,
+//     mojom::AncestorChainBit ancestor_chain_bit) {
+//   auto security_origin =
+//       SecurityOrigin::CreateWithReferenceOrigin(url, nullptr);
+//   auto schemeful_site = BlinkSchemefulSite(security_origin);
+//   return std::make_unique<BlinkStorageKey>(
+//       BlinkStorageKey::Create(security_origin, schemeful_site,
+//                                        ancestor_chain_bit));
+// }
+
+bool Mutator::can_replace_host(const KURL& url) {
+  if (url.IsNull()) {
+    // DLOG(INFO) << "IPCFuzzer KURL is null";
+    return false;
+  }
+  if (url.IsEmpty()) {
+    // DLOG(INFO) << "IPCFuzzer KURL is empty";
+    return false;
+  }
+  if (!url.CanSetHostOrPort() || url.ProtocolIs("blob") ||
+      url.ProtocolIs("filesystem")) {
+    return false;
+  }
+  return true;
+}
+
+bool Mutator::can_replace_inner_host(const KURL& url) {
+  if (url.ProtocolIs("blob") || url.ProtocolIs("filesystem")) {
+    return true;
+  }
+  return false;
+}
+
+bool Mutator::can_replace_host(
+    const ::scoped_refptr<const SecurityOrigin>& security_origin) {
+  if (security_origin == nullptr || security_origin->IsOpaque()) {
+    return false;
+  }
+  return true;
+}
+
+// bool Mutator::can_replace_host(
+//     const absl::optional<BlinkSchemefulSite>& schemeful_site) {
+//   if (!schemeful_site.has_value()) {
+//     return false;
+//   }
+//   if (schemeful_site.value().Serialize() == "null") {
+//     return false;
+//   }
+//   return true;
+// }
+
+bool Mutator::can_replace_host(const ::net::SiteForCookies& site_for_cookies) {
+  if (site_for_cookies.IsNull()) {
+    return false;
+  }
+  return true;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/mutator.h b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.h
new file mode 100644
index 0000000000000..83868c3b32e70
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/mutator.h
@@ -0,0 +1,83 @@
+// COPYRIGHT 2023 Jan Niklas Drescher
+
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
+
+#include <memory>
+#include "net/cookies/site_for_cookies.h"
+#include "third_party/blink/renderer/modules/ipc_fuzzer/mutation.h"
+// #include "third_party/blink/renderer/platform/network/blink_schemeful_site.h"
+// #include "third_party/blink/renderer/platform/storage/blink_storage_key.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/weborigin/security_origin.h"
+
+namespace blink {
+class Mutator {
+ public:
+  static std::unique_ptr<const KURL> mutate_url(
+      const KURL& url,
+      const Mutation& mutation);
+
+  // return scoped_refptr because that is used by all Mojo functions
+  static ::scoped_refptr<const SecurityOrigin> mutate_security_origin(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin,
+      const Mutation& mutation);
+
+  // // return optional because that is used by all Mojo functions
+  // static absl::optional<BlinkSchemefulSite> mutate_schemeful_site(
+  //     const absl::optional<BlinkSchemefulSite>& schemeful_site,
+  //     const Mutation& mutation);
+
+  static std::unique_ptr<const ::net::SiteForCookies> mutate_site_for_cookies(
+      const ::net::SiteForCookies& site_for_cookies,
+      const Mutation& mutation);
+
+  // static std::unique_ptr<const BlinkStorageKey> mutate_storage_key(
+  //     const BlinkStorageKey& storage_key,
+  //     const Mutation& mutation);
+
+ private:
+  static std::unique_ptr<KURL> url_replace_host(
+      const KURL& url,
+      const KURL& replacement);
+
+  static std::unique_ptr<KURL> url_replace_inner_host(
+      const KURL& url,
+      const KURL& replacement);
+
+  static ::scoped_refptr<const SecurityOrigin>
+  security_origin_replace_host(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin,
+      const KURL& replacement);
+
+  // static absl::optional<BlinkSchemefulSite>
+  // schemeful_site_replace_host(
+  //     const absl::optional<BlinkSchemefulSite>& schemeful_site,
+  //     const KURL& replacement);
+
+  static std::unique_ptr<::net::SiteForCookies> site_for_cookies_replace_host(
+      const ::net::SiteForCookies& site_for_cookies,
+      const KURL& replacement);
+
+  // static std::unique_ptr<BlinkStorageKey> storage_key_replace_host(
+  //     const BlinkStorageKey& storage_key,
+  //     const KURL& replacement);
+
+  // static std::unique_ptr<BlinkStorageKey> create_storage_key(
+  //     const KURL& url);
+//   static std::unique_ptr<BlinkStorageKey> create_storage_key(
+//       const KURL& url,
+//       mojom::AncestorChainBit ancestor_chain_bit);
+
+  static bool can_replace_host(const KURL& url);
+  static bool can_replace_inner_host(const KURL& url);
+  static bool can_replace_host(
+      const ::scoped_refptr<const SecurityOrigin>& security_origin);
+  // static bool can_replace_host(
+  //     const absl::optional<BlinkSchemefulSite>& schemeful_site);
+  static bool can_replace_host(const ::net::SiteForCookies& site_for_cookies);
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_MUTATOR_H_
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc
new file mode 100644
index 0000000000000..fbd1d14cfce87
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.cc
@@ -0,0 +1,26 @@
+#include "third_party/blink/renderer/modules/ipc_fuzzer/url_store.h"
+#include "base/logging.h"
+
+namespace blink {
+UrlStore::UrlStore() = default;
+UrlStore::~UrlStore() = default;
+
+void UrlStore::store(const KURL& url) {
+  if (url.IsNull()) {
+    return;
+  }
+
+  lock_.Acquire();
+  WTF::String s = url.GetString();
+  urls_.insert(s);
+  lock_.Release();
+}
+
+WTF::Vector<WTF::String> UrlStore::get() {
+  lock_.Acquire();
+  WTF::Vector<WTF::String> result; // urls_
+  lock_.Release();
+  return result;
+}
+
+}  // namespace blink
diff --git a/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h
new file mode 100644
index 0000000000000..2763393112f83
--- /dev/null
+++ b/third_party/blink/renderer/modules/ipc_fuzzer/url_store.h
@@ -0,0 +1,26 @@
+#ifndef THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
+#define THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
+
+#include <memory>
+#include "base/synchronization/lock.h"
+#include "third_party/blink/renderer/platform/weborigin/kurl.h"
+#include "third_party/blink/renderer/platform/wtf/text/string_hash.h"
+#include "third_party/blink/renderer/platform/wtf/hash_set.h"
+
+namespace blink {
+class UrlStore {
+ public:
+  UrlStore();
+  ~UrlStore();
+
+  void store(const KURL& url);
+  WTF::Vector<WTF::String> get();
+
+ private:
+  base::Lock lock_;
+  WTF::HashSet<WTF::String> urls_;
+};
+
+}  // namespace blink
+
+#endif  // THIRD_PARTY_BLINK_RENDERER_MODULES_IPC_FUZZER_URL_STORE_H_
diff --git a/third_party/blink/renderer/platform/exported/web_security_origin.cc b/third_party/blink/renderer/platform/exported/web_security_origin.cc
index a465d679e5ec2..2c3efda06906e 100644
--- a/third_party/blink/renderer/platform/exported/web_security_origin.cc
+++ b/third_party/blink/renderer/platform/exported/web_security_origin.cc
@@ -35,6 +35,8 @@
 #include "third_party/blink/renderer/platform/weborigin/kurl.h"
 #include "third_party/blink/renderer/platform/weborigin/security_origin.h"
 
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+
 namespace blink {
 
 WebSecurityOrigin WebSecurityOrigin::CreateFromString(const WebString& origin) {
@@ -83,22 +85,38 @@ bool WebSecurityOrigin::IsOpaque() const {
 }
 
 bool WebSecurityOrigin::CanAccess(const WebSecurityOrigin& other) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   DCHECK(other.private_);
   return private_->CanAccess(other.private_.Get());
 }
 
 bool WebSecurityOrigin::CanRequest(const WebURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanRequest(url);
 }
 
 bool WebSecurityOrigin::CanDisplay(const WebURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanDisplay(url);
 }
 
 bool WebSecurityOrigin::IsPotentiallyTrustworthy() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->IsPotentiallyTrustworthy();
 }
@@ -109,6 +127,10 @@ WebString WebSecurityOrigin::ToString() const {
 }
 
 bool WebSecurityOrigin::CanAccessPasswordManager() const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(private_);
   return private_->CanAccessPasswordManager();
 }
diff --git a/third_party/blink/renderer/platform/weborigin/security_origin.cc b/third_party/blink/renderer/platform/weborigin/security_origin.cc
index c448d3262262d..ff9cd949e452e 100644
--- a/third_party/blink/renderer/platform/weborigin/security_origin.cc
+++ b/third_party/blink/renderer/platform/weborigin/security_origin.cc
@@ -52,6 +52,8 @@
 #include "url/url_canon_ip.h"
 #include "url/url_util.h"
 
+#include "third_party/blink/renderer/modules/ipc_fuzzer/ipc_fuzzer_core.h"
+
 namespace blink {
 
 namespace {
@@ -322,6 +324,10 @@ SecurityOrigin::GetNonceForSerialization() const {
 
 bool SecurityOrigin::CanAccess(const SecurityOrigin* other,
                                AccessResultDomainDetail& detail) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_) {
     detail = AccessResultDomainDetail::kDomainNotRelevant;
     return true;
@@ -341,6 +347,10 @@ bool SecurityOrigin::CanAccess(const SecurityOrigin* other,
 }
 
 bool SecurityOrigin::PassesFileCheck(const SecurityOrigin* other) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   DCHECK(IsLocal());
   DCHECK(other->IsLocal());
 
@@ -349,6 +359,10 @@ bool SecurityOrigin::PassesFileCheck(const SecurityOrigin* other) const {
 }
 
 bool SecurityOrigin::CanRequest(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_)
     return true;
 
@@ -387,6 +401,10 @@ bool SecurityOrigin::CanRequest(const KURL& url) const {
 }
 
 bool SecurityOrigin::CanReadContent(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (CanRequest(url))
     return true;
 
@@ -401,6 +419,10 @@ bool SecurityOrigin::CanReadContent(const KURL& url) const {
 }
 
 bool SecurityOrigin::CanDisplay(const KURL& url) const {
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
   if (universal_access_)
     return true;
 
@@ -422,8 +444,12 @@ bool SecurityOrigin::CanDisplay(const KURL& url) const {
 }
 
 bool SecurityOrigin::IsPotentiallyTrustworthy() const {
-  // TODO(lukasza): The code below can hopefully be eventually deleted and
-  // IsOriginPotentiallyTrustworthy can be used instead (from
+  if(::blink::IPCFuzzerCore::GetInstance()->checks_deactivated){
+    //DISABLED_CHECK
+    return true;
+  }
+  // TODO(https://crbug.com/1153336): The code below can hopefully be eventually
+  // deleted and IsOriginPotentiallyTrustworthy can be used instead (from
   // //services/network/public/cpp/is_potentially_trustworthy.h).
 
   DCHECK_NE(protocol_, "data");
