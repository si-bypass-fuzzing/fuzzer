"""
WebIDL grammar representation

- Parses JSON files generated by webidl2json
- The JSON files must follow the webidl standard:
  - https://webidl.spec.whatwg.org/#idl-names
  - https://github.com/w3c/webidl2.js/
- We make the following assumptions about deviations from the standard.
  - (All assumptions are guarded by assertions)
  - the `parent` field is never used
"""

from functools import lru_cache
import os
import random
from typing import Iterator, List, Set, TypeVar
import json
import logging
from .webidl import interfaces, entities, operation, types as webidl_types, var
from .js import builtin, js, types as js_types
from ..util import DictSerializable, ListSet
from .html import mapping, mdn_parser
from ..exception import GrammarLookupError
from .cache import GeneratorCache

type PossiblyPartial = interfaces.Interface | interfaces.CallbackInterface | interfaces.Namespace | interfaces.Mixin | entities.Dictionary
type InterfaceLike = interfaces.Interface | interfaces.Namespace


class Grammar(DictSerializable):
    """
    Grammar class that parses and represents the entire webidl grammar
    """

    def __init__(self):
        self.interfaces: dict[str, interfaces.Interface] = {}
        self.callback_interfaces: dict[str, interfaces.CallbackInterface] = {}
        self.namespaces: dict[str, interfaces.Namespace] = {}
        self.mixins: dict[str, interfaces.Mixin] = {}
        self.enums: dict[str, entities.Enum] = {}
        self.dictionaries: dict[str, entities.Dictionary] = {}
        self.typedefs: dict[str, entities.Typedef] = {}
        self.includes: Set[entities.Include] = set()
        self.callbacks: dict[str, operation.Callback] = {}

        self.partials: dict[str, List[PossiblyPartial]] = {}

        self.js_builtin_classes: dict[str, js.Class] = builtin.get_builtin_classes()
        self.js_builtin_functions: dict[str, js.Function] = (
            builtin.get_builtin_functions()
        )
        self.js_builtin_constants: dict[str, js.Constant] = (
            builtin.get_builtin_constants()
        )

        self.caches = {"Window": GeneratorCache(), "ServiceWorker": GeneratorCache()}

        # caches for generator lookups
        # self.instantiable_callees: ListSet[str] = ListSet()
        # self.generator_cache: dict[str, ListSet[tuple[js.Class, js.Member]]] = {}
        # self.static_func_cache: dict[str, ListSet[tuple[js.Class, js.Function]]] = {}

    def parse_file(self, filepath: str) -> None:
        """Parse a webidl2js JSON file and add the contents to the grammar

        Args:
            filepath (str): path to the JSON file
        """
        with open(filepath, "r", encoding="utf-8") as f:
            data = json.load(f)
            self.parse_webidl2js_dict(data)

    def parse_dir(self, dirpath: str) -> None:
        for root, _, files in os.walk(dirpath):
            for file in files:
                if file.endswith(".json"):
                    self.parse_file(os.path.join(root, file))

    def parse_webidl2js_dict(self, data: dict) -> None:
        """Parse a webidl2js JSON dict and add the contents to the grammar

        Args:
            data (dict): webidl2js JSON dict

        Raises:
            GrammarLookupError: if an unexpected type value is encountered
        """
        for entity in data:
            match entity["type"]:
                case "interface":
                    new_interface = interfaces.Interface.from_webidl2js_dict(entity)
                    if new_interface.partial:
                        if new_interface.name not in self.partials:
                            self.partials[new_interface.name] = []
                        self.partials[new_interface.name].append(new_interface)
                        logging.debug("Added partial interface %s", new_interface.name)
                    else:
                        # assert new_interface.name not in self.interfaces
                        self.interfaces[new_interface.name] = new_interface
                        logging.debug("Added interface %s", new_interface.name)
                case "callback interface":
                    new_callback_interface = (
                        interfaces.CallbackInterface.from_webidl2js_dict(entity)
                    )
                    if new_callback_interface.partial:
                        if new_callback_interface.name not in self.partials:
                            self.partials[new_callback_interface.name] = []
                        self.partials[new_callback_interface.name].append(
                            new_callback_interface
                        )
                        logging.debug(
                            "Added partial callback interface %s",
                            new_callback_interface.name,
                        )
                    else:
                        # assert (
                        #     new_callback_interface.name not in self.callback_interfaces
                        # )
                        self.callback_interfaces[new_callback_interface.name] = (
                            new_callback_interface
                        )
                        logging.debug(
                            "Added callback interface %s", new_callback_interface.name
                        )
                case "namespace":
                    new_namespace = interfaces.Namespace.from_webidl2js_dict(entity)
                    if new_namespace.partial:
                        if new_namespace.name not in self.partials:
                            self.partials[new_namespace.name] = []
                        self.partials[new_namespace.name].append(new_namespace)
                        logging.debug("Added partial namespace %s", new_namespace.name)
                    else:
                        # assert new_namespace.name not in self.namespaces
                        self.namespaces[new_namespace.name] = new_namespace
                        logging.debug("Added namespace %s", new_namespace.name)
                case "interface mixin":
                    new_mixin = interfaces.Mixin.from_webidl2js_dict(entity)
                    if new_mixin.partial:
                        if new_mixin.name not in self.partials:
                            self.partials[new_mixin.name] = []
                        self.partials[new_mixin.name].append(new_mixin)
                        logging.debug("Added partial mixin %s", new_mixin.name)
                    else:
                        # assert new_mixin.name not in self.mixins
                        self.mixins[new_mixin.name] = new_mixin
                        logging.debug("Added mixin %s", new_mixin.name)
                case "enum":
                    new_enum = entities.Enum.from_webidl2js_dict(entity)
                    # assert new_enum.name not in self.enums
                    self.enums[new_enum.name] = new_enum
                    logging.debug("Added enum %s", new_enum.name)
                case "dictionary":
                    new_dictionary = entities.Dictionary.from_webidl2js_dict(entity)
                    if new_dictionary.partial:
                        if new_dictionary.name not in self.partials:
                            self.partials[new_dictionary.name] = []
                        self.partials[new_dictionary.name].append(new_dictionary)
                        logging.debug(
                            "Added partial dictionary %s", new_dictionary.name
                        )
                    else:
                        # assert new_dictionary.name not in self.dictionaries
                        self.dictionaries[new_dictionary.name] = new_dictionary
                        logging.debug("Added dictionary %s", new_dictionary.name)
                case "typedef":
                    new_typedef = entities.Typedef.from_webidl2js_dict(entity)
                    # assert new_typedef.name not in self.typedefs
                    self.typedefs[new_typedef.name] = new_typedef
                    logging.debug(
                        "Added typedef %s to %s", new_typedef.name, new_typedef.idl_type
                    )
                case "includes":
                    new_include = entities.Include.from_webidl2js_dict(entity)
                    # assert new_include not in self.includes
                    self.includes.add(new_include)
                    logging.debug(
                        "Added include %s includes %s",
                        new_include.target,
                        new_include.includes,
                    )
                case "callback":
                    new_callback = operation.Callback.from_webidl2js_dict(entity)
                    # assert new_callback.name not in self.callbacks
                    self.callbacks[new_callback.name] = new_callback
                    logging.debug("Added callback %s", new_callback.name)
                case "bodyless interface":
                    logging.debug("Ignoring bodyless interface %s", entity["name"])
                case "callback constructor":
                    # TODO: implement callback constructor
                    logging.warn(
                        "Not Implemented: callback constructor %s", entity["name"]
                    )
                case _:
                    raise GrammarLookupError(f"Unknown type: {entity['type']}")

    def process_includes(self) -> None:
        """
        Process all include statements from self.includes
        and add the mixins to the target interfaces.
        """
        for include in self.includes:
            target_interface = self.interfaces.get(include.target, None)
            if target_interface is None:
                logging.warning("Include target %s not found", include.target)
                continue
            success: bool = False
            # 1. step: search for non-partial mixin
            mixin = self.mixins.get(include.includes, None)
            if mixin is not None:
                target_interface.add_mixin(mixin)
                success = True
                logging.debug("Added mixin %s to %s", mixin.name, target_interface.name)

            # 2. step: search for partial mixins
            for partial in self.partials.get(include.includes, []):
                if isinstance(partial, interfaces.Mixin):
                    target_interface.add_mixin(partial)
                    success = True
                    logging.debug(
                        "Added partial mixin %s to %s",
                        partial.name,
                        target_interface.name,
                    )
                else:
                    logging.warning("Include includes %s not a mixin", include.includes)

            if not success:
                logging.warning("Include includes %s not found", include.includes)
                continue

    def process_partials(self) -> None:
        """Process all partial definitions from self.partials
        and add them to their respective targets.
        Deletes all processed partials from self.partials

        Raises:
            GrammarLookupError: if an unknown partial type is encountered
        """
        unprocessed_partials: dict[str, List[PossiblyPartial]] = {}
        for name, partials in self.partials.items():
            for partial in partials:
                if isinstance(partial, interfaces.CallbackInterface):
                    target = self.callback_interfaces.get(name, None)
                elif isinstance(partial, interfaces.Namespace):
                    target = self.namespaces.get(name, None)
                elif isinstance(partial, interfaces.Mixin):
                    # sometimes there is no non-partial parent mixins
                    # thus we simply add all partial mixins to the target during the include processing
                    # without preprocessing the partials
                    if name not in unprocessed_partials:
                        unprocessed_partials[name] = []
                    unprocessed_partials[name].append(partial)
                    logging.debug("Skipped partial mixin %s", partial.name)
                    continue
                elif isinstance(partial, entities.Dictionary):
                    target = self.dictionaries.get(name, None)
                elif isinstance(partial, interfaces.Interface):
                    target = self.interfaces.get(name, None)
                else:
                    raise GrammarLookupError(f"Unknown partial type: {partial}")
                if target is None:
                    logging.warning("Partial target %s not found", name)
                    if name not in unprocessed_partials:
                        unprocessed_partials[name] = []
                    unprocessed_partials[name].append(partial)
                    continue
                target.add_partial(partial)  # type: ignore # TODO could fix this by adding a base class for partials
                logging.debug("Added partial %s to main entity", name)

        # overwrite self.partials with the unprocessed partials
        # thus deleting all processed partials
        self.partials = unprocessed_partials

    def link_inheritance(self) -> None:
        """Link all classes to their respective parent classes
        This allows us to quickly traverse the inheritance chain and search for inherited members
        """

        T = TypeVar("T", bound=js.Class | interfaces.Interface)

        def apply_inheritance_links_to_classes(
            d: dict[str, T], builtin_classes: dict[str, js.Class] | None = None
        ) -> None:
            for element in d.values():
                if element.inheritance is not None and isinstance(
                    element.inheritance, str
                ):
                    parent: js.Class | None = d.get(element.inheritance, None)
                    if parent is None and builtin_classes is not None:
                        # fallback to builtin classes
                        parent = builtin_classes.get(element.inheritance, None)
                    if parent is None:
                        logging.warning(
                            "Parent interface %s not found", element.inheritance
                        )
                        continue
                    element.link_parent(parent)

        apply_inheritance_links_to_classes(self.js_builtin_classes)
        apply_inheritance_links_to_classes(self.interfaces, self.js_builtin_classes)
        apply_inheritance_links_to_classes(self.namespaces, self.js_builtin_classes)

        for dictionary in self.dictionaries.values():
            if dictionary.inheritance is not None and isinstance(
                dictionary.inheritance, str
            ):
                parent = self.dictionaries.get(dictionary.inheritance, None)
                if parent is None:
                    logging.warning(
                        "Parent dictionary %s not found", dictionary.inheritance
                    )
                    continue
                dictionary.link_parent(parent)

    def add_html_tags(self) -> None:
        """Add HTML tags to the interfaces of HTML element handles"""
        for interface_name, tag in mapping.WEBIDL_TO_TAG.items():
            try:
                interface = self.interfaces[interface_name]
                interface.set_html_tag(tag)
            except KeyError:
                logging.warning("HTML element %s not found", interface_name)

    def finalize(self) -> None:
        """Finalize the grammar by processing partials and includes"""
        # IMPORTANT: must process partials first,
        # to add partial to mixins before adding mixins to interfaces
        self.interfaces["WindowProxy"] = interfaces.Interface(
            "WindowProxy", [], [], "Window"
        )
        self.resolve_typedefs()
        self.process_partials()
        self.process_includes()
        self.link_inheritance()
        self.instantiable_callees: ListSet[str] = ListSet(
            self.iter_callee_identifiers(["Window"])
        )

    def enhance_html_grammar(self, mdn_path: str) -> None:
        """Enhance the grammar with information from MDN

        Args:
            mdn_path (str): path to the MDN docs
        """
        self.add_html_tags()
        self.add_keyword_hints_for_html(mdn_path)

    def add_keyword_hints_for_html(self, mdn_path: str) -> None:
        """Scrape MDN for HTML attribute keywords and add them to the grammar as hints"""
        for iface in self.interfaces.values():
            if iface.name.startswith("HTML") and iface.name.endswith("Element"):

                if iface.name == "HTMLElement":
                    # TODO scrape std attributes?
                    continue

                if iface.name in [
                    "HTMLModElement",
                    "HTMLMediaElement",
                    "HTMLQuoteElement",
                ]:
                    # we could scrape the JS API MDN docs for these
                    # however, there are no keyword attributes in these interfaces
                    continue

                if iface.name == "HTMLUnknownElement":
                    continue  # no MDN docs for this

                if iface.html_tag is None:
                    continue

                # assert iface.html_tag is not None
                try:
                    attributes = mdn_parser.get_attributes(iface.html_tag, mdn_path)
                    # add keyword hints to the right string attributes
                    for member in iface.get_members(inherited=False):
                        if isinstance(member, var.Attribute):
                            if (
                                isinstance(member.var_type, webidl_types.PrimitiveType)
                                and member.var_type.primitive == "string"
                            ) or (
                                member.is_put_forwards()
                                and self.get_put_forwards_type(member).matches(
                                    js_types.STRING()
                                )
                            ):
                                keywords = attributes.get(member.name.lower(), [])
                                if len(keywords) > 0:
                                    member.var_type = member.var_type.hint(
                                        {"keyword": keywords}
                                    )
                                else:
                                    logging.warning(
                                        "No keywords found for %s.%s",
                                        iface.html_tag,
                                        member.name,
                                    )
                except FileNotFoundError:
                    logging.error("No MDN file found for %s", iface.html_tag)

    def to_dict(self) -> dict:
        """Return the whole grammar as a serilizable dict

        Returns:
            dict: grammar as a dict
        """
        return {
            "js": {
                "classes": [cls.to_dict() for cls in self.js_builtin_classes.values()],
                "functions": [
                    func.to_dict() for func in self.js_builtin_functions.values()
                ],
                "constants": [
                    const.to_dict() for const in self.js_builtin_constants.values()
                ],
            },
            "browser": {
                "interfaces": [
                    interface.to_dict() for interface in self.interfaces.values()
                ],
                "callback_interfaces": [
                    callback_interface.to_dict()
                    for callback_interface in self.callback_interfaces.values()
                ],
                "namespaces": [
                    namespace.to_dict() for namespace in self.namespaces.values()
                ],
                "mixins": [mixin.to_dict() for mixin in self.mixins.values()],
                "enums": [enum.to_dict() for enum in self.enums.values()],
                "dictionaries": [
                    dictionary.to_dict() for dictionary in self.dictionaries.values()
                ],
                "typedefs": [typedef.to_dict() for typedef in self.typedefs.values()],
                "includes": [include.to_dict() for include in self.includes],
                "callbacks": [
                    callback.to_dict() for callback in self.callbacks.values()
                ],
                "partials": {
                    name: [partial.to_dict() for partial in partials]
                    for name, partials in self.partials.items()
                },
            },
        }

    def write(self, filepath: str) -> None:
        """Write the grammar in JSON format to a file

        Args:
            filepath (str): path to the file
        """
        with open(filepath, "w", encoding="utf-8") as f:
            f.write(self.to_json())

    def get_webidls(self) -> Iterator[InterfaceLike]:
        """Yield all webidl elements

        Yields:
            WebIDLElement: webidl element
        """
        for interface in self.interfaces.values():
            yield interface
        for namespace in self.namespaces.values():
            yield namespace

    def check_exposed_ext_attr(
        self, element: InterfaceLike, exposed_to:  list[str]
    ) -> bool:
        for attr in element.ext_attrs:
            if attr.name == "RuntimeEnabled":
                return False
        for attr in element.ext_attrs:
            if attr.name == "Exposed":
                # Chrome: check extended arguments in arguments list
                for ext_arg in attr.arguments:
                    if isinstance(ext_arg.idl_type, webidl_types.InterfaceType) and ext_arg.idl_type.class_name in exposed_to:
                        return True

                # Firefox: check type dict in rhs
                rhs_type: str = attr.rhs.get("type", "")
                match rhs_type:
                    case "*":
                        return True
                    case "identifier":
                        value = attr.rhs.get("value", "")
                        return value in exposed_to or value == "*"
                    case "identifier-list":
                        for d in attr.rhs.get("value", []):
                            assert isinstance(d, dict)
                            if d["value"] in exposed_to or d["value"] == "*":
                                return True
                    case _:
                        # logging.warning("%s: Unknown Exposed type %s", element.name, rhs_type)
                        pass
        return False

    def check_member_exposed_ext_attr(self, member: interfaces.Member ) -> bool:
        for attr in member.ext_attrs:
            if attr.name == "RuntimeEnabled":
                return False
        return True

    def iter_visible_definitions(
        self, scope: str| list[str]
    ) -> Iterator[js.Class | entities.Dictionary | entities.Enum]:
        """Yield all elements that possess properties and are visible in the global scope"""
        for builtin in self.js_builtin_classes.values():
            yield builtin

        if isinstance(scope, str):
            scope = [scope]

        for webidl_element in self.get_webidls():
            if webidl_element.name in scope:
                # yield the global window element
                yield webidl_element
            else:
                # yield all elements that are exposed to window via extended attribute
                if self.check_exposed_ext_attr(webidl_element,scope):
                    yield webidl_element

    def iter_visible_classes(self, scope: str| list[str]) -> Iterator[js.Class | interfaces.Interface | interfaces.Namespace]:
        """Yield all interface-like elements that are visible in the global scope"""
        if isinstance(scope, str):
            scope = [scope]
        for builtin in self.js_builtin_classes.values():
            yield builtin
        for interface in self.interfaces.values():
            if interface.name in scope or self.check_exposed_ext_attr(interface,scope):
                yield interface
        for namespace in self.namespaces.values():
            if self.check_exposed_ext_attr(namespace,scope):
                yield namespace

    def iter_visible_namespaces(self, scope: str| list[str]) -> Iterator[interfaces.Namespace]:
        """Yield all namespaces that are visible in the global scope"""
        if isinstance(scope, str):
            scope = [scope]
        for namespace in self.namespaces.values():
            if self.check_exposed_ext_attr(namespace,scope):
                yield namespace

    def find_class(self, name: str) -> js.Class:
        """Find a class by name
        A class can be a JS builtin class, an interface, a mixin, a namespace, or a callback interface

        Args:
            name (str): name of the class

        Returns:
            js.Class: the class
        """
        if name in self.js_builtin_classes:
            return self.js_builtin_classes[name]
        if name in self.interfaces:
            return self.interfaces[name]
        if name in self.callback_interfaces:
            return self.callback_interfaces[name]
        if name in self.namespaces:
            return self.namespaces[name]
        if name in self.mixins:
            return self.mixins[name]
        raise GrammarLookupError(f"Class {name} not found in grammar")

    def find_interface(self, name: str) -> interfaces.Interface:
        if name in self.interfaces:
            return self.interfaces[name]
        raise GrammarLookupError(f"Interface {name} not found in grammar")

    def find_interfacelike(self, name: str) -> InterfaceLike:
        try:
            return self.find_interface(name)
        except GrammarLookupError:
            pass

        try:
            return self.namespaces[name]
        except KeyError:
            pass

        raise GrammarLookupError(f"Interface-like {name} not found in grammar")

    def find_dictionary(self, name: str) -> entities.Dictionary:
        """Find a dictionary by name

        Args:
            name (str): name of the dictionary

        Returns:
            interface.Dictionary: the dictionary
        """
        if name in self.dictionaries:
            return self.dictionaries[name]
        raise GrammarLookupError(f"Dictionary {name} not found in grammar")

    def find_enum(self, name: str) -> entities.Enum:
        """Find an enum by name

        Args:
            name (str): name of the enum

        Returns:
            interface.Enum: the enum
        """
        if name in self.enums:
            return self.enums[name]
        raise GrammarLookupError(f"Enum {name} not found in grammar")

    def find_instantiatable(
        self, name: str
    ) -> js.Class | entities.Dictionary | entities.Enum:
        """Search for a definition of an instantiable element by name
        Classes, dictionaries and enums are instantiable"""
        try:
            return self.find_class(name)
        except GrammarLookupError:
            pass

        try:
            return self.find_dictionary(name)
        except GrammarLookupError:
            pass

        try:
            return self.find_enum(name)
        except GrammarLookupError:
            pass

        raise GrammarLookupError(f"Instantiable {name} not found in grammar")

    def is_lineage(self, child: str, parent: str) -> bool:
        """Check if child inherits from parent
        Searches for the parent in the inheritance chain of the child
        Also resolves typedefs"""
        try:
            child_cls = self.find_class(child)
            # parent_cls = self.find_class(parent)
            return child_cls.inherits(parent)
        except GrammarLookupError:
            pass

        return False

    def get_put_forwards_type(self, attr: var.Attribute) -> js_types.Type:
        """Get the putForwards type for an attribute"""
        assert isinstance(attr.var_type, js_types.ObjectType)
        if attr.ext_attrs is None:
            raise GrammarLookupError("Attribute has no extended attributes")

        # evaluate the PutForwards extended attribute
        target = None
        for ext_attr in attr.ext_attrs:
            if ext_attr.name == "PutForwards":
                target = ext_attr.rhs.get("value", None)
                break
        if target is None:
            raise GrammarLookupError("Attribute has no PutForwards extended attribute")

        # find the attribuet of the interface that PutForwards points to
        interface: interfaces.Interface = self.find_interface(attr.var_type.class_name)
        for member in interface.get_members(inherited=True):
            if isinstance(member, var.Attribute) and member.name == target:
                return member.var_type

        raise GrammarLookupError(
            f"PutForwards target {target} not found in {interface.name}"
        )

    # def get_rand_callee(self) -> interfaces.Interface | interfaces.Namespace:
    #     """Get a random callee from the grammar"""

    #     # TODO: implement weighted rand

    #     total_len = len(self.interfaces) + len(self.namespaces)
    #     rand = random.randint(0, total_len - 1)

    #     if rand < len(self.interfaces):
    #         return list(self.interfaces.values())[rand]
    #     else:
    #         return list(self.namespaces.values())[rand - len(self.interfaces)]

    # TODO: must be visible in scope
    def iter_callee_identifiers(self, scope: list[str]) -> Iterator[str]:
        """Iterate over all possible callees"""
        for name, interface in self.interfaces.items():
            if name in scope or self.check_exposed_ext_attr(interface,scope):
                yield name
        for name, namespace in self.namespaces.items():
            if name in scope or self.check_exposed_ext_attr(namespace,scope):
                yield name

    def number_of_callees(self) -> int:
        """Get the number of possible callees"""
        return len(self.interfaces) + len(self.namespaces)

    def resolve_typedefs(self) -> None:
        """Resolve all typedefs in the grammar by replacing the typedef identifier with the actual type"""
        self.clean_typedefs()

        # iterate over every object that may contain typedef identifiers
        for interface in self.interfaces.values():
            interface.replace_typedefs(self.typedefs)
        for callback_interface in self.callback_interfaces.values():
            callback_interface.replace_typedefs(self.typedefs)
        for namespace in self.namespaces.values():
            namespace.replace_typedefs(self.typedefs)
        for mixin in self.mixins.values():
            mixin.replace_typedefs(self.typedefs)
        for dictionary in self.dictionaries.values():
            dictionary.replace_typedefs(self.typedefs)
        for callback in self.callbacks.values():
            callback.replace_typedefs(self.typedefs)

        # TODO: flatten nested unions

    def clean_typedefs(self) -> None:
        """Resolve all typedefs in the grammar by   replacing the typedef identifier with the actual type
        Handle recursive typedefs. Afterwards flatten nested unions"""

        cleaned_typedefs: dict[str, entities.Typedef] = {}
        modified: bool = True
        while modified:
            modified = False
            for typedef in self.typedefs.values():
                if typedef.name in cleaned_typedefs:
                    continue
                success, resolved = self.recursively_resolve_typedefs(
                    typedef.idl_type, cleaned_typedefs
                )
                if success:
                    if resolved is not None:
                        typedef.idl_type = resolved
                        cleaned_typedefs[typedef.name] = typedef
                        modified = True
                    else:
                        raise Exception(
                            "successfully resolved typedef but no replacement type"
                        )

        assert len(cleaned_typedefs) == len(self.typedefs)
        self.typedefs = cleaned_typedefs

    def recursively_resolve_typedefs(
        self, idl_type: js_types.Type, cleaned_typedefs: dict[str, entities.Typedef]
    ) -> tuple[bool, js_types.Type | None]:
        """Resolve recursive typedefs by replacing the typedef identifier with the actual type
        Returns true if all recursive typedefs could be resolved"""

        if isinstance(idl_type, js_types.PrimitiveType):
            return True, idl_type
        if isinstance(idl_type, js_types.UnionType):
            assert isinstance(idl_type, js_types.UnionType)
            success: list[bool] = []
            for i, t in enumerate(idl_type.types):
                s, nt = self.recursively_resolve_typedefs(t, cleaned_typedefs)
                success.append(s)
                if nt is not None:
                    idl_type.types[i] = nt
            return all(success), idl_type
        if isinstance(idl_type, js_types.ObjectType):
            assert isinstance(idl_type, js_types.ObjectType)
            # cases: cleaned typedef, uncleaned typedef, regular interface
            if idl_type.class_name in self.typedefs:
                if idl_type.class_name in cleaned_typedefs:
                    # cleaned typedef, replace with cleaned typedef
                    return True, cleaned_typedefs[idl_type.class_name].idl_type
                else:
                    return False, None
            else:
                # regular interface, resolve typedefs in inners
                success: list[bool] = []
                for i, t in enumerate(idl_type.inners):
                    s, nt = self.recursively_resolve_typedefs(t, cleaned_typedefs)
                    success.append(s)
                    if nt is not None:
                        idl_type.inners[i] = nt
                return all(success), idl_type
        if isinstance(idl_type, js_types.AnyType):
            return True, idl_type
        else:
            raise Exception("Unreachable")

    # @lru_cache(maxsize=None)
    def inherits(self, child: js_types.Type, parent: js_types.Type) -> bool:
        """Check if the child class inherits from the potential parent class
        Returns True if parent appears somewhere in the inheritance chain of child, False otherwise
        """
        if (
            isinstance(child, js_types.ObjectType)
            and isinstance(parent, js_types.ObjectType)
            and self.is_lineage(child.class_name, parent.class_name)
        ):
            return True
        return False

    # @lru_cache(maxsize=None)
    def is_match(self, var_type: js_types.Type, target_type: js_types.Type) -> bool:
        """Check if the type matches another type. Returns True if a variable of this type can be used as a parameter of the other type
        Also checks if var_type is an object that inherits from target_type"""
        if var_type.matches(target_type) or self.inherits(var_type, target_type):
            return True
        return False

    def mark_uninstantiable(self, api_scope:str, name: str) -> None:
        """Mark a class as uninstantiable"""
        self.caches[api_scope].instantiable_callees.remove(name)

    def get_static_funcs_by_return(self, api_scope: str, obj_type: js_types.ObjectType) -> ListSet[tuple[js.Class,js.Function]]:
        class_name: str = obj_type.class_name
        static_func_cache = self.caches[api_scope].static_func_cache
        if class_name in static_func_cache:
            return static_func_cache[class_name]

        funcs: ListSet[tuple[js.Class,js.Function]] = ListSet()
        for cls in self.iter_visible_classes(api_scope):
            is_namespace: bool = isinstance(cls, interfaces.Namespace)
            for member in cls.members:
                if not (isinstance(cls, interfaces.Interface) and not self.check_member_exposed_ext_attr(member)): #type: ignore
                    if isinstance(member, js.Function):
                        if (
                            (is_namespace or member.special == "static")
                            and member.special in ["", "stringifier"]
                            and self.is_match(member.ret.var_type, obj_type)
                        ):
                            funcs.add((cls, member))
        static_func_cache[class_name] = funcs
        return funcs

    def rand_iter_static_funcs_by_return(self, api_scope: str, obj_type: js_types.ObjectType) -> Iterator[tuple[js.Class,js.Function]]:
        return self.get_static_funcs_by_return(api_scope, js_types.ObjectType(obj_type.class_name)).rand_iter()

    def remove_static_func_from_cache(self, obj_type: js_types.ObjectType, gen_cls: js.Class, gen_func: js.Function):
        class_name: str = obj_type.class_name
        static_func_cache = self.caches[api_scope].static_func_cache
        if class_name in static_func_cache:
            static_func_cache[class_name].remove((gen_cls, gen_func))

    def get_potential_generators(self, api_scope:str, obj_type: js_types.ObjectType) -> ListSet[tuple[js.Class, js.Member]]:
        class_name = obj_type.class_name
        generator_cache = self.caches[api_scope].generator_cache
        if class_name in generator_cache:
            return generator_cache[class_name]

        definitions_in_scope: list[js.Class] = [
            elem
            for elem in self.iter_visible_classes(api_scope)
            if elem.name in self.caches[api_scope].instantiable_callees
        ]

        potential_generators: ListSet[tuple[js.Class, js.Member]] = ListSet()
        for cls in definitions_in_scope:
            for member in cls.members:
                # if the cls is a webidl interface, check if the member is exposed
                if not (isinstance(cls, interfaces.Interface) and not self.check_member_exposed_ext_attr(member)): #type: ignore
                    if isinstance(member, js.Function) and member.special in [
                        "",
                        "stringifier",
                    ]:
                        if self.is_match(member.ret.var_type, obj_type):
                            potential_generators.append((cls, member))
                    elif isinstance(member, js.Attribute):
                        if self.is_match(member.var_type, obj_type):
                            potential_generators.append((cls, member))

        generator_cache[class_name] = potential_generators
        return potential_generators

    def rand_iter_potential_generators(self, api_scope: str, obj_type: js_types.ObjectType) -> Iterator[tuple[js.Class, js.Member]]:
        return self.get_potential_generators(api_scope, obj_type).rand_iter()

    def remove_generator_from_cache(self, obj_type: js_types.ObjectType, gen_cls: js.Class, gen_member: js.Member):
        class_name: str = obj_type.class_name
        generator_cache = self.caches[api_scope].generator_cache
        if class_name in generator_cache:
            generator_cache[class_name].remove((gen_cls, gen_member))
